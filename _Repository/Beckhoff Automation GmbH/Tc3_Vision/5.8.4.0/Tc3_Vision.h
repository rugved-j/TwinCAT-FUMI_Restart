#pragma once

#pragma warning(push)
#pragma warning(disable : 26495 26812)

// Define the licenses you want to use as a preprocessor definition. Available:
// LIC_TC3_Vision_Base
// LIC_TC3_Vision_Code_Reading
// LIC_TC3_Vision_Code_Quality
// LIC_TC3_Vision_Metrology_2D
// LIC_TC3_Vision_Matching
// LIC_TC3_Vision_OCR
// LIC_TC3_Machine_Learning_Realtime_Inference
// LIC_TC3_Neural_Network_Realtime_Inference

#if !defined(_X64_) && !defined(_AMD64_)
	static_assert(false, "Unsupported architecture. Only x86-64 CPUs are supported. Select TwinCAT RT (x64) platform.");
#endif

#include "TcInterfaces.h"
#include <iterator>
#include <initializer_list>

////////////////////////////////////////////////////////////////////////////
// Tc3_VisionVersion.h

#ifndef Tc3_VisionVersion_H_INCLUDED
#define Tc3_VisionVersion_H_INCLUDED

#define Tc3_Vision_Version   5
#define Tc3_Vision_Revision  8
#define Tc3_Vision_Build     0

#define Tc3_Vision_FileVersionMajor    5
#define Tc3_Vision_FileVersionMinor    8
#define Tc3_Vision_FileVersionBuild    4
#define Tc3_Vision_FileVersionRevision 0
#define Tc3_Vision_FileVersionStr      "5.8.4.0"
#define Tc3_Vision_FileVersionRcStr    "5,8,4,0"

#define Tc3_Vision_ProductMajor        5
#define Tc3_Vision_ProductMinor        8
#define Tc3_Vision_ProductBuild        10
#define Tc3_Vision_ProductRevision     0
#define Tc3_Vision_ProductVersionStr   "5.8.10.0"
#define Tc3_Vision_ProductVersionRcStr "5,8,10,0"

#define Tc3_Vision_CompanyNameStr      "Beckhoff Automation GmbH"
#define Tc3_Vision_InternalNameStr     "Tc3_Vision"
#define Tc3_Vision_LibraryIdNameStr    "Beckhoff Automation GmbH|Tc3_Vision|5.8.4.0"

#ifndef RC_INVOKED
static const GUID VID_Tc3_Vision      = { 0x918b0775, 0xf502, 0x6e45, { 0xc7, 0x9d, 0xd7, 0xc9, 0x81, 0xe9, 0x0b, 0x28 } };
#endif

#endif // include guard

#if !defined(_TC_IID_2A45F794_2ECF_4340_9A69_A3AE84C60C9D_INCLUDED_)
#define _TC_IID_2A45F794_2ECF_4340_9A69_A3AE84C60C9D_INCLUDED_
TCOM_DECL_INTERFACE("2a45f794-2ecf-4340-9a69-a3ae84c60c9d", ITcIoFileImageAcquisition)
#endif // !defined(_TC_IID_2A45F794_2ECF_4340_9A69_A3AE84C60C9D_INCLUDED_)

#if !defined(_TC_IID_63EDCBEF_48BA_40D6_93FE_BB498E230FC7_INCLUDED_)
#define _TC_IID_63EDCBEF_48BA_40D6_93FE_BB498E230FC7_INCLUDED_
TCOM_DECL_INTERFACE("63edcbef-48ba-40d6-93fe-bb498e230fc7", ITcIoFileImageRecv)
#endif // !defined(_TC_IID_63EDCBEF_48BA_40D6_93FE_BB498E230FC7_INCLUDED_)

#if !defined(_TC_IID_238E9E96_5AEF_4E8B_9052_C371A8C7BBED_INCLUDED_)
#define _TC_IID_238E9E96_5AEF_4E8B_9052_C371A8C7BBED_INCLUDED_
TCOM_DECL_INTERFACE("238e9e96-5aef-4e8b-9052-c371a8c7bbed", ITcIoGevImage)
#endif // !defined(_TC_IID_238E9E96_5AEF_4E8B_9052_C371A8C7BBED_INCLUDED_)

#if !defined(_TC_IID_3CCE1940_FF2A_4594_9FB0_40033A186838_INCLUDED_)
#define _TC_IID_3CCE1940_FF2A_4594_9FB0_40033A186838_INCLUDED_
TCOM_DECL_INTERFACE("3cce1940-ff2a-4594-9fb0-40033a186838", ITcIoGevImageAcquisition)
#endif // !defined(_TC_IID_3CCE1940_FF2A_4594_9FB0_40033A186838_INCLUDED_)

#if !defined(_TC_IID_D245C557_353A_4D5F_A69A_DDF424681A3C_INCLUDED_)
#define _TC_IID_D245C557_353A_4D5F_A69A_DDF424681A3C_INCLUDED_
TCOM_DECL_INTERFACE("d245c557-353a-4d5f-a69a-ddf424681a3c", ITcIoImageAcquisition)
#endif // !defined(_TC_IID_D245C557_353A_4D5F_A69A_DDF424681A3C_INCLUDED_)

#if !defined(_TC_IID_3404B97C_9B43_42E9_9D95_3DB0DA598A36_INCLUDED_)
#define _TC_IID_3404B97C_9B43_42E9_9D95_3DB0DA598A36_INCLUDED_
TCOM_DECL_INTERFACE("3404b97c-9b43-42e9-9d95-3db0da598a36", ITcIoImageRecv)
#endif // !defined(_TC_IID_3404B97C_9B43_42E9_9D95_3DB0DA598A36_INCLUDED_)

#if !defined(_TC_IID_0EDD1F90_35E9_4368_8ED9_EF04662E5E31_INCLUDED_)
#define _TC_IID_0EDD1F90_35E9_4368_8ED9_EF04662E5E31_INCLUDED_
TCOM_DECL_INTERFACE("0edd1f90-35e9-4368-8ed9-ef04662e5e31", ITcSerializableNotification)
#endif // !defined(_TC_IID_0EDD1F90_35E9_4368_8ED9_EF04662E5E31_INCLUDED_)

#if !defined(_TC_IID_B976A700_680B_4D98_A422_3DAAB772CDA7_INCLUDED_)
#define _TC_IID_B976A700_680B_4D98_A422_3DAAB772CDA7_INCLUDED_
TCOM_DECL_INTERFACE("b976a700-680b-4d98-a422-3daab772cda7", ITcVnAccess_DINT)
#endif // !defined(_TC_IID_B976A700_680B_4D98_A422_3DAAB772CDA7_INCLUDED_)

#if !defined(_TC_IID_EA71C8AC_0D0A_4EB4_BC0D_41E921E1B80C_INCLUDED_)
#define _TC_IID_EA71C8AC_0D0A_4EB4_BC0D_41E921E1B80C_INCLUDED_
TCOM_DECL_INTERFACE("ea71c8ac-0d0a-4eb4-bc0d-41e921e1b80c", ITcVnAccess_INT)
#endif // !defined(_TC_IID_EA71C8AC_0D0A_4EB4_BC0D_41E921E1B80C_INCLUDED_)

#if !defined(_TC_IID_82C08AE5_D6D8_42EF_A019_AD4009CD9D7C_INCLUDED_)
#define _TC_IID_82C08AE5_D6D8_42EF_A019_AD4009CD9D7C_INCLUDED_
TCOM_DECL_INTERFACE("82c08ae5-d6d8-42ef-a019-ad4009cd9d7c", ITcVnAccess_ITcVnImage)
#endif // !defined(_TC_IID_82C08AE5_D6D8_42EF_A019_AD4009CD9D7C_INCLUDED_)

#if !defined(_TC_IID_6D67E62F_71CE_4246_BFBA_598CBC724667_INCLUDED_)
#define _TC_IID_6D67E62F_71CE_4246_BFBA_598CBC724667_INCLUDED_
TCOM_DECL_INTERFACE("6d67e62f-71ce-4246-bfba-598cbc724667", ITcVnAccess_LREAL)
#endif // !defined(_TC_IID_6D67E62F_71CE_4246_BFBA_598CBC724667_INCLUDED_)

#if !defined(_TC_IID_21AEB775_EF11_4F5F_A93D_84005AC02C23_INCLUDED_)
#define _TC_IID_21AEB775_EF11_4F5F_A93D_84005AC02C23_INCLUDED_
TCOM_DECL_INTERFACE("21aeb775-ef11-4f5f-a93d-84005ac02c23", ITcVnAccess_REAL)
#endif // !defined(_TC_IID_21AEB775_EF11_4F5F_A93D_84005AC02C23_INCLUDED_)

#if !defined(_TC_IID_0487C72D_26A8_4216_8606_07B28D49DF16_INCLUDED_)
#define _TC_IID_0487C72D_26A8_4216_8606_07B28D49DF16_INCLUDED_
TCOM_DECL_INTERFACE("0487c72d-26a8-4216-8606-07b28d49df16", ITcVnAccess_SINT)
#endif // !defined(_TC_IID_0487C72D_26A8_4216_8606_07B28D49DF16_INCLUDED_)

#if !defined(_TC_IID_6AE5D2B2_3BF7_458C_9FE2_B3074B61AD63_INCLUDED_)
#define _TC_IID_6AE5D2B2_3BF7_458C_9FE2_B3074B61AD63_INCLUDED_
TCOM_DECL_INTERFACE("6ae5d2b2-3bf7-458c-9fe2-b3074b61ad63", ITcVnAccess_TcVnDMatch)
#endif // !defined(_TC_IID_6AE5D2B2_3BF7_458C_9FE2_B3074B61AD63_INCLUDED_)

#if !defined(_TC_IID_69643CDD_657E_4B26_8CED_A86941BB515F_INCLUDED_)
#define _TC_IID_69643CDD_657E_4B26_8CED_A86941BB515F_INCLUDED_
TCOM_DECL_INTERFACE("69643cdd-657e-4b26-8ced-a86941bb515f", ITcVnAccess_TcVnKeyPoint)
#endif // !defined(_TC_IID_69643CDD_657E_4B26_8CED_A86941BB515F_INCLUDED_)

#if !defined(_TC_IID_BB5FA424_DAEE_4975_8991_89171FB03AFB_INCLUDED_)
#define _TC_IID_BB5FA424_DAEE_4975_8991_89171FB03AFB_INCLUDED_
TCOM_DECL_INTERFACE("bb5fa424-daee-4975-8991-89171fb03afb", ITcVnAccess_TcVnPoint2_DINT)
#endif // !defined(_TC_IID_BB5FA424_DAEE_4975_8991_89171FB03AFB_INCLUDED_)

#if !defined(_TC_IID_3381410F_F244_4B92_98CA_720F421FFA9C_INCLUDED_)
#define _TC_IID_3381410F_F244_4B92_98CA_720F421FFA9C_INCLUDED_
TCOM_DECL_INTERFACE("3381410f-f244-4b92-98ca-720f421ffa9c", ITcVnAccess_TcVnPoint2_LREAL)
#endif // !defined(_TC_IID_3381410F_F244_4B92_98CA_720F421FFA9C_INCLUDED_)

#if !defined(_TC_IID_F1235D2C_E536_4B4D_9AA5_79B069D44B6A_INCLUDED_)
#define _TC_IID_F1235D2C_E536_4B4D_9AA5_79B069D44B6A_INCLUDED_
TCOM_DECL_INTERFACE("f1235d2c-e536-4b4d-9aa5-79b069d44b6a", ITcVnAccess_TcVnPoint2_REAL)
#endif // !defined(_TC_IID_F1235D2C_E536_4B4D_9AA5_79B069D44B6A_INCLUDED_)

#if !defined(_TC_IID_885CF0CB_8571_4517_A3AC_44A9B734D71D_INCLUDED_)
#define _TC_IID_885CF0CB_8571_4517_A3AC_44A9B734D71D_INCLUDED_
TCOM_DECL_INTERFACE("885cf0cb-8571-4517-a3ac-44a9b734d71d", ITcVnAccess_TcVnPoint3_LREAL)
#endif // !defined(_TC_IID_885CF0CB_8571_4517_A3AC_44A9B734D71D_INCLUDED_)

#if !defined(_TC_IID_9C920E2C_99F0_4681_B240_F6937115D395_INCLUDED_)
#define _TC_IID_9C920E2C_99F0_4681_B240_F6937115D395_INCLUDED_
TCOM_DECL_INTERFACE("9c920e2c-99f0-4681-b240-f6937115d395", ITcVnAccess_TcVnPoint3_REAL)
#endif // !defined(_TC_IID_9C920E2C_99F0_4681_B240_F6937115D395_INCLUDED_)

#if !defined(_TC_IID_788837B1_9E55_43A4_AF2B_1B81D5D3C276_INCLUDED_)
#define _TC_IID_788837B1_9E55_43A4_AF2B_1B81D5D3C276_INCLUDED_
TCOM_DECL_INTERFACE("788837b1-9e55-43a4-af2b-1b81d5d3c276", ITcVnAccess_TcVnRectangle_DINT)
#endif // !defined(_TC_IID_788837B1_9E55_43A4_AF2B_1B81D5D3C276_INCLUDED_)

#if !defined(_TC_IID_BF344472_E777_4038_B2AD_DA8886316120_INCLUDED_)
#define _TC_IID_BF344472_E777_4038_B2AD_DA8886316120_INCLUDED_
TCOM_DECL_INTERFACE("bf344472-e777-4038-b2ad-da8886316120", ITcVnAccess_TcVnRotatedRectangle)
#endif // !defined(_TC_IID_BF344472_E777_4038_B2AD_DA8886316120_INCLUDED_)

#if !defined(_TC_IID_7C3899C4_4A43_4F7D_980E_27692F5C803E_INCLUDED_)
#define _TC_IID_7C3899C4_4A43_4F7D_980E_27692F5C803E_INCLUDED_
TCOM_DECL_INTERFACE("7c3899c4-4a43-4f7d-980e-27692f5c803e", ITcVnAccess_TcVnVector2_DINT)
#endif // !defined(_TC_IID_7C3899C4_4A43_4F7D_980E_27692F5C803E_INCLUDED_)

#if !defined(_TC_IID_C094FF76_F4ED_4556_B23E_D688BEB8A0FF_INCLUDED_)
#define _TC_IID_C094FF76_F4ED_4556_B23E_D688BEB8A0FF_INCLUDED_
TCOM_DECL_INTERFACE("c094ff76-f4ed-4556-b23e-d688beb8a0ff", ITcVnAccess_TcVnVector2_INT)
#endif // !defined(_TC_IID_C094FF76_F4ED_4556_B23E_D688BEB8A0FF_INCLUDED_)

#if !defined(_TC_IID_F3273513_9CCC_4685_B709_62C964EC6C8A_INCLUDED_)
#define _TC_IID_F3273513_9CCC_4685_B709_62C964EC6C8A_INCLUDED_
TCOM_DECL_INTERFACE("f3273513-9ccc-4685-b709-62c964ec6c8a", ITcVnAccess_TcVnVector2_REAL)
#endif // !defined(_TC_IID_F3273513_9CCC_4685_B709_62C964EC6C8A_INCLUDED_)

#if !defined(_TC_IID_0925DD5F_990F_485E_8DEC_2A83E719410D_INCLUDED_)
#define _TC_IID_0925DD5F_990F_485E_8DEC_2A83E719410D_INCLUDED_
TCOM_DECL_INTERFACE("0925dd5f-990f-485e-8dec-2a83e719410d", ITcVnAccess_TcVnVector2_SINT)
#endif // !defined(_TC_IID_0925DD5F_990F_485E_8DEC_2A83E719410D_INCLUDED_)

#if !defined(_TC_IID_87224FDC_7436_43AB_BC6B_F65B3127132C_INCLUDED_)
#define _TC_IID_87224FDC_7436_43AB_BC6B_F65B3127132C_INCLUDED_
TCOM_DECL_INTERFACE("87224fdc-7436-43ab-bc6b-f65b3127132c", ITcVnAccess_TcVnVector2_UINT)
#endif // !defined(_TC_IID_87224FDC_7436_43AB_BC6B_F65B3127132C_INCLUDED_)

#if !defined(_TC_IID_475238AC_6DC0_4B71_8963_9FFB61837664_INCLUDED_)
#define _TC_IID_475238AC_6DC0_4B71_8963_9FFB61837664_INCLUDED_
TCOM_DECL_INTERFACE("475238ac-6dc0-4b71-8963-9ffb61837664", ITcVnAccess_TcVnVector2_USINT)
#endif // !defined(_TC_IID_475238AC_6DC0_4B71_8963_9FFB61837664_INCLUDED_)

#if !defined(_TC_IID_96CA0768_0293_4D60_AF79_F5575EB993B6_INCLUDED_)
#define _TC_IID_96CA0768_0293_4D60_AF79_F5575EB993B6_INCLUDED_
TCOM_DECL_INTERFACE("96ca0768-0293-4d60-af79-f5575eb993b6", ITcVnAccess_TcVnVector3_INT)
#endif // !defined(_TC_IID_96CA0768_0293_4D60_AF79_F5575EB993B6_INCLUDED_)

#if !defined(_TC_IID_D62BE8B8_B130_4192_AD85_9F0C63F30A74_INCLUDED_)
#define _TC_IID_D62BE8B8_B130_4192_AD85_9F0C63F30A74_INCLUDED_
TCOM_DECL_INTERFACE("d62be8b8-b130-4192-ad85-9f0c63f30a74", ITcVnAccess_TcVnVector3_REAL)
#endif // !defined(_TC_IID_D62BE8B8_B130_4192_AD85_9F0C63F30A74_INCLUDED_)

#if !defined(_TC_IID_1B5B7311_E83D_41DD_B263_0BA2CED8319D_INCLUDED_)
#define _TC_IID_1B5B7311_E83D_41DD_B263_0BA2CED8319D_INCLUDED_
TCOM_DECL_INTERFACE("1b5b7311-e83d-41dd-b263-0ba2ced8319d", ITcVnAccess_TcVnVector3_SINT)
#endif // !defined(_TC_IID_1B5B7311_E83D_41DD_B263_0BA2CED8319D_INCLUDED_)

#if !defined(_TC_IID_7614254E_8CCE_4C28_A1BB_68E69F40EB02_INCLUDED_)
#define _TC_IID_7614254E_8CCE_4C28_A1BB_68E69F40EB02_INCLUDED_
TCOM_DECL_INTERFACE("7614254e-8cce-4c28-a1bb-68e69f40eb02", ITcVnAccess_TcVnVector3_UINT)
#endif // !defined(_TC_IID_7614254E_8CCE_4C28_A1BB_68E69F40EB02_INCLUDED_)

#if !defined(_TC_IID_6D53AB22_1E21_44A9_9579_B605E4DFFF94_INCLUDED_)
#define _TC_IID_6D53AB22_1E21_44A9_9579_B605E4DFFF94_INCLUDED_
TCOM_DECL_INTERFACE("6d53ab22-1e21-44a9-9579-b605e4dfff94", ITcVnAccess_TcVnVector3_USINT)
#endif // !defined(_TC_IID_6D53AB22_1E21_44A9_9579_B605E4DFFF94_INCLUDED_)

#if !defined(_TC_IID_145CA3F8_C73D_4106_807D_89774C71C360_INCLUDED_)
#define _TC_IID_145CA3F8_C73D_4106_807D_89774C71C360_INCLUDED_
TCOM_DECL_INTERFACE("145ca3f8-c73d-4106-807d-89774c71c360", ITcVnAccess_TcVnVector4_DINT)
#endif // !defined(_TC_IID_145CA3F8_C73D_4106_807D_89774C71C360_INCLUDED_)

#if !defined(_TC_IID_C6EBEC76_FA9E_401A_9288_52F73A86A051_INCLUDED_)
#define _TC_IID_C6EBEC76_FA9E_401A_9288_52F73A86A051_INCLUDED_
TCOM_DECL_INTERFACE("c6ebec76-fa9e-401a-9288-52f73a86a051", ITcVnAccess_TcVnVector4_INT)
#endif // !defined(_TC_IID_C6EBEC76_FA9E_401A_9288_52F73A86A051_INCLUDED_)

#if !defined(_TC_IID_59B6E8C8_D07D_4893_AFF4_0C86FFDF14B2_INCLUDED_)
#define _TC_IID_59B6E8C8_D07D_4893_AFF4_0C86FFDF14B2_INCLUDED_
TCOM_DECL_INTERFACE("59b6e8c8-d07d-4893-aff4-0c86ffdf14b2", ITcVnAccess_TcVnVector4_LREAL)
#endif // !defined(_TC_IID_59B6E8C8_D07D_4893_AFF4_0C86FFDF14B2_INCLUDED_)

#if !defined(_TC_IID_810CFD98_AB51_4398_9DB3_9D529DE76E1B_INCLUDED_)
#define _TC_IID_810CFD98_AB51_4398_9DB3_9D529DE76E1B_INCLUDED_
TCOM_DECL_INTERFACE("810cfd98-ab51-4398-9db3-9d529de76e1b", ITcVnAccess_TcVnVector4_REAL)
#endif // !defined(_TC_IID_810CFD98_AB51_4398_9DB3_9D529DE76E1B_INCLUDED_)

#if !defined(_TC_IID_7CFD71B1_3B6C_471C_9752_5C1DA7F32900_INCLUDED_)
#define _TC_IID_7CFD71B1_3B6C_471C_9752_5C1DA7F32900_INCLUDED_
TCOM_DECL_INTERFACE("7cfd71b1-3b6c-471c-9752-5c1da7f32900", ITcVnAccess_TcVnVector4_SINT)
#endif // !defined(_TC_IID_7CFD71B1_3B6C_471C_9752_5C1DA7F32900_INCLUDED_)

#if !defined(_TC_IID_3A3DA38B_309A_4BBC_9362_4ED7A7CF7B45_INCLUDED_)
#define _TC_IID_3A3DA38B_309A_4BBC_9362_4ED7A7CF7B45_INCLUDED_
TCOM_DECL_INTERFACE("3a3da38b-309a-4bbc-9362-4ed7a7cf7b45", ITcVnAccess_TcVnVector4_UINT)
#endif // !defined(_TC_IID_3A3DA38B_309A_4BBC_9362_4ED7A7CF7B45_INCLUDED_)

#if !defined(_TC_IID_B0FB083F_A0CD_4728_B39E_34BDD4FE2948_INCLUDED_)
#define _TC_IID_B0FB083F_A0CD_4728_B39E_34BDD4FE2948_INCLUDED_
TCOM_DECL_INTERFACE("b0fb083f-a0cd-4728-b39e-34bdd4fe2948", ITcVnAccess_TcVnVector4_USINT)
#endif // !defined(_TC_IID_B0FB083F_A0CD_4728_B39E_34BDD4FE2948_INCLUDED_)

#if !defined(_TC_IID_7196ECF3_D7E6_4F01_9889_652C87275E3C_INCLUDED_)
#define _TC_IID_7196ECF3_D7E6_4F01_9889_652C87275E3C_INCLUDED_
TCOM_DECL_INTERFACE("7196ecf3-d7e6-4f01-9889-652c87275e3c", ITcVnAccess_UDINT)
#endif // !defined(_TC_IID_7196ECF3_D7E6_4F01_9889_652C87275E3C_INCLUDED_)

#if !defined(_TC_IID_8670B02D_0498_4657_ADA1_441E54B74270_INCLUDED_)
#define _TC_IID_8670B02D_0498_4657_ADA1_441E54B74270_INCLUDED_
TCOM_DECL_INTERFACE("8670b02d-0498-4657-ada1-441e54b74270", ITcVnAccess_UINT)
#endif // !defined(_TC_IID_8670B02D_0498_4657_ADA1_441E54B74270_INCLUDED_)

#if !defined(_TC_IID_252DBC07_54C1_47D5_9A56_BEA40BDD3A76_INCLUDED_)
#define _TC_IID_252DBC07_54C1_47D5_9A56_BEA40BDD3A76_INCLUDED_
TCOM_DECL_INTERFACE("252dbc07-54c1-47d5-9a56-bea40bdd3a76", ITcVnAccess_ULINT)
#endif // !defined(_TC_IID_252DBC07_54C1_47D5_9A56_BEA40BDD3A76_INCLUDED_)

#if !defined(_TC_IID_975032E0_7E5A_4866_AB67_13B20C8FC9CB_INCLUDED_)
#define _TC_IID_975032E0_7E5A_4866_AB67_13B20C8FC9CB_INCLUDED_
TCOM_DECL_INTERFACE("975032e0-7e5a-4866-ab67-13b20c8fc9cb", ITcVnAccess_USINT)
#endif // !defined(_TC_IID_975032E0_7E5A_4866_AB67_13B20C8FC9CB_INCLUDED_)

#if !defined(_TC_IID_F6C9D79D_2E9C_40FA_9865_3D23FAC6860C_INCLUDED_)
#define _TC_IID_F6C9D79D_2E9C_40FA_9865_3D23FAC6860C_INCLUDED_
TCOM_DECL_INTERFACE("f6c9d79d-2e9c-40fa-9865-3d23fac6860c", ITcVnBidirectionalIterator)
#endif // !defined(_TC_IID_F6C9D79D_2E9C_40FA_9865_3D23FAC6860C_INCLUDED_)

#if !defined(_TC_IID_500E63A9_3202_40BD_9395_A71A6CA83DA4_INCLUDED_)
#define _TC_IID_500E63A9_3202_40BD_9395_A71A6CA83DA4_INCLUDED_
TCOM_DECL_INTERFACE("500e63a9-3202-40bd-9395-a71a6ca83da4", ITcVnBitmapExport)
#endif // !defined(_TC_IID_500E63A9_3202_40BD_9395_A71A6CA83DA4_INCLUDED_)

#if !defined(_TC_IID_733357A0_AA2A_4242_B876_C2B34FEEF1F8_INCLUDED_)
#define _TC_IID_733357A0_AA2A_4242_B876_C2B34FEEF1F8_INCLUDED_
TCOM_DECL_INTERFACE("733357a0-aa2a-4242-b876-c2b34feef1f8", ITcVnBitmapExportNotification)
#endif // !defined(_TC_IID_733357A0_AA2A_4242_B876_C2B34FEEF1F8_INCLUDED_)

#if !defined(_TC_IID_48DA88B5_7B23_4BD4_921B_D39483F1D3BA_INCLUDED_)
#define _TC_IID_48DA88B5_7B23_4BD4_921B_D39483F1D3BA_INCLUDED_
TCOM_DECL_INTERFACE("48da88b5-7b23-4bd4-921b-d39483f1d3ba", ITcVnBitmapExportRpcUnlocked)
#endif // !defined(_TC_IID_48DA88B5_7B23_4BD4_921B_D39483F1D3BA_INCLUDED_)

#if !defined(_TC_IID_BC72B333_E095_465B_9693_7979773CA3B8_INCLUDED_)
#define _TC_IID_BC72B333_E095_465B_9693_7979773CA3B8_INCLUDED_
TCOM_DECL_INTERFACE("bc72b333-e095-465b-9693-7979773ca3b8", ITcVnContainer)
#endif // !defined(_TC_IID_BC72B333_E095_465B_9693_7979773CA3B8_INCLUDED_)

#if !defined(_TC_IID_C10B6EE2_EA6E_4FED_AC4E_D3C8366F26C0_INCLUDED_)
#define _TC_IID_C10B6EE2_EA6E_4FED_AC4E_D3C8366F26C0_INCLUDED_
TCOM_DECL_INTERFACE("c10b6ee2-ea6e-4fed-ac4e-d3c8366f26c0", ITcVnData)
#endif // !defined(_TC_IID_C10B6EE2_EA6E_4FED_AC4E_D3C8366F26C0_INCLUDED_)

#if !defined(_TC_IID_6766D7F3_3908_4D4C_8A3B_39ED7C3EC1E2_INCLUDED_)
#define _TC_IID_6766D7F3_3908_4D4C_8A3B_39ED7C3EC1E2_INCLUDED_
TCOM_DECL_INTERFACE("6766d7f3-3908-4d4c-8a3b-39ed7c3ec1e2", ITcVnDisplayableImage)
#endif // !defined(_TC_IID_6766D7F3_3908_4D4C_8A3B_39ED7C3EC1E2_INCLUDED_)

#if !defined(_TC_IID_F5435722_337D_4786_87F5_6DEC5A1CAED5_INCLUDED_)
#define _TC_IID_F5435722_337D_4786_87F5_6DEC5A1CAED5_INCLUDED_
TCOM_DECL_INTERFACE("f5435722-337d-4786-87f5-6dec5a1caed5", ITcVnFileImageProvider)
#endif // !defined(_TC_IID_F5435722_337D_4786_87F5_6DEC5A1CAED5_INCLUDED_)

#if !defined(_TC_IID_010A82ED_513F_4803_A63A_D4E4A54C2603_INCLUDED_)
#define _TC_IID_010A82ED_513F_4803_A63A_D4E4A54C2603_INCLUDED_
TCOM_DECL_INTERFACE("010a82ed-513f-4803-a63a-d4e4a54c2603", ITcVnForwardIterator)
#endif // !defined(_TC_IID_010A82ED_513F_4803_A63A_D4E4A54C2603_INCLUDED_)

#if !defined(_TC_IID_ED7659DB_95DC_4A4A_B62F_02C9870D5E81_INCLUDED_)
#define _TC_IID_ED7659DB_95DC_4A4A_B62F_02C9870D5E81_INCLUDED_
TCOM_DECL_INTERFACE("ed7659db-95dc-4a4a-b62f-02c9870d5e81", ITcVnGevImageProvider)
#endif // !defined(_TC_IID_ED7659DB_95DC_4A4A_B62F_02C9870D5E81_INCLUDED_)

#if !defined(_TC_IID_8762D1CC_970E_47FD_84DA_E97E36A07768_INCLUDED_)
#define _TC_IID_8762D1CC_970E_47FD_84DA_E97E36A07768_INCLUDED_
TCOM_DECL_INTERFACE("8762d1cc-970e-47fd-84da-e97e36a07768", ITcVnHistogramExport)
#endif // !defined(_TC_IID_8762D1CC_970E_47FD_84DA_E97E36A07768_INCLUDED_)

#if !defined(_TC_IID_70D42C6D_6F4E_4719_8B29_2883D5D59B1C_INCLUDED_)
#define _TC_IID_70D42C6D_6F4E_4719_8B29_2883D5D59B1C_INCLUDED_
TCOM_DECL_INTERFACE("70d42c6d-6f4e-4719-8b29-2883d5d59b1c", ITcVnImage)
#endif // !defined(_TC_IID_70D42C6D_6F4E_4719_8B29_2883D5D59B1C_INCLUDED_)

#if !defined(_TC_IID_A78D28D9_F618_4D35_8FB8_162CE7C7F8EB_INCLUDED_)
#define _TC_IID_A78D28D9_F618_4D35_8FB8_162CE7C7F8EB_INCLUDED_
TCOM_DECL_INTERFACE("a78d28d9-f618-4d35-8fb8-162ce7c7f8eb", ITcVnImageBase)
#endif // !defined(_TC_IID_A78D28D9_F618_4D35_8FB8_162CE7C7F8EB_INCLUDED_)

#if !defined(_TC_IID_B05227C0_7FB6_4EBC_B79C_8DC65E1F5DAA_INCLUDED_)
#define _TC_IID_B05227C0_7FB6_4EBC_B79C_8DC65E1F5DAA_INCLUDED_
TCOM_DECL_INTERFACE("b05227c0-7fb6-4ebc-b79c-8dc65e1f5daa", ITcVnImageProvider)
#endif // !defined(_TC_IID_B05227C0_7FB6_4EBC_B79C_8DC65E1F5DAA_INCLUDED_)

#if !defined(_TC_IID_0162856D_6491_4A66_BB3A_80489E400478_INCLUDED_)
#define _TC_IID_0162856D_6491_4A66_BB3A_80489E400478_INCLUDED_
TCOM_DECL_INTERFACE("0162856d-6491-4a66-bb3a-80489e400478", ITcVnIteratorBase)
#endif // !defined(_TC_IID_0162856D_6491_4A66_BB3A_80489E400478_INCLUDED_)

#if !defined(_TC_IID_F002C7C2_AE73_45A5_949B_FC51184F2226_INCLUDED_)
#define _TC_IID_F002C7C2_AE73_45A5_949B_FC51184F2226_INCLUDED_
TCOM_DECL_INTERFACE("f002c7c2-ae73-45a5-949b-fc51184f2226", ITcVnIteratorCopyCreator)
#endif // !defined(_TC_IID_F002C7C2_AE73_45A5_949B_FC51184F2226_INCLUDED_)

#if !defined(_TC_IID_AC23D64B_CDFA_4D43_AE8B_364A856EB3E2_INCLUDED_)
#define _TC_IID_AC23D64B_CDFA_4D43_AE8B_364A856EB3E2_INCLUDED_
TCOM_DECL_INTERFACE("ac23d64b-cdfa-4d43-ae8b-364a856eb3e2", ITcVnMlModel)
#endif // !defined(_TC_IID_AC23D64B_CDFA_4D43_AE8B_364A856EB3E2_INCLUDED_)

#if !defined(_TC_IID_E4FB6944_2DE3_495A_A7E6_182A6EDDF670_INCLUDED_)
#define _TC_IID_E4FB6944_2DE3_495A_A7E6_182A6EDDF670_INCLUDED_
TCOM_DECL_INTERFACE("e4fb6944-2de3-495a-a7e6-182a6eddf670", ITcVnNeuralNetwork)
#endif // !defined(_TC_IID_E4FB6944_2DE3_495A_A7E6_182A6EDDF670_INCLUDED_)

#if !defined(_TC_IID_90B5507C_52E3_4DA4_895B_7274317CC7D6_INCLUDED_)
#define _TC_IID_90B5507C_52E3_4DA4_895B_7274317CC7D6_INCLUDED_
TCOM_DECL_INTERFACE("90b5507c-52e3-4da4-895b-7274317cc7d6", ITcVnRandomAccess_DINT)
#endif // !defined(_TC_IID_90B5507C_52E3_4DA4_895B_7274317CC7D6_INCLUDED_)

#if !defined(_TC_IID_55B49B83_CD33_4312_AC44_EFAE0B975C28_INCLUDED_)
#define _TC_IID_55B49B83_CD33_4312_AC44_EFAE0B975C28_INCLUDED_
TCOM_DECL_INTERFACE("55b49b83-cd33-4312-ac44-efae0b975c28", ITcVnRandomAccess_INT)
#endif // !defined(_TC_IID_55B49B83_CD33_4312_AC44_EFAE0B975C28_INCLUDED_)

#if !defined(_TC_IID_F52C8D8B_2284_4E73_B79B_98A8EB1B7CEE_INCLUDED_)
#define _TC_IID_F52C8D8B_2284_4E73_B79B_98A8EB1B7CEE_INCLUDED_
TCOM_DECL_INTERFACE("f52c8d8b-2284-4e73-b79b-98a8eb1b7cee", ITcVnRandomAccess_ITcVnImage)
#endif // !defined(_TC_IID_F52C8D8B_2284_4E73_B79B_98A8EB1B7CEE_INCLUDED_)

#if !defined(_TC_IID_1E9D51F1_9741_4E56_A25E_D5365993D80A_INCLUDED_)
#define _TC_IID_1E9D51F1_9741_4E56_A25E_D5365993D80A_INCLUDED_
TCOM_DECL_INTERFACE("1e9d51f1-9741-4e56-a25e-d5365993d80a", ITcVnRandomAccess_LREAL)
#endif // !defined(_TC_IID_1E9D51F1_9741_4E56_A25E_D5365993D80A_INCLUDED_)

#if !defined(_TC_IID_DB17B2E5_3A5D_43F8_9FC0_C1A0A93D1559_INCLUDED_)
#define _TC_IID_DB17B2E5_3A5D_43F8_9FC0_C1A0A93D1559_INCLUDED_
TCOM_DECL_INTERFACE("db17b2e5-3a5d-43f8-9fc0-c1a0a93d1559", ITcVnRandomAccess_REAL)
#endif // !defined(_TC_IID_DB17B2E5_3A5D_43F8_9FC0_C1A0A93D1559_INCLUDED_)

#if !defined(_TC_IID_E734E903_5AEA_4877_A6BF_58B4F394488C_INCLUDED_)
#define _TC_IID_E734E903_5AEA_4877_A6BF_58B4F394488C_INCLUDED_
TCOM_DECL_INTERFACE("e734e903-5aea-4877-a6bf-58b4f394488c", ITcVnRandomAccess_SINT)
#endif // !defined(_TC_IID_E734E903_5AEA_4877_A6BF_58B4F394488C_INCLUDED_)

#if !defined(_TC_IID_E0561896_2FF7_4D83_AC45_DDFEE1532049_INCLUDED_)
#define _TC_IID_E0561896_2FF7_4D83_AC45_DDFEE1532049_INCLUDED_
TCOM_DECL_INTERFACE("e0561896-2ff7-4d83-ac45-ddfee1532049", ITcVnRandomAccess_TcVnDMatch)
#endif // !defined(_TC_IID_E0561896_2FF7_4D83_AC45_DDFEE1532049_INCLUDED_)

#if !defined(_TC_IID_B06B4E6D_10F5_4A04_97EB_C84DCB383D87_INCLUDED_)
#define _TC_IID_B06B4E6D_10F5_4A04_97EB_C84DCB383D87_INCLUDED_
TCOM_DECL_INTERFACE("b06b4e6d-10f5-4a04-97eb-c84dcb383d87", ITcVnRandomAccess_TcVnKeyPoint)
#endif // !defined(_TC_IID_B06B4E6D_10F5_4A04_97EB_C84DCB383D87_INCLUDED_)

#if !defined(_TC_IID_35459277_9BFC_4D31_8F9F_A262236E77A8_INCLUDED_)
#define _TC_IID_35459277_9BFC_4D31_8F9F_A262236E77A8_INCLUDED_
TCOM_DECL_INTERFACE("35459277-9bfc-4d31-8f9f-a262236e77a8", ITcVnRandomAccess_TcVnPoint2_DINT)
#endif // !defined(_TC_IID_35459277_9BFC_4D31_8F9F_A262236E77A8_INCLUDED_)

#if !defined(_TC_IID_B747E227_43B1_4507_96A4_00549458BA01_INCLUDED_)
#define _TC_IID_B747E227_43B1_4507_96A4_00549458BA01_INCLUDED_
TCOM_DECL_INTERFACE("b747e227-43b1-4507-96a4-00549458ba01", ITcVnRandomAccess_TcVnPoint2_LREAL)
#endif // !defined(_TC_IID_B747E227_43B1_4507_96A4_00549458BA01_INCLUDED_)

#if !defined(_TC_IID_37607F12_4FDB_4BDD_8787_E9459AC5C8BB_INCLUDED_)
#define _TC_IID_37607F12_4FDB_4BDD_8787_E9459AC5C8BB_INCLUDED_
TCOM_DECL_INTERFACE("37607f12-4fdb-4bdd-8787-e9459ac5c8bb", ITcVnRandomAccess_TcVnPoint2_REAL)
#endif // !defined(_TC_IID_37607F12_4FDB_4BDD_8787_E9459AC5C8BB_INCLUDED_)

#if !defined(_TC_IID_1B779EE3_6D76_4AC3_AF52_ADF574DE3771_INCLUDED_)
#define _TC_IID_1B779EE3_6D76_4AC3_AF52_ADF574DE3771_INCLUDED_
TCOM_DECL_INTERFACE("1b779ee3-6d76-4ac3-af52-adf574de3771", ITcVnRandomAccess_TcVnPoint3_LREAL)
#endif // !defined(_TC_IID_1B779EE3_6D76_4AC3_AF52_ADF574DE3771_INCLUDED_)

#if !defined(_TC_IID_17437ED0_DC3E_48AE_9278_4FF188DD5B9E_INCLUDED_)
#define _TC_IID_17437ED0_DC3E_48AE_9278_4FF188DD5B9E_INCLUDED_
TCOM_DECL_INTERFACE("17437ed0-dc3e-48ae-9278-4ff188dd5b9e", ITcVnRandomAccess_TcVnPoint3_REAL)
#endif // !defined(_TC_IID_17437ED0_DC3E_48AE_9278_4FF188DD5B9E_INCLUDED_)

#if !defined(_TC_IID_BF284756_4FFC_4A8B_9FCB_627AFBA2F9F7_INCLUDED_)
#define _TC_IID_BF284756_4FFC_4A8B_9FCB_627AFBA2F9F7_INCLUDED_
TCOM_DECL_INTERFACE("bf284756-4ffc-4a8b-9fcb-627afba2f9f7", ITcVnRandomAccess_TcVnRectangle_DINT)
#endif // !defined(_TC_IID_BF284756_4FFC_4A8B_9FCB_627AFBA2F9F7_INCLUDED_)

#if !defined(_TC_IID_404084DA_7276_4843_9D19_8A1EDEEFF891_INCLUDED_)
#define _TC_IID_404084DA_7276_4843_9D19_8A1EDEEFF891_INCLUDED_
TCOM_DECL_INTERFACE("404084da-7276-4843-9d19-8a1edeeff891", ITcVnRandomAccess_TcVnRotatedRectangle)
#endif // !defined(_TC_IID_404084DA_7276_4843_9D19_8A1EDEEFF891_INCLUDED_)

#if !defined(_TC_IID_847677D5_CBC1_4CEF_BD93_1EB4C0A41732_INCLUDED_)
#define _TC_IID_847677D5_CBC1_4CEF_BD93_1EB4C0A41732_INCLUDED_
TCOM_DECL_INTERFACE("847677d5-cbc1-4cef-bd93-1eb4c0a41732", ITcVnRandomAccess_TcVnVector2_DINT)
#endif // !defined(_TC_IID_847677D5_CBC1_4CEF_BD93_1EB4C0A41732_INCLUDED_)

#if !defined(_TC_IID_894BB9FE_7982_42CF_B7A5_06B2C0B25D1B_INCLUDED_)
#define _TC_IID_894BB9FE_7982_42CF_B7A5_06B2C0B25D1B_INCLUDED_
TCOM_DECL_INTERFACE("894bb9fe-7982-42cf-b7a5-06b2c0b25d1b", ITcVnRandomAccess_TcVnVector2_INT)
#endif // !defined(_TC_IID_894BB9FE_7982_42CF_B7A5_06B2C0B25D1B_INCLUDED_)

#if !defined(_TC_IID_62D081B8_D6B8_4716_A089_70442409D7CC_INCLUDED_)
#define _TC_IID_62D081B8_D6B8_4716_A089_70442409D7CC_INCLUDED_
TCOM_DECL_INTERFACE("62d081b8-d6b8-4716-a089-70442409d7cc", ITcVnRandomAccess_TcVnVector2_REAL)
#endif // !defined(_TC_IID_62D081B8_D6B8_4716_A089_70442409D7CC_INCLUDED_)

#if !defined(_TC_IID_4D648ABD_113C_4FB0_BFF9_FDB146DE194B_INCLUDED_)
#define _TC_IID_4D648ABD_113C_4FB0_BFF9_FDB146DE194B_INCLUDED_
TCOM_DECL_INTERFACE("4d648abd-113c-4fb0-bff9-fdb146de194b", ITcVnRandomAccess_TcVnVector2_SINT)
#endif // !defined(_TC_IID_4D648ABD_113C_4FB0_BFF9_FDB146DE194B_INCLUDED_)

#if !defined(_TC_IID_E7732B95_809A_48A9_819F_C0398050AF2F_INCLUDED_)
#define _TC_IID_E7732B95_809A_48A9_819F_C0398050AF2F_INCLUDED_
TCOM_DECL_INTERFACE("e7732b95-809a-48a9-819f-c0398050af2f", ITcVnRandomAccess_TcVnVector2_UINT)
#endif // !defined(_TC_IID_E7732B95_809A_48A9_819F_C0398050AF2F_INCLUDED_)

#if !defined(_TC_IID_3DE1B926_DF4C_41CE_A43D_4FC1D3E9EC87_INCLUDED_)
#define _TC_IID_3DE1B926_DF4C_41CE_A43D_4FC1D3E9EC87_INCLUDED_
TCOM_DECL_INTERFACE("3de1b926-df4c-41ce-a43d-4fc1d3e9ec87", ITcVnRandomAccess_TcVnVector2_USINT)
#endif // !defined(_TC_IID_3DE1B926_DF4C_41CE_A43D_4FC1D3E9EC87_INCLUDED_)

#if !defined(_TC_IID_1E105D1B_EAE2_4E41_82F0_12C7D1885305_INCLUDED_)
#define _TC_IID_1E105D1B_EAE2_4E41_82F0_12C7D1885305_INCLUDED_
TCOM_DECL_INTERFACE("1e105d1b-eae2-4e41-82f0-12c7d1885305", ITcVnRandomAccess_TcVnVector3_INT)
#endif // !defined(_TC_IID_1E105D1B_EAE2_4E41_82F0_12C7D1885305_INCLUDED_)

#if !defined(_TC_IID_7FE46E54_63FF_432B_97AD_BBC6FF5B6620_INCLUDED_)
#define _TC_IID_7FE46E54_63FF_432B_97AD_BBC6FF5B6620_INCLUDED_
TCOM_DECL_INTERFACE("7fe46e54-63ff-432b-97ad-bbc6ff5b6620", ITcVnRandomAccess_TcVnVector3_REAL)
#endif // !defined(_TC_IID_7FE46E54_63FF_432B_97AD_BBC6FF5B6620_INCLUDED_)

#if !defined(_TC_IID_3DBB53DC_9376_4272_9152_41C74C30793B_INCLUDED_)
#define _TC_IID_3DBB53DC_9376_4272_9152_41C74C30793B_INCLUDED_
TCOM_DECL_INTERFACE("3dbb53dc-9376-4272-9152-41c74c30793b", ITcVnRandomAccess_TcVnVector3_SINT)
#endif // !defined(_TC_IID_3DBB53DC_9376_4272_9152_41C74C30793B_INCLUDED_)

#if !defined(_TC_IID_B59FA04C_C9A7_4855_8FFB_18FA23F7A998_INCLUDED_)
#define _TC_IID_B59FA04C_C9A7_4855_8FFB_18FA23F7A998_INCLUDED_
TCOM_DECL_INTERFACE("b59fa04c-c9a7-4855-8ffb-18fa23f7a998", ITcVnRandomAccess_TcVnVector3_UINT)
#endif // !defined(_TC_IID_B59FA04C_C9A7_4855_8FFB_18FA23F7A998_INCLUDED_)

#if !defined(_TC_IID_69E8C978_AEC6_43C9_A12D_5BD936489543_INCLUDED_)
#define _TC_IID_69E8C978_AEC6_43C9_A12D_5BD936489543_INCLUDED_
TCOM_DECL_INTERFACE("69e8c978-aec6-43c9-a12d-5bd936489543", ITcVnRandomAccess_TcVnVector3_USINT)
#endif // !defined(_TC_IID_69E8C978_AEC6_43C9_A12D_5BD936489543_INCLUDED_)

#if !defined(_TC_IID_A12E33E7_C3D8_4F85_99B8_55D4B21B4E70_INCLUDED_)
#define _TC_IID_A12E33E7_C3D8_4F85_99B8_55D4B21B4E70_INCLUDED_
TCOM_DECL_INTERFACE("a12e33e7-c3d8-4f85-99b8-55d4b21b4e70", ITcVnRandomAccess_TcVnVector4_DINT)
#endif // !defined(_TC_IID_A12E33E7_C3D8_4F85_99B8_55D4B21B4E70_INCLUDED_)

#if !defined(_TC_IID_55845100_BBCA_4143_8D01_BE330E1AF7FC_INCLUDED_)
#define _TC_IID_55845100_BBCA_4143_8D01_BE330E1AF7FC_INCLUDED_
TCOM_DECL_INTERFACE("55845100-bbca-4143-8d01-be330e1af7fc", ITcVnRandomAccess_TcVnVector4_INT)
#endif // !defined(_TC_IID_55845100_BBCA_4143_8D01_BE330E1AF7FC_INCLUDED_)

#if !defined(_TC_IID_B9D5D219_707B_4E0F_B558_507B4E8FC9F4_INCLUDED_)
#define _TC_IID_B9D5D219_707B_4E0F_B558_507B4E8FC9F4_INCLUDED_
TCOM_DECL_INTERFACE("b9d5d219-707b-4e0f-b558-507b4e8fc9f4", ITcVnRandomAccess_TcVnVector4_LREAL)
#endif // !defined(_TC_IID_B9D5D219_707B_4E0F_B558_507B4E8FC9F4_INCLUDED_)

#if !defined(_TC_IID_ACD95CBE_4D48_414D_9183_418F0D61EA1C_INCLUDED_)
#define _TC_IID_ACD95CBE_4D48_414D_9183_418F0D61EA1C_INCLUDED_
TCOM_DECL_INTERFACE("acd95cbe-4d48-414d-9183-418f0d61ea1c", ITcVnRandomAccess_TcVnVector4_REAL)
#endif // !defined(_TC_IID_ACD95CBE_4D48_414D_9183_418F0D61EA1C_INCLUDED_)

#if !defined(_TC_IID_49999433_E2A7_4601_9B4F_69484DFC00F8_INCLUDED_)
#define _TC_IID_49999433_E2A7_4601_9B4F_69484DFC00F8_INCLUDED_
TCOM_DECL_INTERFACE("49999433-e2a7-4601-9b4f-69484dfc00f8", ITcVnRandomAccess_TcVnVector4_SINT)
#endif // !defined(_TC_IID_49999433_E2A7_4601_9B4F_69484DFC00F8_INCLUDED_)

#if !defined(_TC_IID_ABF8C5EF_20C8_4BB1_930E_07E4832076B6_INCLUDED_)
#define _TC_IID_ABF8C5EF_20C8_4BB1_930E_07E4832076B6_INCLUDED_
TCOM_DECL_INTERFACE("abf8c5ef-20c8-4bb1-930e-07e4832076b6", ITcVnRandomAccess_TcVnVector4_UINT)
#endif // !defined(_TC_IID_ABF8C5EF_20C8_4BB1_930E_07E4832076B6_INCLUDED_)

#if !defined(_TC_IID_385D1F0F_F66A_4AE9_B75C_AA75F69D91A0_INCLUDED_)
#define _TC_IID_385D1F0F_F66A_4AE9_B75C_AA75F69D91A0_INCLUDED_
TCOM_DECL_INTERFACE("385d1f0f-f66a-4ae9-b75c-aa75f69d91a0", ITcVnRandomAccess_TcVnVector4_USINT)
#endif // !defined(_TC_IID_385D1F0F_F66A_4AE9_B75C_AA75F69D91A0_INCLUDED_)

#if !defined(_TC_IID_9D8272BC_0D30_49C5_9E1E_ECD3240BACE5_INCLUDED_)
#define _TC_IID_9D8272BC_0D30_49C5_9E1E_ECD3240BACE5_INCLUDED_
TCOM_DECL_INTERFACE("9d8272bc-0d30-49c5-9e1e-ecd3240bace5", ITcVnRandomAccess_UDINT)
#endif // !defined(_TC_IID_9D8272BC_0D30_49C5_9E1E_ECD3240BACE5_INCLUDED_)

#if !defined(_TC_IID_20F37D3F_E3CF_46A1_B395_CC79C1975FB7_INCLUDED_)
#define _TC_IID_20F37D3F_E3CF_46A1_B395_CC79C1975FB7_INCLUDED_
TCOM_DECL_INTERFACE("20f37d3f-e3cf-46a1-b395-cc79c1975fb7", ITcVnRandomAccess_UINT)
#endif // !defined(_TC_IID_20F37D3F_E3CF_46A1_B395_CC79C1975FB7_INCLUDED_)

#if !defined(_TC_IID_630EC56F_AF3F_4CC1_A585_7B4BD08B6283_INCLUDED_)
#define _TC_IID_630EC56F_AF3F_4CC1_A585_7B4BD08B6283_INCLUDED_
TCOM_DECL_INTERFACE("630ec56f-af3f-4cc1-a585-7b4bd08b6283", ITcVnRandomAccess_ULINT)
#endif // !defined(_TC_IID_630EC56F_AF3F_4CC1_A585_7B4BD08B6283_INCLUDED_)

#if !defined(_TC_IID_C8DAFC84_2C0E_4250_8A2D_D18BBBC488B6_INCLUDED_)
#define _TC_IID_C8DAFC84_2C0E_4250_8A2D_D18BBBC488B6_INCLUDED_
TCOM_DECL_INTERFACE("c8dafc84-2c0e-4250-8a2d-d18bbbc488b6", ITcVnRandomAccess_USINT)
#endif // !defined(_TC_IID_C8DAFC84_2C0E_4250_8A2D_D18BBBC488B6_INCLUDED_)

#if !defined(_TC_IID_BCAC943A_527D_4A55_B4CD_386DBFF328B8_INCLUDED_)
#define _TC_IID_BCAC943A_527D_4A55_B4CD_386DBFF328B8_INCLUDED_
TCOM_DECL_INTERFACE("bcac943a-527d-4a55-b4cd-386dbff328b8", ITcVnRandomAccessIterator)
#endif // !defined(_TC_IID_BCAC943A_527D_4A55_B4CD_386DBFF328B8_INCLUDED_)

#if !defined(_TC_IID_0E607ACC_A0D9_498A_AB3F_133D124E9AD8_INCLUDED_)
#define _TC_IID_0E607ACC_A0D9_498A_AB3F_133D124E9AD8_INCLUDED_
TCOM_DECL_INTERFACE("0e607acc-a0d9-498a-ab3f-133d124e9ad8", ITcVnTiffExport)
#endif // !defined(_TC_IID_0E607ACC_A0D9_498A_AB3F_133D124E9AD8_INCLUDED_)

#if !defined(_TC_IID_DFDCFA99_94EE_4C66_A05E_96CC78FB1641_INCLUDED_)
#define _TC_IID_DFDCFA99_94EE_4C66_A05E_96CC78FB1641_INCLUDED_
TCOM_DECL_INTERFACE("dfdcfa99-94ee-4c66-a05e-96cc78fb1641", ITcVnTiffExportNotification)
#endif // !defined(_TC_IID_DFDCFA99_94EE_4C66_A05E_96CC78FB1641_INCLUDED_)

#if !defined(_TC_IID_CFC0CE0B_0521_4D65_85C4_F774CBDD1BC7_INCLUDED_)
#define _TC_IID_CFC0CE0B_0521_4D65_85C4_F774CBDD1BC7_INCLUDED_
TCOM_DECL_INTERFACE("cfc0ce0b-0521-4d65-85c4-f774cbdd1bc7", ITcVnTiffExportRpcUnlocked)
#endif // !defined(_TC_IID_CFC0CE0B_0521_4D65_85C4_F774CBDD1BC7_INCLUDED_)

#if !defined(_TC_IID_D78C67BA_0E8E_4865_8A1A_3554A6F235D1_INCLUDED_)
#define _TC_IID_D78C67BA_0E8E_4865_8A1A_3554A6F235D1_INCLUDED_
TCOM_DECL_INTERFACE("d78c67ba-0e8e-4865-8a1a-3554a6f235d1", ITcVnTiffImport)
#endif // !defined(_TC_IID_D78C67BA_0E8E_4865_8A1A_3554A6F235D1_INCLUDED_)

#if !defined(_TC_IID_4626F8E2_9080_4F43_8B92_05E22F3DC9FD_INCLUDED_)
#define _TC_IID_4626F8E2_9080_4F43_8B92_05E22F3DC9FD_INCLUDED_
TCOM_DECL_INTERFACE("4626f8e2-9080-4f43-8b92-05e22f3dc9fd", ITcVnTimestamp)
#endif // !defined(_TC_IID_4626F8E2_9080_4F43_8B92_05E22F3DC9FD_INCLUDED_)

#if !defined(_TC_TYPE_67601283_AEDC_464B_844D_CB3A84C7261F_INCLUDED_)
#define _TC_TYPE_67601283_AEDC_464B_844D_CB3A84C7261F_INCLUDED_
/// <summary>
/// Offers element types.
/// </summary>
enum VN_ETcVnElementType : LONG
{
	TCVN_ET_SAME_AS_SOURCE = -1, // Sets the element type of the destination image to the source image element type.
	TCVN_ET_USINT = 0, // USINT (depth: 8 bit, 0..255)
	TCVN_ET_SINT = 1, // SINT (depth: 8 bit, -128..127)
	TCVN_ET_UINT = 2, // UINT (depth: 16 bit, 0..65535)
	TCVN_ET_INT = 3, // INT (depth: 16 bit, -32768..32767)
	TCVN_ET_DINT = 4, // DINT (depth: 32 bit, -2147483648..2147483647)
	TCVN_ET_REAL = 5, // REAL (depth: 32 bit, ~ -3.402823E 10^38 .. ~ 3.402823E 38)
	TCVN_ET_LREAL = 6, // LREAL (depth: 64 bit, ~ -1.79769313486231E 308 .. ~ 1.79769313486232E 308)
};
#endif // !defined(_TC_TYPE_67601283_AEDC_464B_844D_CB3A84C7261F_INCLUDED_)

#if !defined(_TC_TYPE_657520DB_518C_41A3_9E92_0670C7E6804F_INCLUDED_)
#define _TC_TYPE_657520DB_518C_41A3_9E92_0670C7E6804F_INCLUDED_
/// <summary>
/// Offers pixel encodings.
/// </summary>
enum VN_ETcVnPixelEncoding : BYTE
{
	TCVN_PE_NONE = 0, // No encoding available, i.e. every pixel value is independent of other pixels.
	TCVN_PE_BAYER_GR = 1, // Pixels are encoded as a BayerGR pattern.
	TCVN_PE_BAYER_RG = 2, // Pixels are encoded as a BayerRG pattern.
	TCVN_PE_BAYER_GB = 3, // Pixels are encoded as a BayerGB pattern.
	TCVN_PE_BAYER_BG = 4, // Pixels are encoded as a BayerBG pattern.
	TCVN_PE_YUV_411_UYYVYY = 5, // Pixels are encoded as YUV411 (UYYVYY).
	TCVN_PE_YUV_422_UYVY = 6, // Pixels are encoded as YUV422 (UYVY).
	TCVN_PE_YUV_422_YUYV = 7, // Pixels are encoded as YUV422 (YUYV).
	TCVN_PE_YCBCR_411_CBYYCRYY = 8, // Pixels are encoded as YCbCr411 (CbYYCrYY).
	TCVN_PE_YCBCR_422_CBYCRY = 9, // Pixels are encoded as YCbCr422 (CbYCrY).
	TCVN_PE_YCBCR_422_YCBYCR = 10, // Pixels are encoded as YCbCr422 (YCbYCr).
};
#endif // !defined(_TC_TYPE_657520DB_518C_41A3_9E92_0670C7E6804F_INCLUDED_)

#if !defined(_TC_TYPE_A897EFE5_AB13_42C7_887C_606D24EB842B_INCLUDED_)
#define _TC_TYPE_A897EFE5_AB13_42C7_887C_606D24EB842B_INCLUDED_
/// <summary>
/// Offers pixel packing modes.
/// </summary>
enum VN_ETcVnPixelPackMode : BYTE
{
	TCVN_PPM_NONE = 0, // No packing
	TCVN_PPM_MONO1P = 1, // Mono1p
	TCVN_PPM_MONO2P = 2, // Mono2p
	TCVN_PPM_MONO4P = 3, // Mono4p
	TCVN_PPM_MONO10PACKED = 4, // Mono10Packed or BayerXX10Packed
	TCVN_PPM_MONO12PACKED = 5, // Mono12Packed or BayerXX12Packed
	TCVN_PPM_RGB10V1PACKED = 6, // RGB10V1Packed
	TCVN_PPM_RGB10P32 = 7, // RGB10V2Packed (RGB10p32)
	TCVN_PPM_RGB12V1PACKED = 8, // RGB12V1Packed
	TCVN_PPM_RGB565P = 9, // RGB565p
	TCVN_PPM_BGR565P = 10, // BGR565p
	TCVN_PPM_MONO10P = 11, // Mono10p or BayerXX10p
	TCVN_PPM_MONO12P = 12, // Mono12p or BayerXX12p
	TCVN_PPM_MONO14P = 13, // Mono14p or BayerXX14p
};
#endif // !defined(_TC_TYPE_A897EFE5_AB13_42C7_887C_606D24EB842B_INCLUDED_)

#if !defined(_TC_TYPE_9032D059_566F_455F_8A15_A5047EC0F49E_INCLUDED_)
#define _TC_TYPE_9032D059_566F_455F_8A15_A5047EC0F49E_INCLUDED_
/// <summary>
/// Offers watchdog accumulation types to compute the fraction processed.
/// </summary>
enum ETcWatchdogAccumulationType : USHORT
{
	WD_ACC_TYPE_MEAN = 1, // Calculates the mean of the individual fractions processed over all monitored functions (recommended for independent functions).
	WD_ACC_TYPE_PRODUCT = 2, // Calculates the product of the individual fractions processed over all monitored functions (recommended for dependent functions).
};
#endif // !defined(_TC_TYPE_9032D059_566F_455F_8A15_A5047EC0F49E_INCLUDED_)

#if !defined(_TC_TYPE_B0162C95_E9FA_4151_A74F_59489FF2D3A0_INCLUDED_)
#define _TC_TYPE_B0162C95_E9FA_4151_A74F_59489FF2D3A0_INCLUDED_
/// <summary>
/// Describes the GigEVision camera connection state.
/// </summary>
enum GEV_CAMERA_STATE : BYTE
{
	GEV_CAMERA_IDLE = 0, // Camera is idle (no control or stream channel open).
	GEV_CONTROL_CHANNEL_OPEN_MASK = 1, // The control channel is open.
	GEV_STREAM_CHANNELS_OPEN_MASK = 2, // At least 1 stream channel is open.
	GEV_CONTROL_CHANNEL_OPEN = 1, // The control channel is open, but no stream channel.
	GEV_STREAM_CHANNELS_OPEN = 3, // At least 1 stream channel and the control channel are open.
};
#endif // !defined(_TC_TYPE_B0162C95_E9FA_4151_A74F_59489FF2D3A0_INCLUDED_)

#if !defined(_TC_TYPE_E157680C_3577_4579_BB71_A51E5EBFDD63_INCLUDED_)
#define _TC_TYPE_E157680C_3577_4579_BB71_A51E5EBFDD63_INCLUDED_
/// <summary>
/// Shows the GVSP (GigE Vision Streaming Protocol) pixel format.
/// </summary>
struct GVSP_PIXEL_FORMAT
{
	BYTE Color; // Indicates if the pixel format is mono or color.
	BYTE EffectivePixelSize; // Effective pixel size in bit
	USHORT Id; // GVSP pixel format ID
};
#endif // !defined(_TC_TYPE_E157680C_3577_4579_BB71_A51E5EBFDD63_INCLUDED_)

static_assert(sizeof(GVSP_PIXEL_FORMAT) == 4);

#if !defined(_TC_TYPE_2614D5C0_F25B_4563_B0A0_120FE33D24BE_INCLUDED_)
#define _TC_TYPE_2614D5C0_F25B_4563_B0A0_120FE33D24BE_INCLUDED_
/// <summary>
/// Offers camera calibration options.
/// </summary>
struct VN_TcVnCameraCalibrationOptions
{
	UCHAR bUseIntrinsicGuess : 1; // The camera matrix and distortion coefficients already contain a valid initial guess, which is optimized further.
	UCHAR bFixAspectRatio : 1; // The ratio fx/fy stays the same as in the input camera matrix.
	UCHAR bFixPrincipalPoint : 1; // The principal point is fixed to the image center (or provided cx,cy if bUseIntrinsicGuess).
	UCHAR bZeroTangentDist : 1; // The tangential distortion coefficients (p1, p2) are forced to 0.
	UCHAR bFixFocalLength : 1; // The parameters fx and fy stay the same as in the input camera matrix.
	UCHAR bFixK1 : 1; // The radial distortion coefficient k1 is fixed to 0 (or provided input if bUseIntrinsicGuess)
	UCHAR bFixK2 : 1; // The radial distortion coefficient k2 is fixed to 0 (or provided input if bUseIntrinsicGuess)
	UCHAR bFixK3 : 1; // The radial distortion coefficient k3 is fixed to 0 (or provided input if bUseIntrinsicGuess)
	UCHAR bFixK4 : 1; // The radial distortion coefficient k4 is fixed to 0 (or provided input if bUseIntrinsicGuess)
	UCHAR bFixK5 : 1; // The radial distortion coefficient k5 is fixed to 0 (or provided input if bUseIntrinsicGuess)
	UCHAR bFixK6 : 1; // The radial distortion coefficient k6 is fixed to 0 (or provided input if bUseIntrinsicGuess)
	UCHAR bRationalModel : 1; // The radial distortion coefficients k4, k5, k6 are enabled.
};
#endif // !defined(_TC_TYPE_2614D5C0_F25B_4563_B0A0_120FE33D24BE_INCLUDED_)

static_assert(sizeof(VN_TcVnCameraCalibrationOptions) == 2);

#if !defined(_TC_TYPE_16ED6EA4_688B_4215_AAFA_38E03CDAE626_INCLUDED_)
#define _TC_TYPE_16ED6EA4_688B_4215_AAFA_38E03CDAE626_INCLUDED_
/// <summary>
/// Describes a descriptor match
/// </summary>
struct VN_TcVnDMatch
{
	LONG nQueryIdx; // Query descriptor index
	LONG nTrainIdx; // Train descriptor index
	LONG nImageIdx; // Train image index
	float fDistance; // Distance between the descriptors (smaller distance means better match)
};
#endif // !defined(_TC_TYPE_16ED6EA4_688B_4215_AAFA_38E03CDAE626_INCLUDED_)

static_assert(sizeof(VN_TcVnDMatch) == 16);

#if !defined(_TC_TYPE_5AC1879E_C40B_4043_A704_EA39B24ED8DE_INCLUDED_)
#define _TC_TYPE_5AC1879E_C40B_4043_A704_EA39B24ED8DE_INCLUDED_
/// <summary>
/// Offers a user-defined matrix with variable rows, columns and element-type.
/// </summary>
struct VN_TcVnMatrix
{
#ifdef _X86_
	ULONG nRows; // Number of rows
	ULONG nCols; // Number of columns
	VN_ETcVnElementType eType; // Element type
	PVOID pData; // Pointer to the data
#else
	ULONG nRows; // Number of rows
	ULONG nCols; // Number of columns
	VN_ETcVnElementType eType; // Element type
private:
	UCHAR reserved1[4];
public:
	PVOID pData; // Pointer to the data
#endif

	VN_TcVnMatrix() { }
	VN_TcVnMatrix(ULONG nRows, ULONG nCols, VN_ETcVnElementType eType, PVOID pData) : nRows(nRows), nCols(nCols), eType(eType), pData(pData) { }
};
#endif // !defined(_TC_TYPE_5AC1879E_C40B_4043_A704_EA39B24ED8DE_INCLUDED_)

#ifdef _X86_
	static_assert(sizeof(VN_TcVnMatrix) == 16);
#else
	static_assert(sizeof(VN_TcVnMatrix) == 24);
#endif

#if !defined(_TC_TYPE_A77AC29D_0724_49B8_BAE1_6DF28088035B_INCLUDED_)
#define _TC_TYPE_A77AC29D_0724_49B8_BAE1_6DF28088035B_INCLUDED_
/// <summary>
/// Offers image or contour moments.
/// </summary>
struct VN_TcVnMoments
{
	double fM00; // Spatial moment 00
	double fM10; // Spatial moment 10
	double fM01; // Spatial moment 01
	double fM20; // Spatial moment 20
	double fM11; // Spatial moment 11
	double fM02; // Spatial moment 02
	double fM30; // Spatial moment 30
	double fM21; // Spatial moment 21
	double fM12; // Spatial moment 12
	double fM03; // Spatial moment 03
	double fMu20; // Central moment 20
	double fMu11; // Central moment 11
	double fMu02; // Central moment 02
	double fMu30; // Central moment 30
	double fMu21; // Central moment 21
	double fMu12; // Central moment 12
	double fMu03; // Central moment 03
	double fNu20; // Normalized central moment 20
	double fNu11; // Normalized central moment 11
	double fNu02; // Normalized central moment 02
	double fNu30; // Normalized central moment 30
	double fNu21; // Normalized central moment 21
	double fNu12; // Normalized central moment 12
	double fNu03; // Normalized central moment 03
};
#endif // !defined(_TC_TYPE_A77AC29D_0724_49B8_BAE1_6DF28088035B_INCLUDED_)

static_assert(sizeof(VN_TcVnMoments) == 192);

#if !defined(_TC_TYPE_1757E396_5DF0_4407_B0EB_1037B2E8B4EE_INCLUDED_)
#define _TC_TYPE_1757E396_5DF0_4407_B0EB_1037B2E8B4EE_INCLUDED_
/// <summary>
/// Contains detailed information about the pixel format.
/// </summary>
struct VN_TcVnPixelFormat
{
	UCHAR bSupported : 1; // If false, the pixel format is not supported.
	UCHAR bSigned : 1; // If true, pixel intensities are signed values.
	UCHAR bPlanar : 1; // If true, the image channels are stored planar instead of interleaved (e.g. RRRRRGGGGGBBBBB instead of RGBRGBRGBRGBRGB).
private:
	UCHAR reserved1 : 1;
public:
	UCHAR bFloat : 1; // If true, the pixel format is floating point.
private:
	UCHAR reserved2 : 3;
public:
	BYTE nChannels; // Number of channels
	VN_ETcVnPixelEncoding ePixelEncoding; // Pixel encoding
	VN_ETcVnPixelPackMode ePixelPackMode; // Pixel pack mode
	USHORT nElementSize; // Size (bit) of a single pixel channel
	USHORT nTotalSize; // Size (bit) of all pixel channels

	VN_TcVnPixelFormat() { }
	VN_TcVnPixelFormat(UCHAR bSupported, UCHAR bSigned, UCHAR bPlanar, UCHAR bFloat, BYTE nChannels, VN_ETcVnPixelEncoding ePixelEncoding, VN_ETcVnPixelPackMode ePixelPackMode, USHORT nElementSize, USHORT nTotalSize) : bSupported(bSupported), bSigned(bSigned), bPlanar(bPlanar), bFloat(bFloat), nChannels(nChannels), ePixelEncoding(ePixelEncoding), ePixelPackMode(ePixelPackMode), nElementSize(nElementSize), nTotalSize(nTotalSize) { }
};
#endif // !defined(_TC_TYPE_1757E396_5DF0_4407_B0EB_1037B2E8B4EE_INCLUDED_)

static_assert(sizeof(VN_TcVnPixelFormat) == 8);

#if !defined(_TC_TYPE_EDDFAD84_6C7F_4BF3_AEB0_8D6817806345_INCLUDED_)
#define _TC_TYPE_EDDFAD84_6C7F_4BF3_AEB0_8D6817806345_INCLUDED_
/// <summary>
/// Contains origin and size of a rectangle.
/// </summary>
struct VN_TcVnRectangle_DINT
{
	LONG nX; // X coordinate of the top-left corner
	LONG nY; // Y coordinate of the top-left corner
	LONG nWidth; // Width
	LONG nHeight; // Height
};
#endif // !defined(_TC_TYPE_EDDFAD84_6C7F_4BF3_AEB0_8D6817806345_INCLUDED_)

static_assert(sizeof(VN_TcVnRectangle_DINT) == 16);

#if !defined(_TC_TYPE_24EC7417_7C49_4351_BEC9_787908E4B593_INCLUDED_)
#define _TC_TYPE_24EC7417_7C49_4351_BEC9_787908E4B593_INCLUDED_
/// <summary>
/// Contains origin and size of a rectangle.
/// </summary>
struct VN_TcVnRectangle_UDINT
{
	ULONG nX; // X coordinate of the top-left corner
	ULONG nY; // Y coordinate of the top-left corner
	ULONG nWidth; // Width
	ULONG nHeight; // Height
};
#endif // !defined(_TC_TYPE_24EC7417_7C49_4351_BEC9_787908E4B593_INCLUDED_)

static_assert(sizeof(VN_TcVnRectangle_UDINT) == 16);

#if !defined(_TC_TYPE_67677000_72B1_437A_A428_8E5785EB2F80_INCLUDED_)
#define _TC_TYPE_67677000_72B1_437A_A428_8E5785EB2F80_INCLUDED_
/// <summary>
/// Contains width and height.
/// </summary>
struct VN_TcVnSize2_REAL
{
	float fWidth; // Width
	float fHeight; // Height
};
#endif // !defined(_TC_TYPE_67677000_72B1_437A_A428_8E5785EB2F80_INCLUDED_)

static_assert(sizeof(VN_TcVnSize2_REAL) == 8);

#if !defined(_TC_TYPE_E1ED2436_3512_43FA_B927_3F71DEDDA853_INCLUDED_)
#define _TC_TYPE_E1ED2436_3512_43FA_B927_3F71DEDDA853_INCLUDED_
/// <summary>
/// Describes a GVCP register address.
/// </summary>
typedef ULONG GVCP_REGISTER_ADDRESS;
#endif // !defined(_TC_TYPE_E1ED2436_3512_43FA_B927_3F71DEDDA853_INCLUDED_)

#if !defined(_TC_TYPE_7DF86AAB_66CE_4CBC_96CF_7237FB9CF43E_INCLUDED_)
#define _TC_TYPE_7DF86AAB_66CE_4CBC_96CF_7237FB9CF43E_INCLUDED_
/// <summary>
/// Contains origin and size of a rectangle.
/// </summary>
typedef VN_TcVnRectangle_DINT VN_TcVnRectangle;
#endif // !defined(_TC_TYPE_7DF86AAB_66CE_4CBC_96CF_7237FB9CF43E_INCLUDED_)

#if !defined(_TC_TYPE_D485A6EE_139B_4293_A4F5_9F5E42C0292F_INCLUDED_)
#define _TC_TYPE_D485A6EE_139B_4293_A4F5_9F5E42C0292F_INCLUDED_
/// <summary>
/// Ten-element array of type ITcVnImage.
/// </summary>
typedef ITcVnImage* VN_TcVnArray10_ITcVnImage[10];
#endif // !defined(_TC_TYPE_D485A6EE_139B_4293_A4F5_9F5E42C0292F_INCLUDED_)

#if !defined(_TC_TYPE_E39E4F1E_AA83_4D62_ADAA_6A7FB452D0F3_INCLUDED_)
#define _TC_TYPE_E39E4F1E_AA83_4D62_ADAA_6A7FB452D0F3_INCLUDED_
/// <summary>
/// 33-dimensional array of element-type UDINT.
/// </summary>
typedef ULONG VN_TcVnArray33_UDINT[33];
#endif // !defined(_TC_TYPE_E39E4F1E_AA83_4D62_ADAA_6A7FB452D0F3_INCLUDED_)

#if !defined(_TC_TYPE_8BC50E18_B4AC_47F8_9E62_3DE99055EAC1_INCLUDED_)
#define _TC_TYPE_8BC50E18_B4AC_47F8_9E62_3DE99055EAC1_INCLUDED_
/// <summary>
/// Four-dimensional array of element-type LREAL.
/// </summary>
typedef double VN_TcVnArray4_LREAL[4];
#endif // !defined(_TC_TYPE_8BC50E18_B4AC_47F8_9E62_3DE99055EAC1_INCLUDED_)

#if !defined(_TC_TYPE_2B353D13_18B2_4617_86DF_03B9792C0361_INCLUDED_)
#define _TC_TYPE_2B353D13_18B2_4617_86DF_03B9792C0361_INCLUDED_
/// <summary>
/// Seven-dimensional array of element-type LREAL.
/// </summary>
typedef double VN_TcVnArray7_LREAL[7];
#endif // !defined(_TC_TYPE_2B353D13_18B2_4617_86DF_03B9792C0361_INCLUDED_)

#if !defined(_TC_TYPE_DD112102_C23A_4B37_A43A_A96400B57010_INCLUDED_)
#define _TC_TYPE_DD112102_C23A_4B37_A43A_A96400B57010_INCLUDED_
/// <summary>
/// Eight-dimensional array of element-type LREAL.
/// </summary>
typedef double VN_TcVnArray8_LREAL[8];
#endif // !defined(_TC_TYPE_DD112102_C23A_4B37_A43A_A96400B57010_INCLUDED_)

#if !defined(_TC_TYPE_76BE69D5_353E_4426_80D1_FB84DE6E20F4_INCLUDED_)
#define _TC_TYPE_76BE69D5_353E_4426_80D1_FB84DE6E20F4_INCLUDED_
/// <summary>
/// 2x3 matrix of type LREAL
/// </summary>
typedef double VN_TcVnMatrix2x3_LREAL[2][3];
#endif // !defined(_TC_TYPE_76BE69D5_353E_4426_80D1_FB84DE6E20F4_INCLUDED_)

#if !defined(_TC_TYPE_91A420A3_4727_4481_B3BB_170528E5BC7C_INCLUDED_)
#define _TC_TYPE_91A420A3_4727_4481_B3BB_170528E5BC7C_INCLUDED_
/// <summary>
/// 3x3 matrix of type LREAL.
/// </summary>
typedef double VN_TcVnMatrix3x3_LREAL[3][3];
#endif // !defined(_TC_TYPE_91A420A3_4727_4481_B3BB_170528E5BC7C_INCLUDED_)

#if !defined(_TC_TYPE_7EF40A83_0784_48B8_AD33_8243A819AB27_INCLUDED_)
#define _TC_TYPE_7EF40A83_0784_48B8_AD33_8243A819AB27_INCLUDED_
/// <summary>
/// Two-dimensional vector for DINT values.
/// </summary>
typedef LONG VN_TcVnVector2_DINT[2];
#endif // !defined(_TC_TYPE_7EF40A83_0784_48B8_AD33_8243A819AB27_INCLUDED_)

#if !defined(_TC_TYPE_362767D4_25C7_4A3F_8FE1_E1B63EB93B1D_INCLUDED_)
#define _TC_TYPE_362767D4_25C7_4A3F_8FE1_E1B63EB93B1D_INCLUDED_
/// <summary>
/// Two-dimensional vector for INT values.
/// </summary>
typedef SHORT VN_TcVnVector2_INT[2];
#endif // !defined(_TC_TYPE_362767D4_25C7_4A3F_8FE1_E1B63EB93B1D_INCLUDED_)

#if !defined(_TC_TYPE_8228BE9A_A121_4C3B_A526_4A9DA3BAA5DA_INCLUDED_)
#define _TC_TYPE_8228BE9A_A121_4C3B_A526_4A9DA3BAA5DA_INCLUDED_
/// <summary>
/// Two-dimensional vector for LREAL values.
/// </summary>
typedef double VN_TcVnVector2_LREAL[2];
#endif // !defined(_TC_TYPE_8228BE9A_A121_4C3B_A526_4A9DA3BAA5DA_INCLUDED_)

#if !defined(_TC_TYPE_4E4EA9C3_00D0_4474_876B_603F4AE8CEBC_INCLUDED_)
#define _TC_TYPE_4E4EA9C3_00D0_4474_876B_603F4AE8CEBC_INCLUDED_
/// <summary>
/// Two-dimensional vector for REAL values.
/// </summary>
typedef float VN_TcVnVector2_REAL[2];
#endif // !defined(_TC_TYPE_4E4EA9C3_00D0_4474_876B_603F4AE8CEBC_INCLUDED_)

#if !defined(_TC_TYPE_B84D5235_118C_4EB8_B71A_CF000546E049_INCLUDED_)
#define _TC_TYPE_B84D5235_118C_4EB8_B71A_CF000546E049_INCLUDED_
/// <summary>
/// Two-dimensional vector for SINT values.
/// </summary>
typedef char VN_TcVnVector2_SINT[2];
#endif // !defined(_TC_TYPE_B84D5235_118C_4EB8_B71A_CF000546E049_INCLUDED_)

#if !defined(_TC_TYPE_F5A9FF0D_A96A_4BA5_A031_4D1D3BBD9734_INCLUDED_)
#define _TC_TYPE_F5A9FF0D_A96A_4BA5_A031_4D1D3BBD9734_INCLUDED_
/// <summary>
/// Two-dimensional vector for UINT values.
/// </summary>
typedef USHORT VN_TcVnVector2_UINT[2];
#endif // !defined(_TC_TYPE_F5A9FF0D_A96A_4BA5_A031_4D1D3BBD9734_INCLUDED_)

#if !defined(_TC_TYPE_08216BF9_BD27_4D0E_A50D_12EDFEBA8F5B_INCLUDED_)
#define _TC_TYPE_08216BF9_BD27_4D0E_A50D_12EDFEBA8F5B_INCLUDED_
/// <summary>
/// Two-dimensional vector for USINT values.
/// </summary>
typedef unsigned char VN_TcVnVector2_USINT[2];
#endif // !defined(_TC_TYPE_08216BF9_BD27_4D0E_A50D_12EDFEBA8F5B_INCLUDED_)

#if !defined(_TC_TYPE_4A2F9AF0_B12B_4D45_B5D9_18F954C15E00_INCLUDED_)
#define _TC_TYPE_4A2F9AF0_B12B_4D45_B5D9_18F954C15E00_INCLUDED_
/// <summary>
/// Three-dimensional vector for INT values.
/// </summary>
typedef SHORT VN_TcVnVector3_INT[3];
#endif // !defined(_TC_TYPE_4A2F9AF0_B12B_4D45_B5D9_18F954C15E00_INCLUDED_)

#if !defined(_TC_TYPE_B9A67DEB_A7D1_4F25_95A3_4A82FA5C1E28_INCLUDED_)
#define _TC_TYPE_B9A67DEB_A7D1_4F25_95A3_4A82FA5C1E28_INCLUDED_
/// <summary>
/// Three-dimensional vector for LREAL values.
/// </summary>
typedef double VN_TcVnVector3_LREAL[3];
#endif // !defined(_TC_TYPE_B9A67DEB_A7D1_4F25_95A3_4A82FA5C1E28_INCLUDED_)

#if !defined(_TC_TYPE_BDB49C24_676C_4AFA_A8E9_D29059B3067D_INCLUDED_)
#define _TC_TYPE_BDB49C24_676C_4AFA_A8E9_D29059B3067D_INCLUDED_
/// <summary>
/// Three-dimensional vector for REAL values.
/// </summary>
typedef float VN_TcVnVector3_REAL[3];
#endif // !defined(_TC_TYPE_BDB49C24_676C_4AFA_A8E9_D29059B3067D_INCLUDED_)

#if !defined(_TC_TYPE_7C6D2F58_B5B9_45B4_8DB8_5F6623C1B19B_INCLUDED_)
#define _TC_TYPE_7C6D2F58_B5B9_45B4_8DB8_5F6623C1B19B_INCLUDED_
/// <summary>
/// Three-dimensional vector for SINT values.
/// </summary>
typedef char VN_TcVnVector3_SINT[3];
#endif // !defined(_TC_TYPE_7C6D2F58_B5B9_45B4_8DB8_5F6623C1B19B_INCLUDED_)

#if !defined(_TC_TYPE_647A628D_C3DF_4800_A37C_D5F8C4628A4F_INCLUDED_)
#define _TC_TYPE_647A628D_C3DF_4800_A37C_D5F8C4628A4F_INCLUDED_
/// <summary>
/// Three-dimensional vector for UINT values.
/// </summary>
typedef USHORT VN_TcVnVector3_UINT[3];
#endif // !defined(_TC_TYPE_647A628D_C3DF_4800_A37C_D5F8C4628A4F_INCLUDED_)

#if !defined(_TC_TYPE_93006603_D9CD_4F58_9515_E70C340ADF7C_INCLUDED_)
#define _TC_TYPE_93006603_D9CD_4F58_9515_E70C340ADF7C_INCLUDED_
/// <summary>
/// Three-dimensional vector for USINT values.
/// </summary>
typedef unsigned char VN_TcVnVector3_USINT[3];
#endif // !defined(_TC_TYPE_93006603_D9CD_4F58_9515_E70C340ADF7C_INCLUDED_)

#if !defined(_TC_TYPE_0F933FA5_B30A_4CF2_B3FD_13B936FE1EFA_INCLUDED_)
#define _TC_TYPE_0F933FA5_B30A_4CF2_B3FD_13B936FE1EFA_INCLUDED_
/// <summary>
/// Four-dimensional vector for DINT values.
/// </summary>
typedef LONG VN_TcVnVector4_DINT[4];
#endif // !defined(_TC_TYPE_0F933FA5_B30A_4CF2_B3FD_13B936FE1EFA_INCLUDED_)

#if !defined(_TC_TYPE_664F512C_59F4_46C0_B3FA_CA0C8CD8F3A7_INCLUDED_)
#define _TC_TYPE_664F512C_59F4_46C0_B3FA_CA0C8CD8F3A7_INCLUDED_
/// <summary>
/// Four-dimensional vector for INT values.
/// </summary>
typedef SHORT VN_TcVnVector4_INT[4];
#endif // !defined(_TC_TYPE_664F512C_59F4_46C0_B3FA_CA0C8CD8F3A7_INCLUDED_)

#if !defined(_TC_TYPE_D6F8E615_70A9_407A_8442_ED15E6633AE8_INCLUDED_)
#define _TC_TYPE_D6F8E615_70A9_407A_8442_ED15E6633AE8_INCLUDED_
/// <summary>
/// Four-dimensional vector for LREAL values.
/// </summary>
typedef double VN_TcVnVector4_LREAL[4];
#endif // !defined(_TC_TYPE_D6F8E615_70A9_407A_8442_ED15E6633AE8_INCLUDED_)

#if !defined(_TC_TYPE_A34B2960_B213_4F31_83FD_A9D32B202B51_INCLUDED_)
#define _TC_TYPE_A34B2960_B213_4F31_83FD_A9D32B202B51_INCLUDED_
/// <summary>
/// Four-dimensional vector for REAL values.
/// </summary>
typedef float VN_TcVnVector4_REAL[4];
#endif // !defined(_TC_TYPE_A34B2960_B213_4F31_83FD_A9D32B202B51_INCLUDED_)

#if !defined(_TC_TYPE_EDD42E43_9F03_4BBF_AF70_222422CA47E3_INCLUDED_)
#define _TC_TYPE_EDD42E43_9F03_4BBF_AF70_222422CA47E3_INCLUDED_
/// <summary>
/// Four-dimensional vector for SINT values.
/// </summary>
typedef char VN_TcVnVector4_SINT[4];
#endif // !defined(_TC_TYPE_EDD42E43_9F03_4BBF_AF70_222422CA47E3_INCLUDED_)

#if !defined(_TC_TYPE_9649F098_0F1D_4D42_AAFB_50FB3F7D8877_INCLUDED_)
#define _TC_TYPE_9649F098_0F1D_4D42_AAFB_50FB3F7D8877_INCLUDED_
/// <summary>
/// Four-dimensional vector for UINT values.
/// </summary>
typedef USHORT VN_TcVnVector4_UINT[4];
#endif // !defined(_TC_TYPE_9649F098_0F1D_4D42_AAFB_50FB3F7D8877_INCLUDED_)

#if !defined(_TC_TYPE_92193E42_2CE3_4BBD_A2C1_68D11BA8F098_INCLUDED_)
#define _TC_TYPE_92193E42_2CE3_4BBD_A2C1_68D11BA8F098_INCLUDED_
/// <summary>
/// Four-dimensional vector for USINT values.
/// </summary>
typedef unsigned char VN_TcVnVector4_USINT[4];
#endif // !defined(_TC_TYPE_92193E42_2CE3_4BBD_A2C1_68D11BA8F098_INCLUDED_)


#if !defined(_TC_TYPE_D245C557_353A_4D5F_A69A_DDF424681A3C_INCLUDED_)
#define _TC_TYPE_D245C557_353A_4D5F_A69A_DDF424681A3C_INCLUDED_
/// <summary>
/// Interface for image acquisition.
/// </summary>
struct __declspec(novtable) ITcIoImageAcquisition : public ITcUnknown
{
	/// <summary>
	/// Register callback interface.
	/// </summary>
	/// <param name="ipRecv">Pointer to an interface containing the callback function.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI RegisterReceiver(ITcIoImageRecv* ipRecv) = 0;
	/// <summary>
	/// Unregister callback interface.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI UnregisterReceiver() = 0;
	/// <summary>
	/// Open camera (open the control channel, open a stream channel, and activate the GVSP receiver).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI OpenCamera() = 0;
	/// <summary>
	/// Close camera (deactivate the GVSP receiver, close the stream channel, and close the control channel).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CloseCamera() = 0;
	/// <summary>
	/// Start the image acquisition.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI StartAcquisition() = 0;
	/// <summary>
	/// Stop the image acquisition.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI StopAcquisition() = 0;
	/// <summary>
	/// Initialize the software trigger and trigger it. The initialization step is skipped if it was executed before.
	/// </summary>
	/// <param name="bSplitConcatenatedCommands">If true, multi-read and multi-write commands are split into sequences of single read and single write commands, respectively.</param>
	/// <param name="bOmitAcknowledgement">Indicates that no acknowledge packet should be requested.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SoftwareTrigger(bool bSplitConcatenatedCommands, bool bOmitAcknowledgement) = 0;
	/// <summary>
	/// Send initialization commands to the camera.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI InitializeCamera() = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcIoImageAcquisition, IID_ITcIoImageAcquisition);
#endif // !defined(_TC_TYPE_D245C557_353A_4D5F_A69A_DDF424681A3C_INCLUDED_)

#if !defined(_TC_TYPE_3404B97C_9B43_42E9_9D95_3DB0DA598A36_INCLUDED_)
#define _TC_TYPE_3404B97C_9B43_42E9_9D95_3DB0DA598A36_INCLUDED_
/// <summary>
/// Interface for a image receiver.
/// </summary>
struct __declspec(novtable) ITcIoImageRecv : public ITcUnknown
{
	/// <summary>
	/// Receive an image from an instance of ITcIoGevImageAcquisition.
	/// </summary>
	/// <param name="ipImage">Interface pointer to the image.</param>
	/// <param name="hrAcquisitionResult">HRESULT indicating the status of the image acquisition.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI ReceiveImage(ITcVnImageBase* ipImage, HRESULT hrAcquisitionResult) = 0;
	/// <summary>
	/// Receive an operation result from an instance of ITcIoGevImageAcquisition.
	/// </summary>
	/// <param name="hrOperationResult">HRESULT indicating the status of the performed operation.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI ReceiveOpResult(HRESULT hrOperationResult) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcIoImageRecv, IID_ITcIoImageRecv);
#endif // !defined(_TC_TYPE_3404B97C_9B43_42E9_9D95_3DB0DA598A36_INCLUDED_)

#if !defined(_TC_TYPE_0EDD1F90_35E9_4368_8ED9_EF04662E5E31_INCLUDED_)
#define _TC_TYPE_0EDD1F90_35E9_4368_8ED9_EF04662E5E31_INCLUDED_
/// <summary>
/// Interface required for sending serialized objects as ADS notifications.
/// </summary>
struct __declspec(novtable) ITcSerializableNotification : public ITcUnknown
{
	/// <summary>
	/// Gets a value that reflects changes of the underlying object (e.g., the timestamp of the latest object change).
	/// </summary>
	/// <param name="nComparisonValue">Returns the comparison value.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetComparisonValue(LONGLONG& nComparisonValue) = 0;
	/// <summary>
	/// Serialize an object into a given buffer.
	/// </summary>
	/// <param name="nBufferSize">Maximum buffer size (in) and actually used buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SerializeRpcUnlocked(ULONGLONG& nBufferSize, PVOID pDestBuffer) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcSerializableNotification, IID_ITcSerializableNotification);
#endif // !defined(_TC_TYPE_0EDD1F90_35E9_4368_8ED9_EF04662E5E31_INCLUDED_)

#if !defined(_TC_TYPE_B976A700_680B_4D98_A422_3DAAB772CDA7_INCLUDED_)
#define _TC_TYPE_B976A700_680B_4D98_A422_3DAAB772CDA7_INCLUDED_
/// <summary>
/// Offers an access interface for DINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_DINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(LONG& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(LONG nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_DINT, IID_ITcVnAccess_DINT);
#endif // !defined(_TC_TYPE_B976A700_680B_4D98_A422_3DAAB772CDA7_INCLUDED_)

#if !defined(_TC_TYPE_EA71C8AC_0D0A_4EB4_BC0D_41E921E1B80C_INCLUDED_)
#define _TC_TYPE_EA71C8AC_0D0A_4EB4_BC0D_41E921E1B80C_INCLUDED_
/// <summary>
/// Offers an access interface for INT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_INT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(SHORT& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(SHORT nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_INT, IID_ITcVnAccess_INT);
#endif // !defined(_TC_TYPE_EA71C8AC_0D0A_4EB4_BC0D_41E921E1B80C_INCLUDED_)

#if !defined(_TC_TYPE_82C08AE5_D6D8_42EF_A019_AD4009CD9D7C_INCLUDED_)
#define _TC_TYPE_82C08AE5_D6D8_42EF_A019_AD4009CD9D7C_INCLUDED_
/// <summary>
/// Offers an access interface for images.
/// </summary>
struct __declspec(novtable) ITcVnAccess_ITcVnImage : public ITcUnknown
{
	/// <summary>
	/// Gets the image.
	/// </summary>
	/// <param name="ipImage">Returns the image.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(ITcVnImage*& ipImage) = 0;
	/// <summary>
	/// Sets the image.
	/// </summary>
	/// <param name="ipImage">The image to set.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(ITcVnImage* ipImage) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_ITcVnImage, IID_ITcVnAccess_ITcVnImage);
#endif // !defined(_TC_TYPE_82C08AE5_D6D8_42EF_A019_AD4009CD9D7C_INCLUDED_)

#if !defined(_TC_TYPE_6D67E62F_71CE_4246_BFBA_598CBC724667_INCLUDED_)
#define _TC_TYPE_6D67E62F_71CE_4246_BFBA_598CBC724667_INCLUDED_
/// <summary>
/// Offers an access interface for LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_LREAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="fValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(double& fValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="fValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(double fValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_LREAL, IID_ITcVnAccess_LREAL);
#endif // !defined(_TC_TYPE_6D67E62F_71CE_4246_BFBA_598CBC724667_INCLUDED_)

#if !defined(_TC_TYPE_21AEB775_EF11_4F5F_A93D_84005AC02C23_INCLUDED_)
#define _TC_TYPE_21AEB775_EF11_4F5F_A93D_84005AC02C23_INCLUDED_
/// <summary>
/// Offers an access interface for REAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_REAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="fValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(float& fValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="fValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(float fValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_REAL, IID_ITcVnAccess_REAL);
#endif // !defined(_TC_TYPE_21AEB775_EF11_4F5F_A93D_84005AC02C23_INCLUDED_)

#if !defined(_TC_TYPE_0487C72D_26A8_4216_8606_07B28D49DF16_INCLUDED_)
#define _TC_TYPE_0487C72D_26A8_4216_8606_07B28D49DF16_INCLUDED_
/// <summary>
/// Offers an access interface for SINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_SINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(char& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(char nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_SINT, IID_ITcVnAccess_SINT);
#endif // !defined(_TC_TYPE_0487C72D_26A8_4216_8606_07B28D49DF16_INCLUDED_)

#if !defined(_TC_TYPE_6AE5D2B2_3BF7_458C_9FE2_B3074B61AD63_INCLUDED_)
#define _TC_TYPE_6AE5D2B2_3BF7_458C_9FE2_B3074B61AD63_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnDMatch values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnDMatch : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="stDMatch">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnDMatch& stDMatch) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="stDMatch">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnDMatch& stDMatch) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnDMatch, IID_ITcVnAccess_TcVnDMatch);
#endif // !defined(_TC_TYPE_6AE5D2B2_3BF7_458C_9FE2_B3074B61AD63_INCLUDED_)

#if !defined(_TC_TYPE_788837B1_9E55_43A4_AF2B_1B81D5D3C276_INCLUDED_)
#define _TC_TYPE_788837B1_9E55_43A4_AF2B_1B81D5D3C276_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnRectangle_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnRectangle_DINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="stRectangle">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnRectangle_DINT& stRectangle) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="stRectangle">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnRectangle_DINT& stRectangle) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnRectangle_DINT, IID_ITcVnAccess_TcVnRectangle_DINT);
#endif // !defined(_TC_TYPE_788837B1_9E55_43A4_AF2B_1B81D5D3C276_INCLUDED_)

#if !defined(_TC_TYPE_7C3899C4_4A43_4F7D_980E_27692F5C803E_INCLUDED_)
#define _TC_TYPE_7C3899C4_4A43_4F7D_980E_27692F5C803E_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector2_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector2_DINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector2_DINT& aVector) = 0;
	/// <summary>
	/// Sets the value.
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector2_DINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector2_DINT, IID_ITcVnAccess_TcVnVector2_DINT);
#endif // !defined(_TC_TYPE_7C3899C4_4A43_4F7D_980E_27692F5C803E_INCLUDED_)

#if !defined(_TC_TYPE_C094FF76_F4ED_4556_B23E_D688BEB8A0FF_INCLUDED_)
#define _TC_TYPE_C094FF76_F4ED_4556_B23E_D688BEB8A0FF_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector2_INT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector2_INT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector2_INT& aVector) = 0;
	/// <summary>
	/// Sets the value.
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector2_INT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector2_INT, IID_ITcVnAccess_TcVnVector2_INT);
#endif // !defined(_TC_TYPE_C094FF76_F4ED_4556_B23E_D688BEB8A0FF_INCLUDED_)

#if !defined(_TC_TYPE_F3273513_9CCC_4685_B709_62C964EC6C8A_INCLUDED_)
#define _TC_TYPE_F3273513_9CCC_4685_B709_62C964EC6C8A_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector2_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector2_REAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector2_REAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector2_REAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector2_REAL, IID_ITcVnAccess_TcVnVector2_REAL);
#endif // !defined(_TC_TYPE_F3273513_9CCC_4685_B709_62C964EC6C8A_INCLUDED_)

#if !defined(_TC_TYPE_0925DD5F_990F_485E_8DEC_2A83E719410D_INCLUDED_)
#define _TC_TYPE_0925DD5F_990F_485E_8DEC_2A83E719410D_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector2_SINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector2_SINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector2_SINT& aVector) = 0;
	/// <summary>
	/// Sets the value.
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector2_SINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector2_SINT, IID_ITcVnAccess_TcVnVector2_SINT);
#endif // !defined(_TC_TYPE_0925DD5F_990F_485E_8DEC_2A83E719410D_INCLUDED_)

#if !defined(_TC_TYPE_87224FDC_7436_43AB_BC6B_F65B3127132C_INCLUDED_)
#define _TC_TYPE_87224FDC_7436_43AB_BC6B_F65B3127132C_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector2_UINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector2_UINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector2_UINT& aVector) = 0;
	/// <summary>
	/// Sets the value.
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector2_UINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector2_UINT, IID_ITcVnAccess_TcVnVector2_UINT);
#endif // !defined(_TC_TYPE_87224FDC_7436_43AB_BC6B_F65B3127132C_INCLUDED_)

#if !defined(_TC_TYPE_475238AC_6DC0_4B71_8963_9FFB61837664_INCLUDED_)
#define _TC_TYPE_475238AC_6DC0_4B71_8963_9FFB61837664_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector2_USINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector2_USINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector2_USINT& aVector) = 0;
	/// <summary>
	/// Sets the value.
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector2_USINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector2_USINT, IID_ITcVnAccess_TcVnVector2_USINT);
#endif // !defined(_TC_TYPE_475238AC_6DC0_4B71_8963_9FFB61837664_INCLUDED_)

#if !defined(_TC_TYPE_96CA0768_0293_4D60_AF79_F5575EB993B6_INCLUDED_)
#define _TC_TYPE_96CA0768_0293_4D60_AF79_F5575EB993B6_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector3_INT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector3_INT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector3_INT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector3_INT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector3_INT, IID_ITcVnAccess_TcVnVector3_INT);
#endif // !defined(_TC_TYPE_96CA0768_0293_4D60_AF79_F5575EB993B6_INCLUDED_)

#if !defined(_TC_TYPE_D62BE8B8_B130_4192_AD85_9F0C63F30A74_INCLUDED_)
#define _TC_TYPE_D62BE8B8_B130_4192_AD85_9F0C63F30A74_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector3_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector3_REAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector3_REAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector3_REAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector3_REAL, IID_ITcVnAccess_TcVnVector3_REAL);
#endif // !defined(_TC_TYPE_D62BE8B8_B130_4192_AD85_9F0C63F30A74_INCLUDED_)

#if !defined(_TC_TYPE_1B5B7311_E83D_41DD_B263_0BA2CED8319D_INCLUDED_)
#define _TC_TYPE_1B5B7311_E83D_41DD_B263_0BA2CED8319D_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector3_SINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector3_SINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector3_SINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector3_SINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector3_SINT, IID_ITcVnAccess_TcVnVector3_SINT);
#endif // !defined(_TC_TYPE_1B5B7311_E83D_41DD_B263_0BA2CED8319D_INCLUDED_)

#if !defined(_TC_TYPE_7614254E_8CCE_4C28_A1BB_68E69F40EB02_INCLUDED_)
#define _TC_TYPE_7614254E_8CCE_4C28_A1BB_68E69F40EB02_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector3_UINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector3_UINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector3_UINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector3_UINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector3_UINT, IID_ITcVnAccess_TcVnVector3_UINT);
#endif // !defined(_TC_TYPE_7614254E_8CCE_4C28_A1BB_68E69F40EB02_INCLUDED_)

#if !defined(_TC_TYPE_6D53AB22_1E21_44A9_9579_B605E4DFFF94_INCLUDED_)
#define _TC_TYPE_6D53AB22_1E21_44A9_9579_B605E4DFFF94_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector3_USINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector3_USINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector3_USINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector3_USINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector3_USINT, IID_ITcVnAccess_TcVnVector3_USINT);
#endif // !defined(_TC_TYPE_6D53AB22_1E21_44A9_9579_B605E4DFFF94_INCLUDED_)

#if !defined(_TC_TYPE_145CA3F8_C73D_4106_807D_89774C71C360_INCLUDED_)
#define _TC_TYPE_145CA3F8_C73D_4106_807D_89774C71C360_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector4_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector4_DINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector4_DINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector4_DINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector4_DINT, IID_ITcVnAccess_TcVnVector4_DINT);
#endif // !defined(_TC_TYPE_145CA3F8_C73D_4106_807D_89774C71C360_INCLUDED_)

#if !defined(_TC_TYPE_C6EBEC76_FA9E_401A_9288_52F73A86A051_INCLUDED_)
#define _TC_TYPE_C6EBEC76_FA9E_401A_9288_52F73A86A051_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector4_INT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector4_INT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector4_INT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector4_INT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector4_INT, IID_ITcVnAccess_TcVnVector4_INT);
#endif // !defined(_TC_TYPE_C6EBEC76_FA9E_401A_9288_52F73A86A051_INCLUDED_)

#if !defined(_TC_TYPE_59B6E8C8_D07D_4893_AFF4_0C86FFDF14B2_INCLUDED_)
#define _TC_TYPE_59B6E8C8_D07D_4893_AFF4_0C86FFDF14B2_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector4_LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector4_LREAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector4_LREAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector4_LREAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector4_LREAL, IID_ITcVnAccess_TcVnVector4_LREAL);
#endif // !defined(_TC_TYPE_59B6E8C8_D07D_4893_AFF4_0C86FFDF14B2_INCLUDED_)

#if !defined(_TC_TYPE_810CFD98_AB51_4398_9DB3_9D529DE76E1B_INCLUDED_)
#define _TC_TYPE_810CFD98_AB51_4398_9DB3_9D529DE76E1B_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector4_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector4_REAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector4_REAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector4_REAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector4_REAL, IID_ITcVnAccess_TcVnVector4_REAL);
#endif // !defined(_TC_TYPE_810CFD98_AB51_4398_9DB3_9D529DE76E1B_INCLUDED_)

#if !defined(_TC_TYPE_7CFD71B1_3B6C_471C_9752_5C1DA7F32900_INCLUDED_)
#define _TC_TYPE_7CFD71B1_3B6C_471C_9752_5C1DA7F32900_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector4_SINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector4_SINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector4_SINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector4_SINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector4_SINT, IID_ITcVnAccess_TcVnVector4_SINT);
#endif // !defined(_TC_TYPE_7CFD71B1_3B6C_471C_9752_5C1DA7F32900_INCLUDED_)

#if !defined(_TC_TYPE_3A3DA38B_309A_4BBC_9362_4ED7A7CF7B45_INCLUDED_)
#define _TC_TYPE_3A3DA38B_309A_4BBC_9362_4ED7A7CF7B45_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector4_UINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector4_UINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector4_UINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector4_UINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector4_UINT, IID_ITcVnAccess_TcVnVector4_UINT);
#endif // !defined(_TC_TYPE_3A3DA38B_309A_4BBC_9362_4ED7A7CF7B45_INCLUDED_)

#if !defined(_TC_TYPE_B0FB083F_A0CD_4728_B39E_34BDD4FE2948_INCLUDED_)
#define _TC_TYPE_B0FB083F_A0CD_4728_B39E_34BDD4FE2948_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnVector4_USINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnVector4_USINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnVector4_USINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnVector4_USINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnVector4_USINT, IID_ITcVnAccess_TcVnVector4_USINT);
#endif // !defined(_TC_TYPE_B0FB083F_A0CD_4728_B39E_34BDD4FE2948_INCLUDED_)

#if !defined(_TC_TYPE_7196ECF3_D7E6_4F01_9889_652C87275E3C_INCLUDED_)
#define _TC_TYPE_7196ECF3_D7E6_4F01_9889_652C87275E3C_INCLUDED_
/// <summary>
/// Offers an access interface for UDINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_UDINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(ULONG& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(ULONG nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_UDINT, IID_ITcVnAccess_UDINT);
#endif // !defined(_TC_TYPE_7196ECF3_D7E6_4F01_9889_652C87275E3C_INCLUDED_)

#if !defined(_TC_TYPE_8670B02D_0498_4657_ADA1_441E54B74270_INCLUDED_)
#define _TC_TYPE_8670B02D_0498_4657_ADA1_441E54B74270_INCLUDED_
/// <summary>
/// Offers an access interface for UINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_UINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(USHORT& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(USHORT nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_UINT, IID_ITcVnAccess_UINT);
#endif // !defined(_TC_TYPE_8670B02D_0498_4657_ADA1_441E54B74270_INCLUDED_)

#if !defined(_TC_TYPE_252DBC07_54C1_47D5_9A56_BEA40BDD3A76_INCLUDED_)
#define _TC_TYPE_252DBC07_54C1_47D5_9A56_BEA40BDD3A76_INCLUDED_
/// <summary>
/// Offers an access interface for ULINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_ULINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(ULONGLONG& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(ULONGLONG nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_ULINT, IID_ITcVnAccess_ULINT);
#endif // !defined(_TC_TYPE_252DBC07_54C1_47D5_9A56_BEA40BDD3A76_INCLUDED_)

#if !defined(_TC_TYPE_975032E0_7E5A_4866_AB67_13B20C8FC9CB_INCLUDED_)
#define _TC_TYPE_975032E0_7E5A_4866_AB67_13B20C8FC9CB_INCLUDED_
/// <summary>
/// Offers an access interface for USINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_USINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(unsigned char& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(unsigned char nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_USINT, IID_ITcVnAccess_USINT);
#endif // !defined(_TC_TYPE_975032E0_7E5A_4866_AB67_13B20C8FC9CB_INCLUDED_)

#if !defined(_TC_TYPE_500E63A9_3202_40BD_9395_A71A6CA83DA4_INCLUDED_)
#define _TC_TYPE_500E63A9_3202_40BD_9395_A71A6CA83DA4_INCLUDED_
/// <summary>
/// Interface for exporting an image as a Windows Bitmap (BMP).
/// </summary>
struct __declspec(novtable) ITcVnBitmapExport : public ITcUnknown
{
	/// <summary>
	/// Gets size of the image if it is converted to a Windows Bitmap (BMP).
	/// </summary>
	/// <param name="nBitmapSize">Output parameter containing the required buffer size.</param>
	/// <param name="nBitmapWidth">Desired width or 0 to keep the original width (in) and actual width (out).</param>
	/// <param name="nBitmapHeight">Desired height or 0 to keep the original height (in) and actual height (out).</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetBitmapSize(ULONGLONG& nBitmapSize, ULONG& nBitmapWidth, ULONG& nBitmapHeight) = 0;
	/// <summary>
	/// Export the image as a Windows Bitmap (BMP) into a given buffer.
	/// </summary>
	/// <param name="nBitmapSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <param name="nBitmapWidth">Desired width or 0 to keep the original width (in) and actual width (out).</param>
	/// <param name="nBitmapHeight">Desired height or 0 to keep the original height (in) and actual height (out).</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetBitmapImage(ULONGLONG& nBitmapSize, PVOID pDestBuffer, ULONG& nBitmapWidth, ULONG& nBitmapHeight) = 0;
};
#endif // !defined(_TC_TYPE_500E63A9_3202_40BD_9395_A71A6CA83DA4_INCLUDED_)

#if !defined(_TC_TYPE_733357A0_AA2A_4242_B876_C2B34FEEF1F8_INCLUDED_)
#define _TC_TYPE_733357A0_AA2A_4242_B876_C2B34FEEF1F8_INCLUDED_
/// <summary>
/// Interface required for sending displayable images as ADS notifications
/// </summary>
struct __declspec(novtable) ITcVnBitmapExportNotification : public ITcUnknown
{
	/// <summary>
	/// Gets the timestamp of the latest image change.
	/// </summary>
	/// <param name="nTimestamp">Returns the timestamp.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTimestamp(LONGLONG& nTimestamp) = 0;
	/// <summary>
	/// Export the image as a Windows Bitmap (BMP) into a given buffer by means of an unlocked remote procedure call. It lies within the responsibility of the user to ensure that no conflicting accesses can occur.
	/// </summary>
	/// <param name="nBitmapSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <param name="nBitmapWidth">Desired width or 0 to keep the original width (in) and actual width (out).</param>
	/// <param name="nBitmapHeight">Desired height or 0 to keep the original height (in) and actual height (out).</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetBitmapImageRpcUnlocked(ULONGLONG& nBitmapSize, PVOID pDestBuffer, ULONG& nBitmapWidth, ULONG& nBitmapHeight) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnBitmapExportNotification, IID_ITcVnBitmapExportNotification);
#endif // !defined(_TC_TYPE_733357A0_AA2A_4242_B876_C2B34FEEF1F8_INCLUDED_)

#if !defined(_TC_TYPE_48DA88B5_7B23_4BD4_921B_D39483F1D3BA_INCLUDED_)
#define _TC_TYPE_48DA88B5_7B23_4BD4_921B_D39483F1D3BA_INCLUDED_
/// <summary>
/// Interface to export an image as a Windows Bitmap (BMP) into a given buffer by means of an unlocked remote procedure call.
/// </summary>
struct __declspec(novtable) ITcVnBitmapExportRpcUnlocked : public ITcVnBitmapExport
{
	/// <summary>
	/// Export the image as a Windows Bitmap (BMP) into a given buffer by means of an unlocked remote procedure call. It lies within the responsibility of the user to ensure that no conflicting accesses can occur.
	/// </summary>
	/// <param name="nBitmapSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <param name="nBitmapWidth">Desired width or 0 to keep the original width (in) and actual width (out).</param>
	/// <param name="nBitmapHeight">Desired height or 0 to keep the original height (in) and actual height (out).</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetBitmapImageRpcUnlocked(ULONGLONG& nBitmapSize, PVOID pDestBuffer, ULONG& nBitmapWidth, ULONG& nBitmapHeight) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnBitmapExportRpcUnlocked, IID_ITcVnBitmapExportRpcUnlocked);
#endif // !defined(_TC_TYPE_48DA88B5_7B23_4BD4_921B_D39483F1D3BA_INCLUDED_)

#if !defined(_TC_TYPE_BC72B333_E095_465B_9693_7979773CA3B8_INCLUDED_)
#define _TC_TYPE_BC72B333_E095_465B_9693_7979773CA3B8_INCLUDED_
/// <summary>
/// Offers an interface for an object container.
/// </summary>
struct __declspec(novtable) ITcVnContainer : public ITcUnknown
{
	/// <summary>
	/// Checks if the container contains only basic (non-container) elements.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfBasicContainer() = 0;
	/// <summary>
	/// Checks if the container is empty. (Alternatively use F_VN_CheckIfEmpty.)
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfEmpty() = 0;
	/// <summary>
	/// Gets an interface pointer to a bidirectional iterator (if this iterator type is supported by the container) and increment its reference counter.
	/// </summary>
	/// <param name="pipIterator">Returns the iterator interface.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetBidirectionalIterator(ITcVnBidirectionalIterator** pipIterator) = 0;
	/// <summary>
	/// Gets the size (number of elements) of the container. (Alternatively use F_VN_GetNumberOfElements.)
	/// </summary>
	/// <param name="nElementNum">Returns the number of elements in the container.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetElementNum(ULONGLONG& nElementNum) = 0;
	/// <summary>
	/// Gets the size (in byte) of each element in the container.
	/// </summary>
	/// <param name="nSize">Returns the size in byte of a single element in the container.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetElementSize(ULONGLONG& nSize) = 0;
	/// <summary>
	/// Gets the GUID of the container elements.
	/// </summary>
	/// <param name="nTypeGuid">Returns the GUID of the container elements.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetElementTypeGuid(GUID& nTypeGuid) = 0;
	/// <summary>
	/// Gets combined size (in byte) of all elements in the container.
	/// </summary>
	/// <param name="nExportSize">Returns the combined size (in byte) of all elements in the container.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetExportSize(ULONGLONG& nExportSize) = 0;
	/// <summary>
	/// Gets an interface pointer to a forward iterator (if this iterator type is supported by the container) and increment its reference counter. (Alternatively use F_VN_GetForwardIterator.)
	/// </summary>
	/// <param name="pipIterator">Returns the iterator interface.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetForwardIterator(ITcVnForwardIterator** pipIterator) = 0;
	/// <summary>
	/// Gets an interface pointer to a random access iterator (if this iterator type is supported by the container) and increment its reference counter. (Alternatively use F_VN_GetRandomAccessIterator.)
	/// </summary>
	/// <param name="pipIterator">Returns the iterator interface.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetRandomAccessIterator(ITcVnRandomAccessIterator** pipIterator) = 0;
	/// <summary>
	/// Gets GUID of the container.
	/// </summary>
	/// <param name="nTypeGuid">Returns the GUID of the container.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTypeGuid(GUID& nTypeGuid) = 0;
	/// <summary>
	/// Gets the container type name as a string.
	/// </summary>
	/// <param name="sTypeName">Returns the container type name as a string.</param>
	/// <param name="nMaxLen">Maximum string length allowed to be written in sTypeName</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTypeName(PCHAR sTypeName, USHORT nMaxLen) = 0;
};
#endif // !defined(_TC_TYPE_BC72B333_E095_465B_9693_7979773CA3B8_INCLUDED_)

#if !defined(_TC_TYPE_C10B6EE2_EA6E_4FED_AC4E_D3C8366F26C0_INCLUDED_)
#define _TC_TYPE_C10B6EE2_EA6E_4FED_AC4E_D3C8366F26C0_INCLUDED_
/// <summary>
/// Interface for accessing data.
/// </summary>
struct __declspec(novtable) ITcVnData : public ITcUnknown
{
	/// <summary>
	/// Check if the data are a copy (returns S_OK for copies and S_FALSE otherwise).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfCopy() = 0;
	/// <summary>
	/// Check if the data belongs to an image (returns S_OK for images and S_FALSE otherwise).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfImage() = 0;
	/// <summary>
	/// Gets the size of the data.
	/// </summary>
	/// <param name="nSize">Size of the stored data in bytes.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetSize(ULONGLONG& nSize) = 0;
	/// <summary>
	/// Check if the data pointer is different from 0 (returns S_OK for non-zero data pointers and S_FALSE otherwise).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckDataPointer() = 0;
	/// <summary>
	/// Gets the data pointer (the obtained data pointer must be released by calling ReleaseDataPointer).
	/// </summary>
	/// <param name="ppData">Returns the data pointer.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetDataPointer(PVOID* ppData) = 0;
	/// <summary>
	/// Release the data pointer.
	/// </summary>
	/// <param name="ppData">Pointer to the data pointer to be released.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI ReleaseDataPointer(PVOID* ppData) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnData, IID_ITcVnData);
#endif // !defined(_TC_TYPE_C10B6EE2_EA6E_4FED_AC4E_D3C8366F26C0_INCLUDED_)

#if !defined(_TC_TYPE_6766D7F3_3908_4D4C_8A3B_39ED7C3EC1E2_INCLUDED_)
#define _TC_TYPE_6766D7F3_3908_4D4C_8A3B_39ED7C3EC1E2_INCLUDED_
/// <summary>
/// Interface for displayable images.
/// </summary>
struct __declspec(novtable) ITcVnDisplayableImage : public ITcUnknown
{
};
#endif // !defined(_TC_TYPE_6766D7F3_3908_4D4C_8A3B_39ED7C3EC1E2_INCLUDED_)

#if !defined(_TC_TYPE_8762D1CC_970E_47FD_84DA_E97E36A07768_INCLUDED_)
#define _TC_TYPE_8762D1CC_970E_47FD_84DA_E97E36A07768_INCLUDED_
/// <summary>
/// Interface for exporting a histogram for an image as an array.
/// </summary>
struct __declspec(novtable) ITcVnHistogramExport : public ITcUnknown
{
	/// <summary>
	/// Gets the size of the histogram array.
	/// </summary>
	/// <param name="nHistogramSize">Output parameter containing the required buffer size.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetHistogramSize(ULONGLONG& nHistogramSize) = 0;
	/// <summary>
	/// Gets the histogram array.
	/// </summary>
	/// <param name="nHistogramSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetHistogramArray(ULONGLONG& nHistogramSize, PVOID pDestBuffer) = 0;
	/// <summary>
	/// Gets the size of a custom histogram array.
	/// </summary>
	/// <param name="nHistogramSize">Output parameter containing the required buffer size.</param>
	/// <param name="nBins">Desired number of bins or 0 to keep the default for the corresponding image format (in) and default number of bins (out).</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetCustomHistogramSize(ULONGLONG& nHistogramSize, ULONG& nBins) = 0;
	/// <summary>
	/// Gets a custom histogram array.
	/// </summary>
	/// <param name="nHistogramSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <param name="nBins">Desired number of bins or 0 to keep the default for the corresponding image format (in) and default number of bins (out).</param>
	/// <param name="fLowerBound">Lower (inclusive) boundary of the 0-th histogram bin (in), or receive the default if fLowerBound AND fUpperBound are set to 0 (out).</param>
	/// <param name="fUpperBound">Upper (exclusive) boundary of the last histogram bin nBins-1 (in), or receive the default if fLowerBound AND fUpperBound are set to 0 (out).</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetCustomHistogramArray(ULONGLONG& nHistogramSize, PVOID pDestBuffer, ULONG& nBins, double& fLowerBound, double& fUpperBound) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnHistogramExport, IID_ITcVnHistogramExport);
#endif // !defined(_TC_TYPE_8762D1CC_970E_47FD_84DA_E97E36A07768_INCLUDED_)

#if !defined(_TC_TYPE_B05227C0_7FB6_4EBC_B79C_8DC65E1F5DAA_INCLUDED_)
#define _TC_TYPE_B05227C0_7FB6_4EBC_B79C_8DC65E1F5DAA_INCLUDED_
/// <summary>
/// Interface for an image provider.
/// </summary>
struct __declspec(novtable) ITcVnImageProvider : public ITcUnknown
{
	/// <summary>
	/// Check whether the module is busy; i.e, an operation is in progress.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfBusy() = 0;
	/// <summary>
	/// Check if the camera is properly connected (Returns S_OK if connected and S_FALSE if not. Can only check software connection, i.e. the check is unable to determine if the cable is connected or not in case that S_FALSE is returned).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfCameraConnected() = 0;
	/// <summary>
	/// Gets the current image by detaching its internal reference.
	/// </summary>
	/// <param name="pipImage">Pointer to the interface pointer to be returned, might be 0 if the image acquisition failed.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetCurrentImage(ITcVnImage** pipImage) = 0;
	/// <summary>
	/// Gets result of the last operation performed.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetError() = 0;
	/// <summary>
	/// Open camera (open the control channel, open a stream channel, and activate the GVSP receiver).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI OpenCamera() = 0;
	/// <summary>
	/// Close camera (deactivate the GVSP receiver, close the stream channel, and close the control channel).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CloseCamera() = 0;
	/// <summary>
	/// Start image acquisition.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI StartAcquisition() = 0;
	/// <summary>
	/// Stop image acquisition.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI StopAcquisition() = 0;
	/// <summary>
	/// Initialize the software trigger and trigger it. The initialization step is skipped if it was executed before.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SoftwareTrigger() = 0;
	/// <summary>
	/// Set camera to initial state.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI InitializeCamera() = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnImageProvider, IID_ITcVnImageProvider);
#endif // !defined(_TC_TYPE_B05227C0_7FB6_4EBC_B79C_8DC65E1F5DAA_INCLUDED_)

#if !defined(_TC_TYPE_0162856D_6491_4A66_BB3A_80489E400478_INCLUDED_)
#define _TC_TYPE_0162856D_6491_4A66_BB3A_80489E400478_INCLUDED_
/// <summary>
/// Offers a base interface for iterators
/// </summary>
struct __declspec(novtable) ITcVnIteratorBase : public ITcUnknown
{
	/// <summary>
	/// Checks if the iterator points to the first element.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfBegin() = 0;
	/// <summary>
	/// Checks if the iterator points to the past-the-end element (alternatively use F_VN_CheckIfIteratorIsAtEnd).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfEnd() = 0;
	/// <summary>
	/// Gets the memory size (in byte) required by the value the iterator points to.
	/// </summary>
	/// <param name="nSize">Returns the element size in bytes.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetValueSize(ULONGLONG& nSize) = 0;
	/// <summary>
	/// Gets the type GUID of the value the iterator points to.
	/// </summary>
	/// <param name="nTypeGuid">Returns the type GUID.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetValueTypeGuid(GUID& nTypeGuid) = 0;
	/// <summary>
	/// Sets the iterator to the first element (alternatively use F_VN_SetIteratorToBegin).
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetToBegin() = 0;
	/// <summary>
	/// Sets the iterator to the past-the-end element.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetToEnd() = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnIteratorBase, IID_ITcVnIteratorBase);
#endif // !defined(_TC_TYPE_0162856D_6491_4A66_BB3A_80489E400478_INCLUDED_)

#if !defined(_TC_TYPE_F002C7C2_AE73_45A5_949B_FC51184F2226_INCLUDED_)
#define _TC_TYPE_F002C7C2_AE73_45A5_949B_FC51184F2226_INCLUDED_
/// <summary>
/// Offers an interface providing a method for creating a new iterator to the same position.
/// </summary>
struct __declspec(novtable) ITcVnIteratorCopyCreator : public ITcUnknown
{
	/// <summary>
	/// Create a new iterator pointing to the position of the calling iterator.
	/// </summary>
	/// <param name="pipIterator">Returns the created iterator.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Create(ITcVnForwardIterator** pipIterator) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnIteratorCopyCreator, IID_ITcVnIteratorCopyCreator);
#endif // !defined(_TC_TYPE_F002C7C2_AE73_45A5_949B_FC51184F2226_INCLUDED_)

#if !defined(_TC_TYPE_AC23D64B_CDFA_4D43_AE8B_364A856EB3E2_INCLUDED_)
#define _TC_TYPE_AC23D64B_CDFA_4D43_AE8B_364A856EB3E2_INCLUDED_
/// <summary>
/// Interface for a machine learning model.
/// </summary>
struct __declspec(novtable) ITcVnMlModel : public ITcUnknown
{
	/// <summary>
	/// Gets the GUID of the model.
	/// </summary>
	/// <param name="nTypeGuid">Returns the GUID of the model.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTypeGuid(GUID& nTypeGuid) = 0;
	/// <summary>
	/// Gets the model type name as a string.
	/// </summary>
	/// <param name="sTypeName">Returns the model type name as a string.</param>
	/// <param name="nMaxLen">Maximum string length allowed to be written in sTypeName.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTypeName(PCHAR sTypeName, USHORT nMaxLen) = 0;
};
#endif // !defined(_TC_TYPE_AC23D64B_CDFA_4D43_AE8B_364A856EB3E2_INCLUDED_)

#if !defined(_TC_TYPE_E4FB6944_2DE3_495A_A7E6_182A6EDDF670_INCLUDED_)
#define _TC_TYPE_E4FB6944_2DE3_495A_A7E6_182A6EDDF670_INCLUDED_
/// <summary>
/// Interface for neural networks.
/// </summary>
struct __declspec(novtable) ITcVnNeuralNetwork : public ITcVnMlModel
{
	/// <summary>
	/// Execute a neural network using the provided image as input and provide the output of one output layer. The method doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="pipDestImage">Destination image (An appropriate destination image based on the output layer is created. To process the destination image, use e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage if necessary.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Execute(ITcVnImage* ipSrcImage, ITcVnImage** pipDestImage) = 0;
	/// <summary>
	/// Execute a neural network using the provided image as input and provide the output of the specified output layer. The method doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="pipDestImage">Destination image (An appropriate destination image based on the output layer is created. To process the destination image, use e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage if necessary.</param>
	/// <param name="sLayerName">Specify the name of the layer for which the output is required. If empty, the output of one output layer is provided.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Execute_SingleLayerOutput(ITcVnImage* ipSrcImage, ITcVnImage** pipDestImage, PCCH sLayerName) = 0;
	/// <summary>
	/// Execute a neural network using the provided image as input and provide the output of the specified output layers. If sLayerNames is empty, the method returns the output of the unconnected output layers. The method doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="pipDestImages">Container of images containing the output from the specified layers</param>
	/// <param name="ipLayerNames">Container of layer names whose outputs to be returned (ContainerType_Vector_String_SINT). If set to zero, the container ipDestImages holds the outputs of all the unconnected output layers.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Execute_MultiLayerOutput(ITcVnImage* ipSrcImage, ITcVnContainer** pipDestImages, ITcVnContainer* ipLayerNames) = 0;
	/// <summary>
	/// Get the name of all layers in the model. If the bOnlyOuput flag is set to true, only the unconnected output layer names are returned.
	/// </summary>
	/// <param name="pipLayerNames">Container with the layers names (ContainerType_Vector_String_SINT) </param>
	/// <param name="bOnlyOutputs">If true, only the unconnected output layer names are returned</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetLayerNames(ITcVnContainer** pipLayerNames, bool bOnlyOutputs) = 0;
};
#endif // !defined(_TC_TYPE_E4FB6944_2DE3_495A_A7E6_182A6EDDF670_INCLUDED_)

#if !defined(_TC_TYPE_90B5507C_52E3_4DA4_895B_7274317CC7D6_INCLUDED_)
#define _TC_TYPE_90B5507C_52E3_4DA4_895B_7274317CC7D6_INCLUDED_
/// <summary>
/// Offers a random access interface for DINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_DINT : public ITcVnAccess_DINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, LONG& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, LONG nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_DINT, IID_ITcVnRandomAccess_DINT);
#endif // !defined(_TC_TYPE_90B5507C_52E3_4DA4_895B_7274317CC7D6_INCLUDED_)

#if !defined(_TC_TYPE_55B49B83_CD33_4312_AC44_EFAE0B975C28_INCLUDED_)
#define _TC_TYPE_55B49B83_CD33_4312_AC44_EFAE0B975C28_INCLUDED_
/// <summary>
/// Offers a random access interface for INT values
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_INT : public ITcVnAccess_INT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, SHORT& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, SHORT nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_INT, IID_ITcVnRandomAccess_INT);
#endif // !defined(_TC_TYPE_55B49B83_CD33_4312_AC44_EFAE0B975C28_INCLUDED_)

#if !defined(_TC_TYPE_F52C8D8B_2284_4E73_B79B_98A8EB1B7CEE_INCLUDED_)
#define _TC_TYPE_F52C8D8B_2284_4E73_B79B_98A8EB1B7CEE_INCLUDED_
/// <summary>
/// Offers an random access interface for images.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_ITcVnImage : public ITcVnAccess_ITcVnImage
{
	/// <summary>
	/// Gets the image.
	/// </summary>
	/// <param name="nOffset">Offset to the current position.</param>
	/// <param name="ipImage">Returns the image.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, ITcVnImage*& ipImage) = 0;
	/// <summary>
	/// Sets the image.
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="ipImage">The image to set.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, ITcVnImage* ipImage) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_ITcVnImage, IID_ITcVnRandomAccess_ITcVnImage);
#endif // !defined(_TC_TYPE_F52C8D8B_2284_4E73_B79B_98A8EB1B7CEE_INCLUDED_)

#if !defined(_TC_TYPE_1E9D51F1_9741_4E56_A25E_D5365993D80A_INCLUDED_)
#define _TC_TYPE_1E9D51F1_9741_4E56_A25E_D5365993D80A_INCLUDED_
/// <summary>
/// Offers a random access interface for LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_LREAL : public ITcVnAccess_LREAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="fValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, double& fValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position.</param>
	/// <param name="fValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, double fValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_LREAL, IID_ITcVnRandomAccess_LREAL);
#endif // !defined(_TC_TYPE_1E9D51F1_9741_4E56_A25E_D5365993D80A_INCLUDED_)

#if !defined(_TC_TYPE_DB17B2E5_3A5D_43F8_9FC0_C1A0A93D1559_INCLUDED_)
#define _TC_TYPE_DB17B2E5_3A5D_43F8_9FC0_C1A0A93D1559_INCLUDED_
/// <summary>
/// Offers a random access interface for REAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_REAL : public ITcVnAccess_REAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="fValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, float& fValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="fValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, float fValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_REAL, IID_ITcVnRandomAccess_REAL);
#endif // !defined(_TC_TYPE_DB17B2E5_3A5D_43F8_9FC0_C1A0A93D1559_INCLUDED_)

#if !defined(_TC_TYPE_E734E903_5AEA_4877_A6BF_58B4F394488C_INCLUDED_)
#define _TC_TYPE_E734E903_5AEA_4877_A6BF_58B4F394488C_INCLUDED_
/// <summary>
/// Offers a random access interface for SINT values
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_SINT : public ITcVnAccess_SINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, char& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, char nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_SINT, IID_ITcVnRandomAccess_SINT);
#endif // !defined(_TC_TYPE_E734E903_5AEA_4877_A6BF_58B4F394488C_INCLUDED_)

#if !defined(_TC_TYPE_E0561896_2FF7_4D83_AC45_DDFEE1532049_INCLUDED_)
#define _TC_TYPE_E0561896_2FF7_4D83_AC45_DDFEE1532049_INCLUDED_
/// <summary>
/// Offers an random access interface for TcVnDMatch values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnDMatch : public ITcVnAccess_TcVnDMatch
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position.</param>
	/// <param name="stDMatch">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnDMatch& stDMatch) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="stDMatch">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnDMatch& stDMatch) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnDMatch, IID_ITcVnRandomAccess_TcVnDMatch);
#endif // !defined(_TC_TYPE_E0561896_2FF7_4D83_AC45_DDFEE1532049_INCLUDED_)

#if !defined(_TC_TYPE_BF284756_4FFC_4A8B_9FCB_627AFBA2F9F7_INCLUDED_)
#define _TC_TYPE_BF284756_4FFC_4A8B_9FCB_627AFBA2F9F7_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnRectangle_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnRectangle_DINT : public ITcVnAccess_TcVnRectangle_DINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="stRectangle">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnRectangle_DINT& stRectangle) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="stRectangle">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnRectangle_DINT& stRectangle) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnRectangle_DINT, IID_ITcVnRandomAccess_TcVnRectangle_DINT);
#endif // !defined(_TC_TYPE_BF284756_4FFC_4A8B_9FCB_627AFBA2F9F7_INCLUDED_)

#if !defined(_TC_TYPE_847677D5_CBC1_4CEF_BD93_1EB4C0A41732_INCLUDED_)
#define _TC_TYPE_847677D5_CBC1_4CEF_BD93_1EB4C0A41732_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector2_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector2_DINT : public ITcVnAccess_TcVnVector2_DINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector2_DINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector2_DINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector2_DINT, IID_ITcVnRandomAccess_TcVnVector2_DINT);
#endif // !defined(_TC_TYPE_847677D5_CBC1_4CEF_BD93_1EB4C0A41732_INCLUDED_)

#if !defined(_TC_TYPE_894BB9FE_7982_42CF_B7A5_06B2C0B25D1B_INCLUDED_)
#define _TC_TYPE_894BB9FE_7982_42CF_B7A5_06B2C0B25D1B_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector2_INT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector2_INT : public ITcVnAccess_TcVnVector2_INT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector2_INT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector2_INT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector2_INT, IID_ITcVnRandomAccess_TcVnVector2_INT);
#endif // !defined(_TC_TYPE_894BB9FE_7982_42CF_B7A5_06B2C0B25D1B_INCLUDED_)

#if !defined(_TC_TYPE_62D081B8_D6B8_4716_A089_70442409D7CC_INCLUDED_)
#define _TC_TYPE_62D081B8_D6B8_4716_A089_70442409D7CC_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector2_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector2_REAL : public ITcVnAccess_TcVnVector2_REAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector2_REAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector2_REAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector2_REAL, IID_ITcVnRandomAccess_TcVnVector2_REAL);
#endif // !defined(_TC_TYPE_62D081B8_D6B8_4716_A089_70442409D7CC_INCLUDED_)

#if !defined(_TC_TYPE_4D648ABD_113C_4FB0_BFF9_FDB146DE194B_INCLUDED_)
#define _TC_TYPE_4D648ABD_113C_4FB0_BFF9_FDB146DE194B_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector2_SINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector2_SINT : public ITcVnAccess_TcVnVector2_SINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector2_SINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector2_SINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector2_SINT, IID_ITcVnRandomAccess_TcVnVector2_SINT);
#endif // !defined(_TC_TYPE_4D648ABD_113C_4FB0_BFF9_FDB146DE194B_INCLUDED_)

#if !defined(_TC_TYPE_E7732B95_809A_48A9_819F_C0398050AF2F_INCLUDED_)
#define _TC_TYPE_E7732B95_809A_48A9_819F_C0398050AF2F_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector2_UINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector2_UINT : public ITcVnAccess_TcVnVector2_UINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector2_UINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector2_UINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector2_UINT, IID_ITcVnRandomAccess_TcVnVector2_UINT);
#endif // !defined(_TC_TYPE_E7732B95_809A_48A9_819F_C0398050AF2F_INCLUDED_)

#if !defined(_TC_TYPE_3DE1B926_DF4C_41CE_A43D_4FC1D3E9EC87_INCLUDED_)
#define _TC_TYPE_3DE1B926_DF4C_41CE_A43D_4FC1D3E9EC87_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector2_USINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector2_USINT : public ITcVnAccess_TcVnVector2_USINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector2_USINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector2_USINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector2_USINT, IID_ITcVnRandomAccess_TcVnVector2_USINT);
#endif // !defined(_TC_TYPE_3DE1B926_DF4C_41CE_A43D_4FC1D3E9EC87_INCLUDED_)

#if !defined(_TC_TYPE_1E105D1B_EAE2_4E41_82F0_12C7D1885305_INCLUDED_)
#define _TC_TYPE_1E105D1B_EAE2_4E41_82F0_12C7D1885305_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector3_INT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector3_INT : public ITcVnAccess_TcVnVector3_INT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector3_INT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector3_INT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector3_INT, IID_ITcVnRandomAccess_TcVnVector3_INT);
#endif // !defined(_TC_TYPE_1E105D1B_EAE2_4E41_82F0_12C7D1885305_INCLUDED_)

#if !defined(_TC_TYPE_7FE46E54_63FF_432B_97AD_BBC6FF5B6620_INCLUDED_)
#define _TC_TYPE_7FE46E54_63FF_432B_97AD_BBC6FF5B6620_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector3_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector3_REAL : public ITcVnAccess_TcVnVector3_REAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector3_REAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector3_REAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector3_REAL, IID_ITcVnRandomAccess_TcVnVector3_REAL);
#endif // !defined(_TC_TYPE_7FE46E54_63FF_432B_97AD_BBC6FF5B6620_INCLUDED_)

#if !defined(_TC_TYPE_3DBB53DC_9376_4272_9152_41C74C30793B_INCLUDED_)
#define _TC_TYPE_3DBB53DC_9376_4272_9152_41C74C30793B_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector3_SINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector3_SINT : public ITcVnAccess_TcVnVector3_SINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector3_SINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector3_SINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector3_SINT, IID_ITcVnRandomAccess_TcVnVector3_SINT);
#endif // !defined(_TC_TYPE_3DBB53DC_9376_4272_9152_41C74C30793B_INCLUDED_)

#if !defined(_TC_TYPE_B59FA04C_C9A7_4855_8FFB_18FA23F7A998_INCLUDED_)
#define _TC_TYPE_B59FA04C_C9A7_4855_8FFB_18FA23F7A998_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector3_UINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector3_UINT : public ITcVnAccess_TcVnVector3_UINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector3_UINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector3_UINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector3_UINT, IID_ITcVnRandomAccess_TcVnVector3_UINT);
#endif // !defined(_TC_TYPE_B59FA04C_C9A7_4855_8FFB_18FA23F7A998_INCLUDED_)

#if !defined(_TC_TYPE_69E8C978_AEC6_43C9_A12D_5BD936489543_INCLUDED_)
#define _TC_TYPE_69E8C978_AEC6_43C9_A12D_5BD936489543_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector3_USINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector3_USINT : public ITcVnAccess_TcVnVector3_USINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector3_USINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector3_USINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector3_USINT, IID_ITcVnRandomAccess_TcVnVector3_USINT);
#endif // !defined(_TC_TYPE_69E8C978_AEC6_43C9_A12D_5BD936489543_INCLUDED_)

#if !defined(_TC_TYPE_A12E33E7_C3D8_4F85_99B8_55D4B21B4E70_INCLUDED_)
#define _TC_TYPE_A12E33E7_C3D8_4F85_99B8_55D4B21B4E70_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector4_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector4_DINT : public ITcVnAccess_TcVnVector4_DINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector4_DINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector4_DINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector4_DINT, IID_ITcVnRandomAccess_TcVnVector4_DINT);
#endif // !defined(_TC_TYPE_A12E33E7_C3D8_4F85_99B8_55D4B21B4E70_INCLUDED_)

#if !defined(_TC_TYPE_55845100_BBCA_4143_8D01_BE330E1AF7FC_INCLUDED_)
#define _TC_TYPE_55845100_BBCA_4143_8D01_BE330E1AF7FC_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector4_INT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector4_INT : public ITcVnAccess_TcVnVector4_INT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector4_INT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector4_INT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector4_INT, IID_ITcVnRandomAccess_TcVnVector4_INT);
#endif // !defined(_TC_TYPE_55845100_BBCA_4143_8D01_BE330E1AF7FC_INCLUDED_)

#if !defined(_TC_TYPE_B9D5D219_707B_4E0F_B558_507B4E8FC9F4_INCLUDED_)
#define _TC_TYPE_B9D5D219_707B_4E0F_B558_507B4E8FC9F4_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector4_LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector4_LREAL : public ITcVnAccess_TcVnVector4_LREAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector4_LREAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector4_LREAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector4_LREAL, IID_ITcVnRandomAccess_TcVnVector4_LREAL);
#endif // !defined(_TC_TYPE_B9D5D219_707B_4E0F_B558_507B4E8FC9F4_INCLUDED_)

#if !defined(_TC_TYPE_ACD95CBE_4D48_414D_9183_418F0D61EA1C_INCLUDED_)
#define _TC_TYPE_ACD95CBE_4D48_414D_9183_418F0D61EA1C_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector4_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector4_REAL : public ITcVnAccess_TcVnVector4_REAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector4_REAL& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector4_REAL& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector4_REAL, IID_ITcVnRandomAccess_TcVnVector4_REAL);
#endif // !defined(_TC_TYPE_ACD95CBE_4D48_414D_9183_418F0D61EA1C_INCLUDED_)

#if !defined(_TC_TYPE_49999433_E2A7_4601_9B4F_69484DFC00F8_INCLUDED_)
#define _TC_TYPE_49999433_E2A7_4601_9B4F_69484DFC00F8_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector4_SINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector4_SINT : public ITcVnAccess_TcVnVector4_SINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector4_SINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector4_SINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector4_SINT, IID_ITcVnRandomAccess_TcVnVector4_SINT);
#endif // !defined(_TC_TYPE_49999433_E2A7_4601_9B4F_69484DFC00F8_INCLUDED_)

#if !defined(_TC_TYPE_ABF8C5EF_20C8_4BB1_930E_07E4832076B6_INCLUDED_)
#define _TC_TYPE_ABF8C5EF_20C8_4BB1_930E_07E4832076B6_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector4_UINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector4_UINT : public ITcVnAccess_TcVnVector4_UINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector4_UINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector4_UINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector4_UINT, IID_ITcVnRandomAccess_TcVnVector4_UINT);
#endif // !defined(_TC_TYPE_ABF8C5EF_20C8_4BB1_930E_07E4832076B6_INCLUDED_)

#if !defined(_TC_TYPE_385D1F0F_F66A_4AE9_B75C_AA75F69D91A0_INCLUDED_)
#define _TC_TYPE_385D1F0F_F66A_4AE9_B75C_AA75F69D91A0_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnVector4_USINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnVector4_USINT : public ITcVnAccess_TcVnVector4_USINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnVector4_USINT& aVector) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aVector">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnVector4_USINT& aVector) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnVector4_USINT, IID_ITcVnRandomAccess_TcVnVector4_USINT);
#endif // !defined(_TC_TYPE_385D1F0F_F66A_4AE9_B75C_AA75F69D91A0_INCLUDED_)

#if !defined(_TC_TYPE_9D8272BC_0D30_49C5_9E1E_ECD3240BACE5_INCLUDED_)
#define _TC_TYPE_9D8272BC_0D30_49C5_9E1E_ECD3240BACE5_INCLUDED_
/// <summary>
/// Offers a random access interface for UDINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_UDINT : public ITcVnAccess_UDINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, ULONG& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, ULONG nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_UDINT, IID_ITcVnRandomAccess_UDINT);
#endif // !defined(_TC_TYPE_9D8272BC_0D30_49C5_9E1E_ECD3240BACE5_INCLUDED_)

#if !defined(_TC_TYPE_20F37D3F_E3CF_46A1_B395_CC79C1975FB7_INCLUDED_)
#define _TC_TYPE_20F37D3F_E3CF_46A1_B395_CC79C1975FB7_INCLUDED_
/// <summary>
/// Offers a random access interface for UINT values
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_UINT : public ITcVnAccess_UINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, USHORT& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, USHORT nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_UINT, IID_ITcVnRandomAccess_UINT);
#endif // !defined(_TC_TYPE_20F37D3F_E3CF_46A1_B395_CC79C1975FB7_INCLUDED_)

#if !defined(_TC_TYPE_630EC56F_AF3F_4CC1_A585_7B4BD08B6283_INCLUDED_)
#define _TC_TYPE_630EC56F_AF3F_4CC1_A585_7B4BD08B6283_INCLUDED_
/// <summary>
/// Offers a randowm access interface for ULINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_ULINT : public ITcVnAccess_ULINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, ULONGLONG& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, ULONGLONG nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_ULINT, IID_ITcVnRandomAccess_ULINT);
#endif // !defined(_TC_TYPE_630EC56F_AF3F_4CC1_A585_7B4BD08B6283_INCLUDED_)

#if !defined(_TC_TYPE_C8DAFC84_2C0E_4250_8A2D_D18BBBC488B6_INCLUDED_)
#define _TC_TYPE_C8DAFC84_2C0E_4250_8A2D_D18BBBC488B6_INCLUDED_
/// <summary>
/// Offers a random access interface for USINT values
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_USINT : public ITcVnAccess_USINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, unsigned char& nValue) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="nValue">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, unsigned char nValue) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_USINT, IID_ITcVnRandomAccess_USINT);
#endif // !defined(_TC_TYPE_C8DAFC84_2C0E_4250_8A2D_D18BBBC488B6_INCLUDED_)

#if !defined(_TC_TYPE_0E607ACC_A0D9_498A_AB3F_133D124E9AD8_INCLUDED_)
#define _TC_TYPE_0E607ACC_A0D9_498A_AB3F_133D124E9AD8_INCLUDED_
/// <summary>
/// Interface for exporting an image as tiff.
/// </summary>
struct __declspec(novtable) ITcVnTiffExport : public ITcUnknown
{
	/// <summary>
	/// Gets size of the image if it is converted to tiff.
	/// </summary>
	/// <param name="nTiffSize">Output parameter containing the required buffer size.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTiffSize(ULONGLONG& nTiffSize) = 0;
	/// <summary>
	/// Export the image as tiff into a given buffer.
	/// </summary>
	/// <param name="nTiffSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTiffImage(ULONGLONG& nTiffSize, PVOID pDestBuffer) = 0;
};
#endif // !defined(_TC_TYPE_0E607ACC_A0D9_498A_AB3F_133D124E9AD8_INCLUDED_)

#if !defined(_TC_TYPE_DFDCFA99_94EE_4C66_A05E_96CC78FB1641_INCLUDED_)
#define _TC_TYPE_DFDCFA99_94EE_4C66_A05E_96CC78FB1641_INCLUDED_
/// <summary>
/// Interface for sending displayable images as tiff via ADS notifications.
/// </summary>
struct __declspec(novtable) ITcVnTiffExportNotification : public ITcUnknown
{
	/// <summary>
	/// Gets the timestamp of the latest image change.
	/// </summary>
	/// <param name="nTimestamp">Returns the timestamp.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTimestamp(LONGLONG& nTimestamp) = 0;
	/// <summary>
	/// Export the image as tiff into a given buffer by means of an unlocked remote procedure call. It lies within the responsibility of the user to ensure that no conflicting accesses can occur.
	/// </summary>
	/// <param name="nTiffSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTiffImageRpcUnlocked(ULONGLONG& nTiffSize, PVOID pDestBuffer) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnTiffExportNotification, IID_ITcVnTiffExportNotification);
#endif // !defined(_TC_TYPE_DFDCFA99_94EE_4C66_A05E_96CC78FB1641_INCLUDED_)

#if !defined(_TC_TYPE_CFC0CE0B_0521_4D65_85C4_F774CBDD1BC7_INCLUDED_)
#define _TC_TYPE_CFC0CE0B_0521_4D65_85C4_F774CBDD1BC7_INCLUDED_
/// <summary>
/// Interface for exporting an image as tiff by means of an unlocked remote procedure call.
/// </summary>
struct __declspec(novtable) ITcVnTiffExportRpcUnlocked : public ITcVnTiffExport
{
	/// <summary>
	/// Export the image as tiff into a given buffer by means of an unlocked remote procedure call. It lies within the responsibility of the user to ensure that no conflicting accesses can occur.
	/// </summary>
	/// <param name="nTiffSize">Maximum buffer size (in) and actual buffer size (out).</param>
	/// <param name="pDestBuffer">Pointer to the destination buffer.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTiffImageRpcUnlocked(ULONGLONG& nTiffSize, PVOID pDestBuffer) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnTiffExportRpcUnlocked, IID_ITcVnTiffExportRpcUnlocked);
#endif // !defined(_TC_TYPE_CFC0CE0B_0521_4D65_85C4_F774CBDD1BC7_INCLUDED_)

#if !defined(_TC_TYPE_D78C67BA_0E8E_4865_8A1A_3554A6F235D1_INCLUDED_)
#define _TC_TYPE_D78C67BA_0E8E_4865_8A1A_3554A6F235D1_INCLUDED_
/// <summary>
/// Interface for importing a tiff image.
/// </summary>
struct __declspec(novtable) ITcVnTiffImport : public ITcUnknown
{
	/// <summary>
	/// Import a tiff image.
	/// </summary>
	/// <param name="pTiffImage">Pointer to the tiff file.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI ImportTiffImage(PVOID pTiffImage) = 0;
};
#endif // !defined(_TC_TYPE_D78C67BA_0E8E_4865_8A1A_3554A6F235D1_INCLUDED_)

#if !defined(_TC_TYPE_4626F8E2_9080_4F43_8B92_05E22F3DC9FD_INCLUDED_)
#define _TC_TYPE_4626F8E2_9080_4F43_8B92_05E22F3DC9FD_INCLUDED_
/// <summary>
/// Offers an interface for timestamps.
/// </summary>
struct __declspec(novtable) ITcVnTimestamp : public ITcUnknown
{
	/// <summary>
	/// Updates the timestamp to the current time
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI UpdateTimestamp() = 0;
	/// <summary>
	/// Gets the timestamp
	/// </summary>
	/// <param name="nTimestamp">Returns the timestamp</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetTimestamp(LONGLONG& nTimestamp) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnTimestamp, IID_ITcVnTimestamp);
#endif // !defined(_TC_TYPE_4626F8E2_9080_4F43_8B92_05E22F3DC9FD_INCLUDED_)

#if !defined(_TC_TYPE_3642C447_4E03_46B5_B473_41DEC5A58EC3_INCLUDED_)
#define _TC_TYPE_3642C447_4E03_46B5_B473_41DEC5A58EC3_INCLUDED_
/// <summary>
/// Shows information over the GVSP (GigE Vision Streaming Protocol) leader payload image.
/// </summary>
struct GVSP_LEADER_PAYLOAD_IMAGE
{
	ULONGLONG Timestamp; // Image timestamp
	GVSP_PIXEL_FORMAT PixelFormat; // Image pixel format
	ULONG SizeX; // Image size in x direction
	ULONG SizeY; // Image size in y direction
	ULONG OffsetX; // Image x-offset from (0,0) origin
	ULONG OffsetY; // Image y-offset from (0,0) origin
	USHORT PaddingX; // Image padding in x direction
	USHORT PaddingY; // Image padding in y direction
};
#endif // !defined(_TC_TYPE_3642C447_4E03_46B5_B473_41DEC5A58EC3_INCLUDED_)

static_assert(sizeof(GVSP_LEADER_PAYLOAD_IMAGE) == 32);

#if !defined(_TC_TYPE_98043368_D839_44FA_98E2_535171CBA052_INCLUDED_)
#define _TC_TYPE_98043368_D839_44FA_98E2_535171CBA052_INCLUDED_
/// <summary>
/// Shows image information.
/// </summary>
struct VN_TcVnImageInfo
{
	ULONGLONG nImageSize; // Image size (number of pixels)
	ULONG nWidth; // Image width
	ULONG nHeight; // Image height
	USHORT nXPadding; // Image x-padding
	USHORT nYPadding; // Image y-padding
	VN_TcVnPixelFormat stPixelFormat; // Pixel format
};
#endif // !defined(_TC_TYPE_98043368_D839_44FA_98E2_535171CBA052_INCLUDED_)

static_assert(sizeof(VN_TcVnImageInfo) == 32);

#if !defined(_TC_TYPE_E50FD705_3036_4755_A150_E10DADFBCFD9_INCLUDED_)
#define _TC_TYPE_E50FD705_3036_4755_A150_E10DADFBCFD9_INCLUDED_
/// <summary>
/// Contains the x coordinate [0] and the y coordinate [1] of a two-dimensional point.
/// </summary>
typedef VN_TcVnVector2_DINT VN_TcVnPoint2_DINT;
#endif // !defined(_TC_TYPE_E50FD705_3036_4755_A150_E10DADFBCFD9_INCLUDED_)

#if !defined(_TC_TYPE_74AA049A_5C1C_4950_8FB4_1D9BD2CE9B35_INCLUDED_)
#define _TC_TYPE_74AA049A_5C1C_4950_8FB4_1D9BD2CE9B35_INCLUDED_
/// <summary>
/// Contains the x coordinate [0] and the y coordinate [1] of a two-dimensional LREAL point.
/// </summary>
typedef VN_TcVnVector2_LREAL VN_TcVnPoint2_LREAL;
#endif // !defined(_TC_TYPE_74AA049A_5C1C_4950_8FB4_1D9BD2CE9B35_INCLUDED_)

#if !defined(_TC_TYPE_17E60320_5263_4689_829A_FB1F460EE3B0_INCLUDED_)
#define _TC_TYPE_17E60320_5263_4689_829A_FB1F460EE3B0_INCLUDED_
/// <summary>
/// Contains the x coordinate [0] and the y coordinate [1] of a two-dimensional REAL point.
/// </summary>
typedef VN_TcVnVector2_REAL VN_TcVnPoint2_REAL;
#endif // !defined(_TC_TYPE_17E60320_5263_4689_829A_FB1F460EE3B0_INCLUDED_)

#if !defined(_TC_TYPE_F745F7B9_D08E_4608_AAC9_BA4EF137F366_INCLUDED_)
#define _TC_TYPE_F745F7B9_D08E_4608_AAC9_BA4EF137F366_INCLUDED_
/// <summary>
/// Contains the x coordinate [0], the y coordinate [1] and the z coordinate [2] of a three-dimensional LREAL point.
/// </summary>
typedef VN_TcVnVector3_LREAL VN_TcVnPoint3_LREAL;
#endif // !defined(_TC_TYPE_F745F7B9_D08E_4608_AAC9_BA4EF137F366_INCLUDED_)

#if !defined(_TC_TYPE_555F6682_CBB3_4912_9979_999D9BAB868E_INCLUDED_)
#define _TC_TYPE_555F6682_CBB3_4912_9979_999D9BAB868E_INCLUDED_
/// <summary>
/// Contains the x coordinate [0], the y coordinate [1] and the z coordinate [2] of a three-dimensional REAL point.
/// </summary>
typedef VN_TcVnVector3_REAL VN_TcVnPoint3_REAL;
#endif // !defined(_TC_TYPE_555F6682_CBB3_4912_9979_999D9BAB868E_INCLUDED_)

#if !defined(_TC_TYPE_8078DB70_606A_420E_BCE2_7B03232DC132_INCLUDED_)
#define _TC_TYPE_8078DB70_606A_420E_BCE2_7B03232DC132_INCLUDED_
/// <summary>
/// Three-dimensional array of element-type Point2_REAL.
/// </summary>
typedef VN_TcVnPoint2_REAL VN_TcVnArray3_Point2_REAL[3];
#endif // !defined(_TC_TYPE_8078DB70_606A_420E_BCE2_7B03232DC132_INCLUDED_)

#if !defined(_TC_TYPE_6D3DC157_222F_4EDF_A600_2949E5C6FCD3_INCLUDED_)
#define _TC_TYPE_6D3DC157_222F_4EDF_A600_2949E5C6FCD3_INCLUDED_
/// <summary>
/// Four-dimensional array of element-type Point2_REAL.
/// </summary>
typedef VN_TcVnPoint2_REAL VN_TcVnArray4_Point2_REAL[4];
#endif // !defined(_TC_TYPE_6D3DC157_222F_4EDF_A600_2949E5C6FCD3_INCLUDED_)


#if !defined(_TC_TYPE_2A45F794_2ECF_4340_9A69_A3AE84C60C9D_INCLUDED_)
#define _TC_TYPE_2A45F794_2ECF_4340_9A69_A3AE84C60C9D_INCLUDED_
/// <summary>
/// Interface for file image acquisition.
/// </summary>
struct __declspec(novtable) ITcIoFileImageAcquisition : public ITcIoImageAcquisition
{
	/// <summary>
	/// Checks the connection
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckConnection() = 0;
	/// <summary>
	/// Initialize the software trigger and trigger a single image. Skips nSkipImages and triggers the capturing of image nSkipImages+1.
	/// </summary>
	/// <param name="nSkipImages">Number of images to skip</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI TriggerImage(LONG nSkipImages) = 0;
	/// <summary>
	/// Initialize the software trigger and trigger a single image specified by its name in the client assistant.
	/// </summary>
	/// <param name="sImageName">Image name to trigger</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI TriggerImageByName(PCCH sImageName) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcIoFileImageAcquisition, IID_ITcIoFileImageAcquisition);
#endif // !defined(_TC_TYPE_2A45F794_2ECF_4340_9A69_A3AE84C60C9D_INCLUDED_)

#if !defined(_TC_TYPE_63EDCBEF_48BA_40D6_93FE_BB498E230FC7_INCLUDED_)
#define _TC_TYPE_63EDCBEF_48BA_40D6_93FE_BB498E230FC7_INCLUDED_
/// <summary>
/// Interface for a image receiver.
/// </summary>
struct __declspec(novtable) ITcIoFileImageRecv : public ITcIoImageRecv
{
	/// <summary>
	/// Receive an image from an instance of ITcIoFileImageAcquisition.
	/// </summary>
	/// <param name="ipImage">Interface pointer to the image.</param>
	/// <param name="sFileName">Returns the filename to the image.</param>
	/// <param name="hrAcquisitionResult">HRESULT indicating the status of the image acquisition.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI ReceiveImage(ITcVnImageBase* ipImage, PCHAR sFileName, HRESULT hrAcquisitionResult) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcIoFileImageRecv, IID_ITcIoFileImageRecv);
#endif // !defined(_TC_TYPE_63EDCBEF_48BA_40D6_93FE_BB498E230FC7_INCLUDED_)

#if !defined(_TC_TYPE_3CCE1940_FF2A_4594_9FB0_40033A186838_INCLUDED_)
#define _TC_TYPE_3CCE1940_FF2A_4594_9FB0_40033A186838_INCLUDED_
/// <summary>
/// Interface for GigE Vision image acquisition.
/// </summary>
struct __declspec(novtable) ITcIoGevImageAcquisition : public ITcIoImageAcquisition
{
	/// <summary>
	/// Checks the camera connection
	/// </summary>
	/// <param name="eAssumedState">The internally assumed state of the camera.</param>
	/// <param name="eActualState">The actually observable state of the camera.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckConnection(GEV_CAMERA_STATE& eAssumedState, GEV_CAMERA_STATE& eActualState) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcIoGevImageAcquisition, IID_ITcIoGevImageAcquisition);
#endif // !defined(_TC_TYPE_3CCE1940_FF2A_4594_9FB0_40033A186838_INCLUDED_)

#if !defined(_TC_TYPE_BB5FA424_DAEE_4975_8991_89171FB03AFB_INCLUDED_)
#define _TC_TYPE_BB5FA424_DAEE_4975_8991_89171FB03AFB_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnPoint2_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnPoint2_DINT : public ITcUnknown
{
	/// <summary>
	/// Gets the value.
	/// </summary>
	/// <param name="aPoint">Returns the value.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnPoint2_DINT& aPoint) = 0;
	/// <summary>
	/// Sets the value.
	/// </summary>
	/// <param name="aPoint">The value to set.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnPoint2_DINT& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnPoint2_DINT, IID_ITcVnAccess_TcVnPoint2_DINT);
#endif // !defined(_TC_TYPE_BB5FA424_DAEE_4975_8991_89171FB03AFB_INCLUDED_)

#if !defined(_TC_TYPE_3381410F_F244_4B92_98CA_720F421FFA9C_INCLUDED_)
#define _TC_TYPE_3381410F_F244_4B92_98CA_720F421FFA9C_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnPoint2_LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnPoint2_LREAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnPoint2_LREAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnPoint2_LREAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnPoint2_LREAL, IID_ITcVnAccess_TcVnPoint2_LREAL);
#endif // !defined(_TC_TYPE_3381410F_F244_4B92_98CA_720F421FFA9C_INCLUDED_)

#if !defined(_TC_TYPE_F1235D2C_E536_4B4D_9AA5_79B069D44B6A_INCLUDED_)
#define _TC_TYPE_F1235D2C_E536_4B4D_9AA5_79B069D44B6A_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnPoint2_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnPoint2_REAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnPoint2_REAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnPoint2_REAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnPoint2_REAL, IID_ITcVnAccess_TcVnPoint2_REAL);
#endif // !defined(_TC_TYPE_F1235D2C_E536_4B4D_9AA5_79B069D44B6A_INCLUDED_)

#if !defined(_TC_TYPE_885CF0CB_8571_4517_A3AC_44A9B734D71D_INCLUDED_)
#define _TC_TYPE_885CF0CB_8571_4517_A3AC_44A9B734D71D_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnPoint3_LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnPoint3_LREAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnPoint3_LREAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnPoint3_LREAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnPoint3_LREAL, IID_ITcVnAccess_TcVnPoint3_LREAL);
#endif // !defined(_TC_TYPE_885CF0CB_8571_4517_A3AC_44A9B734D71D_INCLUDED_)

#if !defined(_TC_TYPE_9C920E2C_99F0_4681_B240_F6937115D395_INCLUDED_)
#define _TC_TYPE_9C920E2C_99F0_4681_B240_F6937115D395_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnPoint3_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnPoint3_REAL : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnPoint3_REAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnPoint3_REAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnPoint3_REAL, IID_ITcVnAccess_TcVnPoint3_REAL);
#endif // !defined(_TC_TYPE_9C920E2C_99F0_4681_B240_F6937115D395_INCLUDED_)

#if !defined(_TC_TYPE_F5435722_337D_4786_87F5_6DEC5A1CAED5_INCLUDED_)
#define _TC_TYPE_F5435722_337D_4786_87F5_6DEC5A1CAED5_INCLUDED_
/// <summary>
/// Interface for an image provider for images from outside realtime environment.
/// </summary>
struct __declspec(novtable) ITcVnFileImageProvider : public ITcVnImageProvider
{
	/// <summary>
	/// Get the current image by detaching its internal reference.
	/// </summary>
	/// <param name="pipImage">pointer to the interface pointer to be returned, might be 0 if the image acquisition failed</param>
	/// <param name="sFileName">returns the filename as a string</param>
	/// <param name="nMaxLen">maximum string length allowed to be written in sFileName</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetCurrentImageAndFileName(ITcVnImage** pipImage, PCHAR sFileName, USHORT nMaxLen) = 0;
	/// <summary>
	/// Initialize the software trigger and trigger a single image. Skips nSkipImages and triggers the capturing of image nSkipImages+1.
	/// </summary>
	/// <param name="nSkipImages">Number of images to skip</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI TriggerImage(LONG nSkipImages) = 0;
	/// <summary>
	/// Initialize the software trigger and trigger a single image specified by its name in the client assistant.
	/// </summary>
	/// <param name="sImageName">Image name to trigger</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI TriggerImageByName(PCCH sImageName) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnFileImageProvider, IID_ITcVnFileImageProvider);
#endif // !defined(_TC_TYPE_F5435722_337D_4786_87F5_6DEC5A1CAED5_INCLUDED_)

#if !defined(_TC_TYPE_010A82ED_513F_4803_A63A_D4E4A54C2603_INCLUDED_)
#define _TC_TYPE_010A82ED_513F_4803_A63A_D4E4A54C2603_INCLUDED_
/// <summary>
/// Offers an interface for a forward iterator.
/// </summary>
struct __declspec(novtable) ITcVnForwardIterator : public ITcVnIteratorBase
{
	/// <summary>
	/// Checks if iterator is equal to another iterator.
	/// </summary>
	/// <param name="ipIterator">Iterator interface to compare with</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfEqualTo(ITcVnForwardIterator* ipIterator) = 0;
	/// <summary>
	/// Gets a pointer to the current element converted into an ITcVnContainer interface and increment its reference counter (only possible for container types). (Alternatively use F_VN_GetContainer.)
	/// </summary>
	/// <param name="pipContainer">Returns the container interface.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetContainer(ITcVnContainer** pipContainer) = 0;
	/// <summary>
	/// Increments the iterator. (Alternatively use F_VN_IncrementIterator.)
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Increment() = 0;
	/// <summary>
	/// Sets the current element using an ITcVnContainer interface (only possible for container types). (Alternatively use F_VN_SetContainer.)
	/// </summary>
	/// <param name="ipContainer">Container interface of which the content is to be assigned to the current element.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetContainer(ITcVnContainer* ipContainer) = 0;
};
#endif // !defined(_TC_TYPE_010A82ED_513F_4803_A63A_D4E4A54C2603_INCLUDED_)

#if !defined(_TC_TYPE_A78D28D9_F618_4D35_8FB8_162CE7C7F8EB_INCLUDED_)
#define _TC_TYPE_A78D28D9_F618_4D35_8FB8_162CE7C7F8EB_INCLUDED_
/// <summary>
/// Base interface for all image types.
/// </summary>
struct __declspec(novtable) ITcVnImageBase : public ITcUnknown
{
	/// <summary>
	/// Gets the data interface (Do not explicitly free the pointer in there!).
	/// </summary>
	/// <param name="pipImageData">Returns a pointer to the image data interface.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetImageData(ITcVnData** pipImageData) = 0;
	/// <summary>
	/// Gets the image size.
	/// </summary>
	/// <param name="nSize">Returns the image size in bytes.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetImageSize(ULONGLONG& nSize) = 0;
	/// <summary>
	/// Gets the image width (alternatively use F_VN_GetImageWidth).
	/// </summary>
	/// <param name="nWidth">Returns the image width in pixels.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetWidth(ULONG& nWidth) = 0;
	/// <summary>
	/// Gets the image height (alternatively use F_VN_GetImageHeight).
	/// </summary>
	/// <param name="nHeight">Returns the image height in pixels.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetHeight(ULONG& nHeight) = 0;
	/// <summary>
	/// Gets the horizontal padding.
	/// </summary>
	/// <param name="nXPadding">Returns the horizontal padding in bytes.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetXPadding(USHORT& nXPadding) = 0;
	/// <summary>
	/// Gets the vertical padding.
	/// </summary>
	/// <param name="nYPadding">Returns the vertical padding in bytes.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetYPadding(USHORT& nYPadding) = 0;
	/// <summary>
	/// Gets the pixel format (alternatively use F_VN_GetPixelFormat).
	/// </summary>
	/// <param name="stPixelFormat">Returns a struct describing the pixel format.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetPixelFormat(VN_TcVnPixelFormat& stPixelFormat) = 0;
	/// <summary>
	/// Gets a struct containing all common meta infos of the image. This basically encompasses all meta information accessible via this interface. (Alternatively use F_VN_GetImageInfo.)
	/// </summary>
	/// <param name="stImageInfo">Returns a struct describing the image.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetImageInfo(VN_TcVnImageInfo& stImageInfo) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnImageBase, IID_ITcVnImageBase);
#endif // !defined(_TC_TYPE_A78D28D9_F618_4D35_8FB8_162CE7C7F8EB_INCLUDED_)

#if !defined(_TC_TYPE_35459277_9BFC_4D31_8F9F_A262236E77A8_INCLUDED_)
#define _TC_TYPE_35459277_9BFC_4D31_8F9F_A262236E77A8_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnPoint2_DINT values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnPoint2_DINT : public ITcVnAccess_TcVnPoint2_DINT
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnPoint2_DINT& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnPoint2_DINT& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnPoint2_DINT, IID_ITcVnRandomAccess_TcVnPoint2_DINT);
#endif // !defined(_TC_TYPE_35459277_9BFC_4D31_8F9F_A262236E77A8_INCLUDED_)

#if !defined(_TC_TYPE_B747E227_43B1_4507_96A4_00549458BA01_INCLUDED_)
#define _TC_TYPE_B747E227_43B1_4507_96A4_00549458BA01_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnPoint2_LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnPoint2_LREAL : public ITcVnAccess_TcVnPoint2_LREAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnPoint2_LREAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnPoint2_LREAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnPoint2_LREAL, IID_ITcVnRandomAccess_TcVnPoint2_LREAL);
#endif // !defined(_TC_TYPE_B747E227_43B1_4507_96A4_00549458BA01_INCLUDED_)

#if !defined(_TC_TYPE_37607F12_4FDB_4BDD_8787_E9459AC5C8BB_INCLUDED_)
#define _TC_TYPE_37607F12_4FDB_4BDD_8787_E9459AC5C8BB_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnPoint2_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnPoint2_REAL : public ITcVnAccess_TcVnPoint2_REAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnPoint2_REAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnPoint2_REAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnPoint2_REAL, IID_ITcVnRandomAccess_TcVnPoint2_REAL);
#endif // !defined(_TC_TYPE_37607F12_4FDB_4BDD_8787_E9459AC5C8BB_INCLUDED_)

#if !defined(_TC_TYPE_1B779EE3_6D76_4AC3_AF52_ADF574DE3771_INCLUDED_)
#define _TC_TYPE_1B779EE3_6D76_4AC3_AF52_ADF574DE3771_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnPoint3_LREAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnPoint3_LREAL : public ITcVnAccess_TcVnPoint3_LREAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnPoint3_LREAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnPoint3_LREAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnPoint3_LREAL, IID_ITcVnRandomAccess_TcVnPoint3_LREAL);
#endif // !defined(_TC_TYPE_1B779EE3_6D76_4AC3_AF52_ADF574DE3771_INCLUDED_)

#if !defined(_TC_TYPE_17437ED0_DC3E_48AE_9278_4FF188DD5B9E_INCLUDED_)
#define _TC_TYPE_17437ED0_DC3E_48AE_9278_4FF188DD5B9E_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnPoint3_REAL values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnPoint3_REAL : public ITcVnAccess_TcVnPoint3_REAL
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnPoint3_REAL& aPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="aPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnPoint3_REAL& aPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnPoint3_REAL, IID_ITcVnRandomAccess_TcVnPoint3_REAL);
#endif // !defined(_TC_TYPE_17437ED0_DC3E_48AE_9278_4FF188DD5B9E_INCLUDED_)

#if !defined(_TC_TYPE_63FC7E33_91CD_44CD_9015_0BD1DC25722C_INCLUDED_)
#define _TC_TYPE_63FC7E33_91CD_44CD_9015_0BD1DC25722C_INCLUDED_
/// <summary>
/// Shows GVSP (GigE Vision Streaming Protocol) meta information.
/// </summary>
struct GVSP_IMAGE_INFO
{
	ULONG CameraIpAddress; // Camera IP address
	ULONG LocalIpAddress; // Local IP address
	USHORT CameraUdpPort; // Camera UDP port
	USHORT LocalUdpPort; // Local UDP port
	USHORT GvspChannelId; // ID of GVSP channel
	USHORT GevStatus; // GigE Vision status code
	ULONGLONG BlockId; // Block Id (incremented for each acquired image, but reset to 0 on overflow)
	GVSP_LEADER_PAYLOAD_IMAGE LeaderInfo; // Contains information about timestamp, pixel format and size.
};
#endif // !defined(_TC_TYPE_63FC7E33_91CD_44CD_9015_0BD1DC25722C_INCLUDED_)

static_assert(sizeof(GVSP_IMAGE_INFO) == 56);

#if !defined(_TC_TYPE_8BE37FD1_756B_41AC_82C3_0A9056B24DEB_INCLUDED_)
#define _TC_TYPE_8BE37FD1_756B_41AC_82C3_0A9056B24DEB_INCLUDED_
/// <summary>
/// Describes a circular arc.
/// </summary>
struct VN_TcVnCircularArc
{
	VN_TcVnPoint2_REAL aCenter; // Center of the circular arc
	float fRadius; // Radius of the circular arc
	float fStartAngle; // Start angle of the circular arc
	float fEndAngle; // End angle of the circular arc
};
#endif // !defined(_TC_TYPE_8BE37FD1_756B_41AC_82C3_0A9056B24DEB_INCLUDED_)

static_assert(sizeof(VN_TcVnCircularArc) == 20);

#if !defined(_TC_TYPE_D339BE98_56F1_46CD_BB69_5C190E97C36D_INCLUDED_)
#define _TC_TYPE_D339BE98_56F1_46CD_BB69_5C190E97C36D_INCLUDED_
/// <summary>
/// Describes a key point.
/// </summary>
struct VN_TcVnKeyPoint
{
	VN_TcVnPoint2_REAL aPoint; // Position
	float fDiameter; // Diameter
	float fAngle; // Angle
	float fResponse; // Response
	LONG nOctave; // Octave
	LONG nClassId; // Class ID
};
#endif // !defined(_TC_TYPE_D339BE98_56F1_46CD_BB69_5C190E97C36D_INCLUDED_)

static_assert(sizeof(VN_TcVnKeyPoint) == 28);

#if !defined(_TC_TYPE_2008297D_E604_46B4_BCB7_F4F069E43B42_INCLUDED_)
#define _TC_TYPE_2008297D_E604_46B4_BCB7_F4F069E43B42_INCLUDED_
/// <summary>
/// Contains center, size and angle of a rotated rectangle.
/// </summary>
struct VN_TcVnRotatedRectangle
{
	VN_TcVnPoint2_REAL aCenter; // Center point
	VN_TcVnSize2_REAL stSize; // Size composed of fWidth and fHeight
	float fAngle; // Angle in degree
};
#endif // !defined(_TC_TYPE_2008297D_E604_46B4_BCB7_F4F069E43B42_INCLUDED_)

static_assert(sizeof(VN_TcVnRotatedRectangle) == 20);

#if !defined(_TC_TYPE_04E69B91_FF97_4F1C_AC92_B4BF0E54FA59_INCLUDED_)
#define _TC_TYPE_04E69B91_FF97_4F1C_AC92_B4BF0E54FA59_INCLUDED_
/// <summary>
/// Contains the x coordinate [0] and the y coordinate [1] of a two-dimensional point.
/// </summary>
typedef VN_TcVnPoint2_DINT VN_TcVnPoint;
#endif // !defined(_TC_TYPE_04E69B91_FF97_4F1C_AC92_B4BF0E54FA59_INCLUDED_)

#if !defined(_TC_TYPE_238E9E96_5AEF_4E8B_9052_C371A8C7BBED_INCLUDED_)
#define _TC_TYPE_238E9E96_5AEF_4E8B_9052_C371A8C7BBED_INCLUDED_
/// <summary>
/// Interface for GigE Vision images.
/// </summary>
struct __declspec(novtable) ITcIoGevImage : public ITcVnImageBase
{
	/// <summary>
	/// Check if image data is a copy.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfCopy() = 0;
	/// <summary>
	/// Sets image height to newHeight if it is smaller than the current value.
	/// </summary>
	/// <param name="nNewHeight">Height value to set.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI DecreaseHeight(ULONG nNewHeight) = 0;
	/// <summary>
	/// Gets the GVSP block ID.
	/// </summary>
	/// <param name="nBlockId">Returns the block ID.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetBlockId(ULONGLONG& nBlockId) = 0;
	/// <summary>
	/// Gets the block status.
	/// </summary>
	/// <param name="nGevStatus">Returns the GigE Vision status code.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetGevStatus(USHORT& nGevStatus) = 0;
	/// <summary>
	/// Gets a pointer to the GVSP leader payload.
	/// </summary>
	/// <param name="ppGvspImageInfo">Pointer to the GVSP meta information.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetGvspImageInfo(GVSP_IMAGE_INFO** ppGvspImageInfo) = 0;
	/// <summary>
	/// Sets the block status.
	/// </summary>
	/// <param name="nGevStatus">GigE Vision status code.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetGevStatus(USHORT nGevStatus) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcIoGevImage, IID_ITcIoGevImage);
#endif // !defined(_TC_TYPE_238E9E96_5AEF_4E8B_9052_C371A8C7BBED_INCLUDED_)

#if !defined(_TC_TYPE_69643CDD_657E_4B26_8CED_A86941BB515F_INCLUDED_)
#define _TC_TYPE_69643CDD_657E_4B26_8CED_A86941BB515F_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnKeyPoint values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnKeyPoint : public ITcUnknown
{
	/// <summary>
	/// Gets the value.
	/// </summary>
	/// <param name="stKeyPoint">Returns the value.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnKeyPoint& stKeyPoint) = 0;
	/// <summary>
	/// Sets the value.
	/// </summary>
	/// <param name="stKeyPoint">The value to set.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnKeyPoint& stKeyPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnKeyPoint, IID_ITcVnAccess_TcVnKeyPoint);
#endif // !defined(_TC_TYPE_69643CDD_657E_4B26_8CED_A86941BB515F_INCLUDED_)

#if !defined(_TC_TYPE_BF344472_E777_4038_B2AD_DA8886316120_INCLUDED_)
#define _TC_TYPE_BF344472_E777_4038_B2AD_DA8886316120_INCLUDED_
/// <summary>
/// Offers an access interface for TcVnRotatedRectangle values.
/// </summary>
struct __declspec(novtable) ITcVnAccess_TcVnRotatedRectangle : public ITcUnknown
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="stRectangle">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Get(VN_TcVnRotatedRectangle& stRectangle) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="stRectangle">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Set(VN_TcVnRotatedRectangle& stRectangle) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnAccess_TcVnRotatedRectangle, IID_ITcVnAccess_TcVnRotatedRectangle);
#endif // !defined(_TC_TYPE_BF344472_E777_4038_B2AD_DA8886316120_INCLUDED_)

#if !defined(_TC_TYPE_F6C9D79D_2E9C_40FA_9865_3D23FAC6860C_INCLUDED_)
#define _TC_TYPE_F6C9D79D_2E9C_40FA_9865_3D23FAC6860C_INCLUDED_
/// <summary>
/// Offers an interface for a bidirectional iterator.
/// </summary>
struct __declspec(novtable) ITcVnBidirectionalIterator : public ITcVnForwardIterator
{
	/// <summary>
	/// Decrements the iterator.
	/// </summary>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Decrement() = 0;
};
#endif // !defined(_TC_TYPE_F6C9D79D_2E9C_40FA_9865_3D23FAC6860C_INCLUDED_)

#if !defined(_TC_TYPE_ED7659DB_95DC_4A4A_B62F_02C9870D5E81_INCLUDED_)
#define _TC_TYPE_ED7659DB_95DC_4A4A_B62F_02C9870D5E81_INCLUDED_
/// <summary>
/// Interface for a GigE Vision image provider.
/// </summary>
struct __declspec(novtable) ITcVnGevImageProvider : public ITcVnImageProvider
{
	/// <summary>
	/// Gets the current GigE Vision image by detaching its internal reference.
	/// </summary>
	/// <param name="pipGevImage">Pointer to the interface pointer to be returned, might be 0 if the image acquisition failed.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetCurrentGevImage(ITcIoGevImage** pipGevImage) = 0;
	/// <summary>
	/// Gets the current image by detaching its internal reference and additionally provide the GVSP info.
	/// </summary>
	/// <param name="pipImage">Pointer to the interface pointer to be returned, might be 0 if the image acquisition failed.</param>
	/// <param name="stGvspInfo">Contains useful meta information like image id, time stamp etc.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetCurrentImageWithGvspInfo(ITcVnImage** pipImage, GVSP_IMAGE_INFO& stGvspInfo) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnGevImageProvider, IID_ITcVnGevImageProvider);
#endif // !defined(_TC_TYPE_ED7659DB_95DC_4A4A_B62F_02C9870D5E81_INCLUDED_)

#if !defined(_TC_TYPE_70D42C6D_6F4E_4719_8B29_2883D5D59B1C_INCLUDED_)
#define _TC_TYPE_70D42C6D_6F4E_4719_8B29_2883D5D59B1C_INCLUDED_
/// <summary>
/// Basic interface for images.
/// </summary>
struct __declspec(novtable) ITcVnImage : public ITcVnImageBase
{
	/// <summary>
	/// Initialize an image with an ITcVnImageBase interface.
	/// </summary>
	/// <param name="ipImageBase">Image from which to obtain the data.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI Init(ITcVnImageBase* ipImageBase) = 0;
	/// <summary>
	/// Gets a pointer to a specific row of an image.
	/// </summary>
	/// <param name="nRowIndex">Row index.</param>
	/// <param name="ppRow">Returns a pointer to the requested image row.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetRowPointer(ULONG nRowIndex, PVOID* ppRow) = 0;
	/// <summary>
	/// Release the pointer to a specific row of an image.
	/// </summary>
	/// <param name="ppRow">Pointer to the row pointer to be released.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI ReleaseRowPointer(PVOID* ppRow) = 0;
};
#endif // !defined(_TC_TYPE_70D42C6D_6F4E_4719_8B29_2883D5D59B1C_INCLUDED_)

#if !defined(_TC_TYPE_B06B4E6D_10F5_4A04_97EB_C84DCB383D87_INCLUDED_)
#define _TC_TYPE_B06B4E6D_10F5_4A04_97EB_C84DCB383D87_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnKeyPoint values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnKeyPoint : public ITcVnAccess_TcVnKeyPoint
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="stKeyPoint">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnKeyPoint& stKeyPoint) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="stKeyPoint">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnKeyPoint& stKeyPoint) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnKeyPoint, IID_ITcVnRandomAccess_TcVnKeyPoint);
#endif // !defined(_TC_TYPE_B06B4E6D_10F5_4A04_97EB_C84DCB383D87_INCLUDED_)

#if !defined(_TC_TYPE_404084DA_7276_4843_9D19_8A1EDEEFF891_INCLUDED_)
#define _TC_TYPE_404084DA_7276_4843_9D19_8A1EDEEFF891_INCLUDED_
/// <summary>
/// Offers a random access interface for TcVnRotatedRectangle values.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccess_TcVnRotatedRectangle : public ITcVnAccess_TcVnRotatedRectangle
{
	/// <summary>
	/// Gets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="stRectangle">Returns the value</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetAt(LONGLONG nOffset, VN_TcVnRotatedRectangle& stRectangle) = 0;
	/// <summary>
	/// Sets the value
	/// </summary>
	/// <param name="nOffset">Offset to the current position</param>
	/// <param name="stRectangle">The value to set</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetAt(LONGLONG nOffset, VN_TcVnRotatedRectangle& stRectangle) = 0;
};
_TCOM_SMARTPTR_TYPEDEF(ITcVnRandomAccess_TcVnRotatedRectangle, IID_ITcVnRandomAccess_TcVnRotatedRectangle);
#endif // !defined(_TC_TYPE_404084DA_7276_4843_9D19_8A1EDEEFF891_INCLUDED_)

#if !defined(_TC_TYPE_BCAC943A_527D_4A55_B4CD_386DBFF328B8_INCLUDED_)
#define _TC_TYPE_BCAC943A_527D_4A55_B4CD_386DBFF328B8_INCLUDED_
/// <summary>
/// Offers an interface for a random access iterator.
/// </summary>
struct __declspec(novtable) ITcVnRandomAccessIterator : public ITcVnBidirectionalIterator
{
	/// <summary>
	/// Checks if the iterator is greater than another iterator.
	/// </summary>
	/// <param name="ipIterator">Iterator interface to compare with.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfGreaterThan(ITcVnRandomAccessIterator* ipIterator) = 0;
	/// <summary>
	/// Checks if the iterator is less than another iterator.
	/// </summary>
	/// <param name="ipIterator">Iterator interface to compare with.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI CheckIfLessThan(ITcVnRandomAccessIterator* ipIterator) = 0;
	/// <summary>
	/// Gets a pointer to the element at a specific offset from the current element converted into an ITcVnContainer interface and increment its reference counter (only possible for container types). (Alternatively use F_VN_GetAt_ITcVnContainer.)
	/// </summary>
	/// <param name="nOffset">Offset from the current element.</param>
	/// <param name="pipContainer">Returns the pointer to the container interface.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI GetContainerAt(LONGLONG nOffset, ITcVnContainer** pipContainer) = 0;
	/// <summary>
	/// Sets the element at a specific offset from the current element using an ITcVnContainer interface (only possible for container types). (Alternatively use F_VN_SetAt_ITcVnContainer.)
	/// </summary>
	/// <param name="nOffset">Offset from the current element.</param>
	/// <param name="ipContainer">Container interface of which the content is to be assigned to the current element.</param>
	/// <returns>HRESULT</returns>
	virtual HRESULT TCOMAPI SetContainerAt(LONGLONG nOffset, ITcVnContainer* ipContainer) = 0;
};
#endif // !defined(_TC_TYPE_BCAC943A_527D_4A55_B4CD_386DBFF328B8_INCLUDED_)

namespace Tc3_Vision
{
	constexpr int Lic0FuncsTotal = 715;
	constexpr int Lic0FuncsOffs = 0;
	#ifdef LIC_TC3_Vision_Base
		constexpr int Lic0Funcs = 715;
	#else
		constexpr int Lic0Funcs = 0;
	#endif

	constexpr int Lic0FBsTotal = 22;
	constexpr int Lic0FBsOffs = 0;
	#ifdef LIC_TC3_Vision_Base
		constexpr int Lic0FBs = 22;
	#else
		constexpr int Lic0FBs = 0;
	#endif

	constexpr int Lic1FuncsTotal = 7;
	constexpr int Lic1FuncsOffs = Lic0FuncsOffs + Lic0FuncsTotal - Lic0Funcs;
	#ifdef LIC_TC3_Vision_Code_Reading
		constexpr int Lic1Funcs = 7;
	#else
		constexpr int Lic1Funcs = 0;
	#endif

	constexpr int Lic1FBsTotal = 0;
	constexpr int Lic1FBsOffs = Lic0FBsOffs + Lic0FBsTotal - Lic0FBs;
	#ifdef LIC_TC3_Vision_Code_Reading
		constexpr int Lic1FBs = 0;
	#else
		constexpr int Lic1FBs = 0;
	#endif

	constexpr int Lic2FuncsTotal = 3;
	constexpr int Lic2FuncsOffs = Lic1FuncsOffs + Lic1FuncsTotal - Lic1Funcs;
	#ifdef LIC_TC3_Vision_Code_Quality
		constexpr int Lic2Funcs = 3;
	#else
		constexpr int Lic2Funcs = 0;
	#endif

	constexpr int Lic2FBsTotal = 0;
	constexpr int Lic2FBsOffs = Lic1FBsOffs + Lic1FBsTotal - Lic1FBs;
	#ifdef LIC_TC3_Vision_Code_Quality
		constexpr int Lic2FBs = 0;
	#else
		constexpr int Lic2FBs = 0;
	#endif

	constexpr int Lic3FuncsTotal = 28;
	constexpr int Lic3FuncsOffs = Lic2FuncsOffs + Lic2FuncsTotal - Lic2Funcs;
	#ifdef LIC_TC3_Vision_Metrology_2D
		constexpr int Lic3Funcs = 28;
	#else
		constexpr int Lic3Funcs = 0;
	#endif

	constexpr int Lic3FBsTotal = 0;
	constexpr int Lic3FBsOffs = Lic2FBsOffs + Lic2FBsTotal - Lic2FBs;
	#ifdef LIC_TC3_Vision_Metrology_2D
		constexpr int Lic3FBs = 0;
	#else
		constexpr int Lic3FBs = 0;
	#endif

	constexpr int Lic4FuncsTotal = 27;
	constexpr int Lic4FuncsOffs = Lic3FuncsOffs + Lic3FuncsTotal - Lic3Funcs;
	#ifdef LIC_TC3_Vision_Matching
		constexpr int Lic4Funcs = 27;
	#else
		constexpr int Lic4Funcs = 0;
	#endif

	constexpr int Lic4FBsTotal = 2;
	constexpr int Lic4FBsOffs = Lic3FBsOffs + Lic3FBsTotal - Lic3FBs;
	#ifdef LIC_TC3_Vision_Matching
		constexpr int Lic4FBs = 2;
	#else
		constexpr int Lic4FBs = 0;
	#endif

	constexpr int Lic5FuncsTotal = 1;
	constexpr int Lic5FuncsOffs = Lic4FuncsOffs + Lic4FuncsTotal - Lic4Funcs;
	#ifdef LIC_TC3_Vision_OCR
		constexpr int Lic5Funcs = 1;
	#else
		constexpr int Lic5Funcs = 0;
	#endif

	constexpr int Lic5FBsTotal = 0;
	constexpr int Lic5FBsOffs = Lic4FBsOffs + Lic4FBsTotal - Lic4FBs;
	#ifdef LIC_TC3_Vision_OCR
		constexpr int Lic5FBs = 0;
	#else
		constexpr int Lic5FBs = 0;
	#endif

	constexpr int Lic6FuncsTotal = 39;
	constexpr int Lic6FuncsOffs = Lic5FuncsOffs + Lic5FuncsTotal - Lic5Funcs;
	#ifdef LIC_TC3_Machine_Learning_Realtime_Inference
		constexpr int Lic6Funcs = 39;
	#else
		constexpr int Lic6Funcs = 0;
	#endif

	constexpr int Lic6FBsTotal = 0;
	constexpr int Lic6FBsOffs = Lic5FBsOffs + Lic5FBsTotal - Lic5FBs;
	#ifdef LIC_TC3_Machine_Learning_Realtime_Inference
		constexpr int Lic6FBs = 0;
	#else
		constexpr int Lic6FBs = 0;
	#endif

	constexpr int Lic7FuncsTotal = 11;
	constexpr int Lic7FuncsOffs = Lic6FuncsOffs + Lic6FuncsTotal - Lic6Funcs;
	#ifdef LIC_TC3_Neural_Network_Realtime_Inference
		constexpr int Lic7Funcs = 11;
	#else
		constexpr int Lic7Funcs = 0;
	#endif

	constexpr int Lic7FBsTotal = 0;
	constexpr int Lic7FBsOffs = Lic6FBsOffs + Lic6FBsTotal - Lic6FBs;
	#ifdef LIC_TC3_Neural_Network_Realtime_Inference
		constexpr int Lic7FBs = 0;
	#else
		constexpr int Lic7FBs = 0;
	#endif

	constexpr int TotalFuncs = Lic0Funcs + Lic1Funcs + Lic2Funcs + Lic3Funcs + Lic4Funcs + Lic5Funcs + Lic6Funcs + Lic7Funcs;
	constexpr int TotalFBs = Lic0FBs + Lic1FBs + Lic2FBs + Lic3FBs + Lic4FBs + Lic5FBs + Lic6FBs + Lic7FBs;

	template<typename _Ty>inline void AssignTo(_Ty& dest, const _Ty& src) { dest = src; }

	#define TCVN_ERROR TC_SEH_ERROR
	#define TCVN_CONDITIONAL_ERROR TC_SEH_CONDITIONAL_ERROR
	#define TCVN_ASSERT(bCondition) TC_SEH_ASSERT(bCondition, FACILITY_TC_VN)
	
	#define TC3_VISION_ACCESS_INTERFACE_PREFIX ITcVnAccess_
	#define TC3_VISION_RANDOM_ACCESS_INTERFACE_PREFIX ITcVnRandomAccess_
	
	#define TC3_VISION_QUOTE(ARG) #ARG
	#define TC3_VISION_CONCATENATE_AS_STRING_HELPER(ARG1, ARG2) TC3_VISION_QUOTE(ARG1 ## ARG2)
	#define TC3_VISION_CONCATENATE_AS_STRING(ARG1, ARG2) TC3_VISION_CONCATENATE_AS_STRING_HELPER(ARG1, ARG2)
	#define TC3_VISION_CONCATENATE_HELPER(ARG1, ARG2) ARG1 ## ARG2
	#define TC3_VISION_CONCATENATE(ARG1, ARG2) TC3_VISION_CONCATENATE_HELPER(ARG1, ARG2)
	#define TC3_VISION_CONCATENATE_HELPER3(ARG1, ARG2, ARG3) ARG1 ## ARG2 ## ARG3
	#define TC3_VISION_CONCATENATE3(ARG1, ARG2, ARG3) TC3_VISION_CONCATENATE_HELPER3(ARG1, ARG2, ARG3)
	
	#define TC3_VISION_DEFINE_ACCESS_INTERFACE(ElementType, ElementTypeSuffix) \
		template<>struct Tc3_VisionElementAccessTraits<ElementType> \
		{ \
			typedef TC3_VISION_CONCATENATE(TC3_VISION_ACCESS_INTERFACE_PREFIX, ElementTypeSuffix) access_interface_type; \
			typedef TC3_VISION_CONCATENATE(TC3_VISION_RANDOM_ACCESS_INTERFACE_PREFIX, ElementTypeSuffix) random_access_interface_type; \
		}; 
	
	#define TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(ELEMENT_TYPE, NUM, TEMPLATE_ENUM, WRAPPER_TYPE) \
		template<>struct Tc3_VisionArrayWrapperTraits<ELEMENT_TYPE, NUM, TEMPLATE_ENUM> { using array_type = ::TC3_VISION_CONCATENATE(VN_, WRAPPER_TYPE); };
	
	#define TC3_VISION_DEFINE_ARRAY_WRAPPER(ELEMENT_TYPE, NUM, TEMPLATE_ENUM, WRAPPER_TYPE) \
		using WRAPPER_TYPE = Internal::Tc3_VisionArrayWrapper<ELEMENT_TYPE, NUM, Internal::TEMPLATE_ENUM>;
	
	#ifndef TCVN_TYPETRAITS_NAMESPACE
		#define TCVN_TYPETRAITS_NAMESPACE std
	#endif
	
	///////////////////////////////////////////////////////////////////////////////
	// DataTypes and Operators
	///////////////////////////////////////////////////////////////////////////////
	
	namespace Internal
	{
		enum ETc3_VisionWrapperType { Tc3_VisionPoint, Tc3_VisionVector };
	
		template<typename _ty, size_t nNum, ETc3_VisionWrapperType eType>struct Tc3_VisionArrayWrapperTraits {};
	
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(LONG, 2, Tc3_VisionPoint, TcVnPoint2_DINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(double, 2, Tc3_VisionPoint, TcVnPoint2_LREAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(float, 2, Tc3_VisionPoint, TcVnPoint2_REAL)
	
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(double, 3, Tc3_VisionPoint, TcVnPoint3_LREAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(float, 3, Tc3_VisionPoint, TcVnPoint3_REAL)
	
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(LONG, 2, Tc3_VisionVector, TcVnVector2_DINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(short, 2, Tc3_VisionVector, TcVnVector2_INT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(double, 2, Tc3_VisionVector, TcVnVector2_LREAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(float, 2, Tc3_VisionVector, TcVnVector2_REAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(char, 2, Tc3_VisionVector, TcVnVector2_SINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(USHORT, 2, Tc3_VisionVector, TcVnVector2_UINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(UCHAR, 2, Tc3_VisionVector, TcVnVector2_USINT)
	
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(short, 3, Tc3_VisionVector, TcVnVector3_INT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(double, 3, Tc3_VisionVector, TcVnVector3_LREAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(float, 3, Tc3_VisionVector, TcVnVector3_REAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(char, 3, Tc3_VisionVector, TcVnVector3_SINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(USHORT, 3, Tc3_VisionVector, TcVnVector3_UINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(UCHAR, 3, Tc3_VisionVector, TcVnVector3_USINT)
	
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(short, 4, Tc3_VisionVector, TcVnVector4_INT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(LONG, 4, Tc3_VisionVector, TcVnVector4_DINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(double, 4, Tc3_VisionVector, TcVnVector4_LREAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(float, 4, Tc3_VisionVector, TcVnVector4_REAL)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(char, 4, Tc3_VisionVector, TcVnVector4_SINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(USHORT, 4, Tc3_VisionVector, TcVnVector4_UINT)
		TC3_VISION_DEFINE_ARRAY_WRAPPER_TRAITS(UCHAR, 4, Tc3_VisionVector, TcVnVector4_USINT)
	
		template<typename _ty, size_t nNum, ETc3_VisionWrapperType eType>struct Tc3_VisionArrayWrapper
		{
			using array_type = typename Tc3_VisionArrayWrapperTraits<_ty, nNum, eType>::array_type;
			static constexpr size_t m_nNum = nNum;
	
			array_type m_aData;
	
			Tc3_VisionArrayWrapper() : m_aData{} {}
			Tc3_VisionArrayWrapper(const Tc3_VisionArrayWrapper<_ty, nNum, eType>&) = default;
			Tc3_VisionArrayWrapper<_ty, nNum, eType>& operator=(const Tc3_VisionArrayWrapper<_ty, nNum, eType>&) = default;
	
			Tc3_VisionArrayWrapper(std::initializer_list<_ty> il) : m_aData{}
			{
				// check for too large initializer lists
				TCVN_ASSERT(TCVN_TYPETRAITS_NAMESPACE::distance(il.begin(), il.end()) <= m_nNum);
	
				size_t i;
				typename std::initializer_list<_ty>::iterator it;
				for(i = 0, it = il.begin(); (i < m_nNum) && (it != il.end()); ++i, ++it)
					m_aData[i] = *it;
			}
	
			// conversion constructor (same element type)
			template<ETc3_VisionWrapperType eTypeOther>
			Tc3_VisionArrayWrapper(const Tc3_VisionArrayWrapper<_ty, nNum, eTypeOther>& other)
			{
				for(size_t i = 0; i < nNum; ++i)
					m_aData[i] = other.m_aData[i];
			}
	
			// conversion constructor (different element type)
			template<typename _otherTy, ETc3_VisionWrapperType eTypeOther>
			explicit Tc3_VisionArrayWrapper(const Tc3_VisionArrayWrapper<_otherTy, nNum, eTypeOther>& other)
			{
				for(size_t i = 0; i < nNum; ++i)
					m_aData[i] = static_cast<_ty>(other.m_aData[i]);
			}
		
			// fill constructor
			template<typename _scalarTy>
			explicit Tc3_VisionArrayWrapper(const _scalarTy scalar)
			{
				for(size_t i = 0; i < nNum; ++i)
					m_aData[i] = scalar;
			}
	
			operator const array_type&() const
			{
				static_assert(TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty>::value, "invalid element type");
				return m_aData;
			}
	
			operator array_type&()
			{
				static_assert(TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty>::value, "invalid element type");
				return m_aData;
			}
	
			template<typename _ty, TCVN_TYPETRAITS_NAMESPACE::enable_if_t<TCVN_TYPETRAITS_NAMESPACE::is_integral<_ty>::value, bool> = true>
			auto operator[](_ty i) const -> const decltype(m_aData[i])
			{
				return m_aData[i];
			}
	
			template<typename _ty, TCVN_TYPETRAITS_NAMESPACE::enable_if_t<TCVN_TYPETRAITS_NAMESPACE::is_integral<_ty>::value, bool> = true>
			auto operator[](_ty i) -> decltype(m_aData[i])
			{
				return m_aData[i];
			}
	
			Tc3_VisionArrayWrapper<_ty, nNum, eType> operator-() const
			{
				Tc3_VisionArrayWrapper<_ty, nNum, eType> res;
				for(size_t i = 0; i < nNum; ++i)
					res.m_aData[i] = -this->m_aData[i];
	
				return res;
			}
	
			template<typename _ty2, ETc3_VisionWrapperType eType2>
			Tc3_VisionArrayWrapper<_ty, nNum, eType>& operator+=(const Tc3_VisionArrayWrapper<_ty2, nNum, eType2>& rhs)
			{
				for(size_t i = 0; i < nNum; ++i)
					this->m_aData[i] = this->m_aData[i] + rhs.m_aData[i];
	
				return *this;
			}
	
			template<typename _scalarTy>
			typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_scalarTy>::value, Tc3_VisionArrayWrapper<_ty, nNum, eType>& >::type 
				operator+=(const _scalarTy rhs)
			{
				for(size_t i = 0; i < nNum; ++i)
					this->m_aData[i] = this->m_aData[i] + rhs;
	
				return *this;
			}
	
			template<typename _ty2, ETc3_VisionWrapperType eType2>
			Tc3_VisionArrayWrapper<_ty, nNum, eType>& operator-=(const Tc3_VisionArrayWrapper<_ty2, nNum, eType2>& rhs)
			{
				for(size_t i = 0; i < nNum; ++i)
					this->m_aData[i] = this->m_aData[i] - rhs.m_aData[i];
	
				return *this;
			}
	
			template<typename _scalarTy>
			typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_scalarTy>::value, Tc3_VisionArrayWrapper<_ty, nNum, eType>& >::type 
				operator-=(const _scalarTy rhs)
			{
				for(size_t i = 0; i < nNum; ++i)
					this->m_aData[i] = this->m_aData[i] - rhs;
	
				return *this;
			}
	
			template<typename _scalarTy>
			typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_scalarTy>::value, Tc3_VisionArrayWrapper<_ty, nNum, eType>& >::type 
				operator*=(const _scalarTy rhs)
			{
				for(size_t i = 0; i < nNum; ++i)
					this->m_aData[i] = this->m_aData[i] * rhs;
	
				return *this;
			}
	
			Tc3_VisionArrayWrapper<_ty, nNum, eType>& operator/=(const double rhs)
			{
				for(size_t i = 0; i < nNum; ++i)
					this->m_aData[i] = static_cast<typename TCVN_TYPETRAITS_NAMESPACE::remove_reference<decltype(m_aData[i])>::type>(this->m_aData[i] / rhs);
	
				return *this;
			}
	
			template<typename _ty2, ETc3_VisionWrapperType eType2>
			Tc3_VisionArrayWrapper<_ty, nNum, eType>& operator=(const Tc3_VisionArrayWrapper<_ty2, nNum, eType2>& rhs)
			{
				for(size_t i = 0; i < nNum; ++i)
					this->m_aData[i] = rhs.m_aData[i];
	
				return *this;
			}
		};
	
		template<typename _ty1, typename _ty2>struct Tc3_VisionReturnHelper {};
		template<typename _ty>struct Tc3_VisionReturnHelper<_ty, _ty> { using type = _ty; };
		template<>struct Tc3_VisionReturnHelper<short, float> { using type = float; };
		template<>struct Tc3_VisionReturnHelper<float, short> { using type = float; };
		template<>struct Tc3_VisionReturnHelper<LONG, float> { using type = float; };
		template<>struct Tc3_VisionReturnHelper<float, LONG> { using type = float; };
		template<>struct Tc3_VisionReturnHelper<LONG, double> { using type = double; };
		template<>struct Tc3_VisionReturnHelper<double, LONG> { using type = double; };
		template<>struct Tc3_VisionReturnHelper<double, float> { using type = double; };
		template<>struct Tc3_VisionReturnHelper<float, double> { using type = double; };
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType1, ETc3_VisionWrapperType eType2>
		struct Tc3_VisionReturnTraits {};
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType>struct Tc3_VisionReturnTraits<_ty1, _ty2, nNum, eType, eType >
		{
			using type = typename Tc3_VisionArrayWrapper<typename Tc3_VisionReturnHelper<_ty1, _ty2>::type, nNum, eType>;
		};
		template<typename _ty1, typename _ty2, size_t nNum>struct Tc3_VisionReturnTraits<_ty1, _ty2, nNum, Tc3_VisionPoint, Tc3_VisionVector >
		{
			using type = typename Tc3_VisionArrayWrapper<typename Tc3_VisionReturnHelper<_ty1, _ty2>::type, nNum, Tc3_VisionPoint>;
		};
		template<typename _ty1, typename _ty2, size_t nNum>struct Tc3_VisionReturnTraits<_ty1, _ty2, nNum, Tc3_VisionVector, Tc3_VisionPoint >
		{
			using type = typename Tc3_VisionArrayWrapper<typename Tc3_VisionReturnHelper<_ty1, _ty2>::type, nNum, Tc3_VisionPoint>;
		};
	
		// -------------
		// operator ==
		// -------------
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType1, ETc3_VisionWrapperType eType2>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<!TCVN_TYPETRAITS_NAMESPACE::is_same<_ty1, _ty2>::value, bool>::type 
			operator==(const Tc3_VisionArrayWrapper<_ty1, nNum, eType1>& a, const Tc3_VisionArrayWrapper<_ty2, nNum, eType2>& b)
		{
			for(size_t i = 0; i < nNum; ++i)
				if(a.m_aData[i] != b.m_aData[i])
					return false;
	
			return true;
		}
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType1, ETc3_VisionWrapperType eType2>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_same<_ty1, _ty2>::value, bool>::type 
			operator==(const Tc3_VisionArrayWrapper<_ty1, nNum, eType1>& a, const Tc3_VisionArrayWrapper<_ty2, nNum, eType2>& b)
		{
			return memcmp(&(a.m_aData[0]), &(b.m_aData[0]), nNum * sizeof(_ty1)) == 0;
		}
	
		// -------------
		// operator !=
		// -------------
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType1, ETc3_VisionWrapperType eType2>
		inline bool operator!=(const Tc3_VisionArrayWrapper<_ty1, nNum, eType1>& a, const Tc3_VisionArrayWrapper<_ty2, nNum, eType2>& b)
		{
			return !(a == b);
		}
	
		// -------------
		// operator +
		// -------------
	
		template<typename _elementType1, typename _elementType2, size_t nNum, ETc3_VisionWrapperType eType1, ETc3_VisionWrapperType eType2>
		inline typename Tc3_VisionReturnTraits<_elementType1, _elementType2, nNum, eType1, eType2>::type
			operator+(const Tc3_VisionArrayWrapper<_elementType1, nNum, eType1>& a, const Tc3_VisionArrayWrapper<_elementType2, nNum, eType2>& b)
		{
			typename Tc3_VisionReturnTraits<_elementType1, _elementType2, nNum, eType1, eType2>::type res(a);
			res += b;
			return res;
		}
	
		template<typename _ty1, size_t nNum, ETc3_VisionWrapperType eType, typename _ty2>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty2>::value, Tc3_VisionArrayWrapper<_ty1, nNum, eType> >::type 
			operator+(const Tc3_VisionArrayWrapper<_ty1, nNum, eType>& array, const _ty2 scalar)
		{
			Tc3_VisionArrayWrapper<_ty1, nNum, eType> res(array);
			res += scalar;
			return res;
		}
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty1>::value, Tc3_VisionArrayWrapper<_ty2, nNum, eType> >::type 
			operator+(const _ty1 scalar, const Tc3_VisionArrayWrapper<_ty2, nNum, eType>& array)
		{
			Tc3_VisionArrayWrapper<_ty2, nNum, eType> res(scalar);
			res += array;
			return res;
		}
	
		// -------------
		// operator -
		// -------------
	
		template<typename _elementType1, typename _elementType2, size_t nNum, ETc3_VisionWrapperType eType1, ETc3_VisionWrapperType eType2>
		inline typename Tc3_VisionReturnTraits<_elementType1, _elementType2, nNum, eType1, eType2>::type
			operator-(const Tc3_VisionArrayWrapper<_elementType1, nNum, eType1>& a, const Tc3_VisionArrayWrapper<_elementType2, nNum, eType2>& b)
		{
			typename Tc3_VisionReturnTraits<_elementType1, _elementType2, nNum, eType1, eType2>::type res(a);
			res -= b;
			return res;
		}
	
		template<typename _ty1, size_t nNum, ETc3_VisionWrapperType eType, typename _ty2>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty2>::value, Tc3_VisionArrayWrapper<_ty1, nNum, eType> >::type 
			operator-(const Tc3_VisionArrayWrapper<_ty1, nNum, eType>& array, const _ty2 scalar)
		{
			Tc3_VisionArrayWrapper<_ty1, nNum, eType> res(array);
			res -= scalar;
			return res;
		}
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty1>::value, Tc3_VisionArrayWrapper<_ty2, nNum, eType> >::type 
			operator-(const _ty1 scalar, const Tc3_VisionArrayWrapper<_ty2, nNum, eType>& array)
		{
			Tc3_VisionArrayWrapper<_ty2, nNum, eType> res(scalar);
			res -= array;
			return res;
		}
	
		// -------------
		// operator *
		// -------------
	
		template<typename _ty1, size_t nNum, ETc3_VisionWrapperType eType, typename _ty2>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty2>::value, Tc3_VisionArrayWrapper<_ty1, nNum, eType> >::type 
			operator*(const Tc3_VisionArrayWrapper<_ty1, nNum, eType>& array, const _ty2 scalar)
		{
			Tc3_VisionArrayWrapper<_ty1, nNum, eType> res(array);
			res *= scalar;
			return res;
		}
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty1>::value, Tc3_VisionArrayWrapper<_ty2, nNum, eType> >::type 
			operator*(const _ty1 scalar, const Tc3_VisionArrayWrapper<_ty2, nNum, eType>& array)
		{
			Tc3_VisionArrayWrapper<_ty2, nNum, eType> res(array);
			res *= scalar;
			return res;
		}
	
		// -------------
		// operator /
		// -------------
	
		template<typename _ty1, size_t nNum, ETc3_VisionWrapperType eType, typename _ty2>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty2>::value, Tc3_VisionArrayWrapper<_ty1, nNum, eType> >::type 
			operator/(const Tc3_VisionArrayWrapper<_ty1, nNum, eType>& array, const _ty2 scalar)
		{
			Tc3_VisionArrayWrapper<_ty1, nNum, eType> res(array);
			res /= scalar;
			return res;
		}
	
		template<typename _ty1, typename _ty2, size_t nNum, ETc3_VisionWrapperType eType>
		inline typename TCVN_TYPETRAITS_NAMESPACE::enable_if<TCVN_TYPETRAITS_NAMESPACE::is_arithmetic<_ty1>::value, Tc3_VisionArrayWrapper<_ty2, nNum, eType> >::type 
			operator/(const _ty1 scalar, const Tc3_VisionArrayWrapper<_ty2, nNum, eType>& array)
		{
			Tc3_VisionArrayWrapper<_ty2, nNum, eType> res;
			for(size_t i = 0; i < nNum; ++i)
				res.m_aData[i] = scalar / array.m_aData[i];
			return res;
		}
	}
	
	TC3_VISION_DEFINE_ARRAY_WRAPPER(LONG, 2, Tc3_VisionPoint, TcVnPoint2_DINT)
	using TcVnPoint = TcVnPoint2_DINT;
	TC3_VISION_DEFINE_ARRAY_WRAPPER(double, 2, Tc3_VisionPoint, TcVnPoint2_LREAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(float, 2, Tc3_VisionPoint, TcVnPoint2_REAL)
	
	TC3_VISION_DEFINE_ARRAY_WRAPPER(double, 3, Tc3_VisionPoint, TcVnPoint3_LREAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(float, 3, Tc3_VisionPoint, TcVnPoint3_REAL)
	
	TC3_VISION_DEFINE_ARRAY_WRAPPER(LONG, 2, Tc3_VisionVector, TcVnVector2_DINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(short, 2, Tc3_VisionVector, TcVnVector2_INT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(double, 2, Tc3_VisionVector, TcVnVector2_LREAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(float, 2, Tc3_VisionVector, TcVnVector2_REAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(char, 2, Tc3_VisionVector, TcVnVector2_SINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(USHORT, 2, Tc3_VisionVector, TcVnVector2_UINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(UCHAR, 2, Tc3_VisionVector, TcVnVector2_USINT)
	
	TC3_VISION_DEFINE_ARRAY_WRAPPER(short, 3, Tc3_VisionVector, TcVnVector3_INT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(double, 3, Tc3_VisionVector, TcVnVector3_LREAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(float, 3, Tc3_VisionVector, TcVnVector3_REAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(char, 3, Tc3_VisionVector, TcVnVector3_SINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(USHORT, 3, Tc3_VisionVector, TcVnVector3_UINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(UCHAR, 3, Tc3_VisionVector, TcVnVector3_USINT)
	
	TC3_VISION_DEFINE_ARRAY_WRAPPER(short, 4, Tc3_VisionVector, TcVnVector4_INT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(LONG, 4, Tc3_VisionVector, TcVnVector4_DINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(double, 4, Tc3_VisionVector, TcVnVector4_LREAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(float, 4, Tc3_VisionVector, TcVnVector4_REAL)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(char, 4, Tc3_VisionVector, TcVnVector4_SINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(USHORT, 4, Tc3_VisionVector, TcVnVector4_UINT)
	TC3_VISION_DEFINE_ARRAY_WRAPPER(UCHAR, 4, Tc3_VisionVector, TcVnVector4_USINT)
	
	// -------------
	// operator +
	// -------------
	
	inline VN_TcVnKeyPoint operator+(const VN_TcVnKeyPoint& stKeyPoint1, const VN_TcVnKeyPoint& stKeyPoint2)
	{
		VN_TcVnKeyPoint result;
		result.aPoint[0] = stKeyPoint1.aPoint[0] + stKeyPoint2.aPoint[0];
		result.aPoint[1] = stKeyPoint1.aPoint[1] + stKeyPoint2.aPoint[1];
		result.fDiameter = stKeyPoint1.fDiameter + stKeyPoint2.fDiameter;
		result.fAngle = stKeyPoint1.fAngle + stKeyPoint2.fAngle;
		result.fResponse = stKeyPoint1.fResponse + stKeyPoint2.fResponse;
		result.nOctave = stKeyPoint1.nOctave + stKeyPoint2.nOctave;
		result.nClassId = stKeyPoint1.nClassId + stKeyPoint2.nClassId;
	
		return result;
	}
	
	inline VN_TcVnRectangle_DINT operator+(const VN_TcVnRectangle_DINT& stRect1, const VN_TcVnRectangle_DINT& stRect2)
	{
		VN_TcVnRectangle_DINT result;
		result.nX = stRect1.nX + stRect2.nX;
		result.nY = stRect1.nY + stRect2.nY;
		result.nWidth = stRect1.nWidth + stRect2.nWidth;
		result.nHeight = stRect1.nHeight + stRect2.nHeight;
	
		return result;
	}
	
	inline VN_TcVnRotatedRectangle operator+(const VN_TcVnRotatedRectangle& stRect1, const VN_TcVnRotatedRectangle& stRect2)
	{
		VN_TcVnRotatedRectangle result;
		result.aCenter[0] = stRect1.aCenter[0] + stRect2.aCenter[0];
		result.aCenter[1] = stRect1.aCenter[1] + stRect2.aCenter[1];
		result.stSize.fWidth = stRect1.stSize.fWidth + stRect2.stSize.fWidth;
		result.stSize.fHeight = stRect1.stSize.fHeight + stRect2.stSize.fHeight;
		result.fAngle = stRect1.fAngle + stRect2.fAngle;
	
		return result;
	}
	
	// -------------
	// operator ==
	// -------------
	
	inline bool operator==(const VN_TcVnDMatch& stDMatch1, const VN_TcVnDMatch& stDMatch2)
	{
		return (	stDMatch1.nQueryIdx == stDMatch2.nQueryIdx
				&& stDMatch1.nTrainIdx == stDMatch2.nTrainIdx
				&& stDMatch1.nImageIdx == stDMatch2.nImageIdx
				&& stDMatch1.fDistance == stDMatch2.fDistance);
	}
	
	inline bool operator==(const VN_TcVnKeyPoint& stKeyPoint1, const VN_TcVnKeyPoint& stKeyPoint2)
	{
		return (	stKeyPoint1.aPoint[0] == stKeyPoint2.aPoint[0]
				&& stKeyPoint1.aPoint[1] == stKeyPoint2.aPoint[1]
				&& stKeyPoint1.fDiameter == stKeyPoint2.fDiameter
				&& stKeyPoint1.fAngle == stKeyPoint2.fAngle
				&& stKeyPoint1.fResponse == stKeyPoint2.fResponse
				&& stKeyPoint1.nOctave == stKeyPoint2.nOctave
				&& stKeyPoint1.nClassId == stKeyPoint2.nClassId);
	}
	
	inline bool operator==(const VN_TcVnRectangle_DINT& stRect1, const VN_TcVnRectangle_DINT& stRect2)
	{
		return (	stRect1.nX == stRect2.nX
				&& stRect1.nY == stRect2.nY
				&& stRect1.nWidth == stRect2.nWidth
				&& stRect1.nHeight == stRect2.nHeight);
	}
	
	inline bool operator==(const VN_TcVnRotatedRectangle& stRect1, const VN_TcVnRotatedRectangle& stRect2)
	{
		return (stRect1.aCenter[0] == stRect2.aCenter[0]
				&& stRect1.aCenter[1] == stRect2.aCenter[1]
				&& stRect1.stSize.fWidth == stRect2.stSize.fWidth
				&& stRect1.stSize.fHeight == stRect2.stSize.fHeight
				&& stRect1.fAngle == stRect2.fAngle);
	}
	
	// ------------------------
	// output param assignment
	// ------------------------
	
	template<>inline void AssignTo<double[3][3]>(double(&dest)[3][3], const double(&src)[3][3])
	{
		for(int a = 0; a < 3; ++a)
		{
			for(int b = 0; b < 3; ++b)
				dest[a][b] = src[a][b];
		}
	}
	
	///////////////////////////////////////////////////////////////////////////////
	// Tc3_VisionElementAccessTraits
	///////////////////////////////////////////////////////////////////////////////
	
	template<typename _ElementType>struct Tc3_VisionElementAccessTraits {};
	
	TC3_VISION_DEFINE_ACCESS_INTERFACE(LONG, DINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(short, INT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(double, LREAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(float, REAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(char, SINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(ULONG, UDINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(USHORT, UINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(ULONGLONG, ULINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(UCHAR, USINT)
	
	TC3_VISION_DEFINE_ACCESS_INTERFACE(ITcVnImage*, ITcVnImage)
	
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnPoint2_DINT, TcVnPoint2_DINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnPoint2_REAL, TcVnPoint2_REAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnPoint2_LREAL, TcVnPoint2_LREAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnPoint3_REAL, TcVnPoint3_REAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnPoint3_LREAL, TcVnPoint3_LREAL)
	
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector2_DINT, TcVnVector2_DINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector2_INT, TcVnVector2_INT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector2_REAL, TcVnVector2_REAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector2_SINT, TcVnVector2_SINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector2_UINT, TcVnVector2_UINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector2_USINT, TcVnVector2_USINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector3_INT, TcVnVector3_INT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector3_REAL, TcVnVector3_REAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector3_SINT, TcVnVector3_SINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector3_UINT, TcVnVector3_UINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector3_USINT, TcVnVector3_USINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector4_DINT, TcVnVector4_DINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector4_INT, TcVnVector4_INT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector4_LREAL, TcVnVector4_LREAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector4_REAL, TcVnVector4_REAL)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector4_SINT, TcVnVector4_SINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector4_UINT, TcVnVector4_UINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(TcVnVector4_USINT, TcVnVector4_USINT)
	
	TC3_VISION_DEFINE_ACCESS_INTERFACE(VN_TcVnRectangle_DINT, TcVnRectangle_DINT)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(VN_TcVnRotatedRectangle, TcVnRotatedRectangle)
	
	TC3_VISION_DEFINE_ACCESS_INTERFACE(VN_TcVnKeyPoint, TcVnKeyPoint)
	TC3_VISION_DEFINE_ACCESS_INTERFACE(VN_TcVnDMatch, TcVnDMatch)

	extern TcTmlVersionedLibraryInfo libraryInfo;

	TCOM_DECL_INTERFACE("aff801f3-60d0-43fa-980f-572a6205b5af", ITcVnColorModel)
	TCOM_DECL_INTERFACE("34359f14-7f93-4029-b4f2-ee882aa4bc0c", ITcVnCustomContainerOperation_ITcVnContainer)
	TCOM_DECL_INTERFACE("07c993f1-5bf1-4781-bfc5-b3489d685f7a", ITcVnCustomContainerOperation_ITcVnForwardIterator)
	TCOM_DECL_INTERFACE("cb32ebb6-1b7a-4113-901b-01e8fa8aaaa0", ITcVnCustomElementCondition_ITcVnContainer)
	TCOM_DECL_INTERFACE("fe95da91-dca6-47ef-896d-9332cdd8ae4e", ITcVnCustomElementCondition_ITcVnForwardIterator)

	/// <summary>
	/// Offers search strategies for 2d code reading (multiple TCVN_CSS_XXX_INVERTED or multiple TCVN_CSS_XXX_FLIPPED cannot be combined).
	/// </summary>
	enum ETcVn2dCodeSearchStrategy : ULONG
	{
		CSS_DEFAULT = 1, // The algorithm searches for codes using the default searching strategy, all other flags are ignored (dependant on code type).
		CSS_ONLY_NOT_INVERTED = 8, // The algorithm searches for codes only in the non-inverted image.
		CSS_FIRST_NOT_INVERTED = 10, // The algorithm first searches for codes in the non-inverted and then in the inverted image.
		CSS_ONLY_INVERTED = 12, // The algorithm searches for codes only in the inverted image.
		CSS_FIRST_INVERTED = 14, // The algorithm first searches for codes in the inverted and then in the non-inverted image.
		CSS_ONLY_NOT_FLIPPED = 64, // The algorithm searches for codes only in the non-mirrored image.
		CSS_FIRST_NOT_FLIPPED = 80, // The algorithm first searches for codes in the non-mirrored and then in the mirrored image.
		CSS_ONLY_FLIPPED = 96, // The algorithm searches for codes only in the mirrored image.
		CSS_FIRST_FLIPPED = 112, // The algorithm first searches for codes in the mirrored and then in the non-mirrored image.
	};

	/// <summary>
	/// Offers methods for adaptive threshold.
	/// </summary>
	enum ETcVnAdaptiveThresholdMethod : LONG
	{
		ATM_MEAN = 0, // The threshold value is calculated as the mean of the nBlockSize x nBlockSize neighborhood of (x,y) minus fConstant.
		ATM_GAUSSIAN = 1, // The threshold value is the weighted sum (cross-correlation with a Gaussian window) of the nBlockSize x nBlockSize neighborhood of (x,y) minus fConstant.
	};

	/// <summary>
	/// Offers search directions for linear barcodes.
	/// </summary>
	enum ETcVnBarcodeSearchDirection : ULONG
	{
		BSD_ANY = 0, // The algorithm searches for codes in any supported directions.
		BSD_HORIZONTAL = 1, // The algorithm searches for codes in horizontal direction.
		BSD_VERTICAL = 2, // The algorithm searches for codes in vertical direction.
	};

	/// <summary>
	/// Offers linear barcode types to search for.
	/// </summary>
	enum ETcVnBarcodeType : ULONG
	{
		BT_CODABAR = 4, // The algorithm searches for Codabar codes.
		BT_CODE39 = 8, // The algorithm searches for Code-39 codes.
		BT_CODE93 = 16, // The algorithm searches for Code-93 codes.
		BT_CODE128 = 32, // The algorithm searches for Code-128 codes.
		BT_EAN8 = 128, // The algorithm searches for EAN-8 codes.
		BT_EAN13 = 256, // The algorithm searches for EAN-13 codes.
		BT_ITF = 512, // The algorithm searches for ITF codes.
		BT_UPCA = 32768, // The algorithm searches for UPC-A codes.
		BT_UPCE = 65536, // The algorithm searches for UPC-E codes.
		BT_ANY = 99260, // The algorithm searches for any supported linear barcode. If the type of the code is known, it is recommended to select the specific type directly.
		BT_CODE39EXTENDED = 262144, // The algorithm searches for Code-93-Extended codes.
	};

	/// <summary>
	/// Offers multiple blob contours to choose from, which should be returned in a multi-threshold scenario (used in TcVnParamsBlobDetection, which in return is used in F_VN_DetectBlobs).
	/// </summary>
	enum ETcVnBlobCombination : LONG
	{
		BC_SMALLEST = 0, // Returns the smallest blob contour.
		BC_LARGEST = 1, // Returns the largest blob contour.
		BC_MIN_THRESHOLD = 2, // Returns the blob contour for the minimum threshold.
		BC_MAX_THRESHOLD = 3, // Returns the blob contour for the maximum threshold.
		BC_MEDIAN_THRESHOLD = 4, // Returns the blob contour for the median threshold.
	};

	/// <summary>
	/// Offers different types of Boost classifiers.
	/// </summary>
	enum ETcVnBoostClassifierType : LONG
	{
		BCT_DISCRETE = 0, // Discrete AdaBoost
		BCT_REAL = 1, // Real AdaBoost
		BCT_LOGIT = 2, // LogitBoost
		BCT_GENTLE = 3, // Gentle AdaBoost
	};

	/// <summary>
	/// Offers methods to extrapolate values of non-existing pixels. On the one hand, this is used for filtering functions to enable filtering at the image borders (where the filter mask reaches over the border). On the other hand, this is used to extrapolate the undefined pixels after a geometric image transformation.
	/// </summary>
	enum ETcVnBorderInterpolationMethod : LONG
	{
		BIM_CONSTANT = 0, // iiiiiii | abcdefgh | iiiiiii  (with some specified i)
		BIM_REPLICATE = 1, // aaaaaaa | abcdefgh | hhhhhhh
		BIM_REFLECT = 2, // gfedcba | abcdefgh | hgfedcb
		BIM_WRAP = 3, // bcdefgh | abcdefgh | abcdefg
		BIM_REFLECT_101 = 4, // hgfedcb | abcdefgh | gfedcba
		BIM_DEFAULT = 4, // Choose this if you don't know which method to select (same as REFLECT_101).
		BIM_TRANSPARENT = 5, // Corresponding pixels in the destination image will not be modified. Only available for geometric image transformations.
		BIM_ISOLATED_CONSTANT = 16, // Similar to CONSTANT, but ROIs are handled as isolated, which means surrounding image pixels outside the ROI are ignored.
		BIM_ISOLATED_REPLICATE = 17, // Similar to REPLICATE, but ROIs are handled as isolated, which means surrounding image pixels outside the ROI are ignored.
		BIM_ISOLATED_REFLECT = 18, // Similar to REFLECT, but ROIs are handled as isolated, which means surrounding image pixels outside the ROI are ignored.
		BIM_ISOLATED_WRAP = 19, // Similar to WRAP, but ROIs are handled as isolated, which means surrounding image pixels outside the ROI are ignored.
		BIM_ISOLATED_REFLECT_101 = 20, // Similar to REFLECT_101, but ROIs are handled as isolated, which means surrounding image pixels outside the ROI are ignored.
	};

	/// <summary>
	/// Offers common calibration pattern types.
	/// </summary>
	enum ETcVnCalibrationPattern : LONG
	{
		CP_CIRCLES_SYM = 0, // Symmetric circle pattern
		CP_CIRCLES_ASYM = 1, // Asymmetric circle pattern, i.e. every 2nd row is indented, starting unindented
		CP_CIRCLES_ASYM_INDENT = 2, // Asymmetric circle pattern, i.e. every 2nd row is indented, starting indented
	};

	/// <summary>
	/// Offers calibration pattern origins.
	/// </summary>
	enum ETcVnCalibrationPatternOrigin : LONG
	{
		CPO_TOPLEFT = 0, // Origin is at top left
		CPO_TOPCENTER = 1, // Origin is at top center
		CPO_TOPRIGHT = 2, // Origin is at top right
		CPO_CENTERLEFT = 3, // Origin is at center left
		CPO_CENTER = 4, // Origin is at center
		CPO_CENTERRIGHT = 5, // Origin is at center right
		CPO_BOTTOMLEFT = 6, // Origin is at bottom left
		CPO_BOTTOMCENTER = 7, // Origin is at bottom center
		CPO_BOTTOMRIGHT = 8, // Origin is at bottom right
	};

	/// <summary>
	/// Specifies the state of a camera controller, which controls an attached camera.
	/// </summary>
	enum ETcVnCameraState : LONG
	{
		CS_ERROR = -1, // The camera controller is in an error state (e.g. the connection to the camera was lost).
		CS_INITIAL = 0, // The camera controller is in the initial state and ready to establish the connection to the camera.
		CS_INITIALIZING = 1, // The camera controller is initializing the camera.
		CS_INITIALIZED = 2, // The camera controller has initialized the camera.
		CS_OPENING = 3, // The camera controller is establishing the connection to the camera.
		CS_OPENED = 4, // The connection to the camera has been established and the camera controller is ready to start the image acquisition.
		CS_STARTACQUISITION = 5, // The camera controller is starting the image acquisition.
		CS_ACQUIRING = 6, // The camera is sending images (either streaming or manually triggered, depending on the configuration).
		CS_STOPACQUISITION = 7, // The camera controller is stopping the image acquisition.
		CS_RESETTINGFEATURES = 8, // The camera controller is resetting the features on the camera.
		CS_TRIGGERING = 9, // The camera controller is processing a softwaretrigger.
		CS_CLOSING = 10, // The camera controller is closing the connection to the camera.
	};

	/// <summary>
	/// Offers methods to calculate contour circularity
	/// </summary>
	enum ETcVnCircularityCalculationMethod : LONG
	{
		CCM_DEFAULT = 0, // 4pi * area / perimeter^2
		CCM_CONVEXHULL_PERIMETER = 1, // 4pi * area / (convex hull perimeter)^2
		CCM_MAX_RADIUS = 2, // area / (pi * r^2), r = max distance to the contour's center of mass
		CCM_ENCLOSINGCIRCLE_RADIUS = 3, // area / (pi * r^2), r = radius of the minimum enclosing circle
	};

	/// <summary>
	/// Offers clustering algorithms
	/// </summary>
	enum ETcVnClusteringAlgorithm : LONG
	{
		CA_KMEANSPP = 0, // KMeans++ (fixed number of clusters)
		CA_LBG = 1, // LBG variant (dynamic number of clusters)
	};

	/// <summary>
	/// Offers color maps (similar to GNU Octave/MATLAB types).
	/// </summary>
	enum ETcVnColorMap : LONG
	{
		CM_AUTUMN = 0, // Red - orange - yellow
		CM_BONE = 1, // Black - blueish gray - white
		CM_JET = 2, // Dark blue - green - dark red
		CM_WINTER = 3, // Blue - green
		CM_RAINBOW = 4, // Red - green - purple
		CM_OCEAN = 5, // Black - blue - white
		CM_SUMMER = 6, // Green - yellow
		CM_SPRING = 7, // Pink - yellow
		CM_COOL = 8, // Cyan - magenta
		CM_HSV = 9, // Red - green - blue - red
		CM_PINK = 10, // Black - pink - light yellow - white
		CM_HOT = 11, // Black - red - yellow - white
		CM_PARULA = 12, // Blue - yellow
		CM_MAGMA = 13, // Black - magenta - light yellow
		CM_INFERNO = 14, // Black - magenta - yellow
		CM_PLASMA = 15, // Blue - magenta - yellow
		CM_VIRIDIS = 16, // Purple - yellow
		CM_CIVIDIS = 17, // Blue - gray - yellow
		CM_TWILIGHT = 18, // White - light blue - dark purple - light red - white
		CM_TWILIGHT_SHIFTED = 19, // Dark purple - light blue - white - light red - dark purple
		CM_TURBO = 20, // Dark blue - light green - dark red
	};

	/// <summary>
	/// Offers color map sizes.
	/// </summary>
	enum ETcVnColorMapSize : ULONG
	{
		CMS_256 = 256, // 256 colors, used for 8 bit images (TCVN_ET_USINT)
		CMS_65536 = 65536, // 65536 colors, used for 16 bit images (TCVN_ET_UINT)
	};

	/// <summary>
	/// Offers color space transformations.
	/// </summary>
	enum ETcVnColorSpaceTransform : LONG
	{
		CST_BGR_TO_BGRA = 0, // Transform the color space from BGR to BGRA.
		CST_RGB_TO_RGBA = 0, // Transform the color space from RGB to RGBA.
		CST_BGRA_TO_BGR = 1, // Transform the color space from BGRA to BGR.
		CST_RGBA_TO_RGB = 1, // Transform the color space from RGBA to RGB.
		CST_BGR_TO_RGBA = 2, // Transform the color space from BGR to RGBA.
		CST_RGB_TO_BGRA = 2, // Transform the color space from RGB to BGRA.
		CST_BGRA_TO_RGB = 3, // Transform the color space from BGRA to RGB.
		CST_RGBA_TO_BGR = 3, // Transform the color space from RGBA to BGR.
		CST_BGR_TO_RGB = 4, // Transform the color space from BGR to RGB.
		CST_RGB_TO_BGR = 4, // Transform the color space from RGB to BGR.
		CST_BGRA_TO_RGBA = 5, // Transform the color space from BGRA to RGBA.
		CST_RGBA_TO_BGRA = 5, // Transform the color space from RGBA to BGRA.
		CST_BGR_TO_GRAY = 6, // Transform the color space from BGR to Gray.
		CST_RGB_TO_GRAY = 7, // Transform the color space from RGB to Gray.
		CST_GRAY_TO_BGR = 8, // Transform the color space from Gray to BGR.
		CST_GRAY_TO_RGB = 8, // Transform the color space from Gray to RGB.
		CST_GRAY_TO_BGRA = 9, // Transform the color space from Gray to BGRA.
		CST_GRAY_TO_RGBA = 9, // Transform the color space from Gray to RGBA.
		CST_BGRA_TO_GRAY = 10, // Transform the color space from BGRA to Gray.
		CST_RGBA_TO_GRAY = 11, // Transform the color space from RGBA to Gray.
		CST_RGB_TO_BGR_565 = 12, // Transform the color space from RGB(24 bit 888) to BGR(16 bit 565).
		CST_BGR_TO_BGR_565 = 13, // Transform the color space from BGR(24 bit 888) to BGR(16 bit 565).
		CST_BGR_565_TO_RGB = 14, // Transform the color space from BGR(16 bit 565) to RGB(24 bit 888).
		CST_BGR_565_TO_BGR = 15, // Transform the color space from BGR(16 bit 565) to BGR(24 bit 888).
		CST_RGBA_TO_BGR_565 = 16, // Transform the color space from RGBA(32 bit 8888) to BGR(16 bit 565).
		CST_BGRA_TO_BGR_565 = 17, // Transform the color space from BGRA(32 bit 8888) to BGR(16 bit 565).
		CST_BGR_565_TO_RGBA = 18, // Transform the color space from BGR(16 bit 565) to RGBA(32 bit 8888).
		CST_BGR_565_TO_BGRA = 19, // Transform the color space from BGR(16 bit 565) to BGRA(32 bit 8888).
		CST_GRAY_TO_BGR_565 = 20, // Transform the color space from Gray to BGR(16 bit 565).
		CST_BGR_565_TO_GRAY = 21, // Transform the color space from BGR(16 bit 565) to Gray.
		CST_RGB_TO_BGR_555 = 22, // Transform the color space from RGB(24 bit 888) to BGR(16 bit 555).
		CST_BGR_TO_BGR_555 = 23, // Transform the color space from BGR(24 bit 888) to BGR(16 bit 555).
		CST_BGR_555_TO_RGB = 24, // Transform the color space from BGR(16 bit 555) to RGB(24 bit 888).
		CST_BGR_555_TO_BGR = 25, // Transform the color space from BGR(16 bit 555) to BGR(24 bit 888).
		CST_RGBA_TO_BGR_555 = 26, // Transform the color space from RGBA(32 bit 8888) to BGR(16 bit 555).
		CST_BGRA_TO_BGR_555 = 27, // Transform the color space from BGRA(32 bit 8888) to BGR(16 bit 555).
		CST_BGR_555_TO_RGBA = 28, // Transform the color space from BGR(16 bit 555) to RGBA(32 bit 8888).
		CST_BGR_555_TO_BGRA = 29, // Transform the color space from BGR(16 bit 555) to BGRA(32 bit 8888).
		CST_GRAY_TO_BGR_555 = 30, // Transform the color space from Gray to BGR(16 bit 555).
		CST_BGR_555_TO_GRAY = 31, // Transform the color space from BGR(16 bit 555) to Gray.
		CST_BGR_TO_XYZ = 32, // Transform the color space from BGR to CIE XYZ (scaled to the full value range of the image).
		CST_RGB_TO_XYZ = 33, // Transform the color space from RGB to CIE XYZ (scaled to the full value range of the image).
		CST_XYZ_TO_BGR = 34, // Transform the color space from CIE XYZ (scaled to the full value range of the image) to BGR.
		CST_XYZ_TO_RGB = 35, // Transform the color space from CIE XYZ (scaled to the full value range of the image) to RGB.
		CST_BGR_TO_YCRCB = 36, // Transform the color space from BGR to YCrCb (scaled to the full value range of the image).
		CST_RGB_TO_YCRCB = 37, // Transform the color space from RGB to YCrCb (scaled to the full value range of the image).
		CST_YCRCB_TO_BGR = 38, // Transform the color space from YCrCb (scaled to the full value range of the image) to BGR.
		CST_YCRCB_TO_RGB = 39, // Transform the color space from YCrCb (scaled to the full value range of the image) to RGB.
		CST_BGR_TO_HSV = 40, // Transform the color space from BGR to HSV (supports images of type USINT or REAL; for USINT, H is scaled to a range from 0 to 180 and S,V from 0 to 255).
		CST_RGB_TO_HSV = 41, // Transform the color space from RGB to HSV (supports images of type USINT or REAL; for USINT, H is scaled to a range from 0 to 180 and S,V from 0 to 255).
		CST_BGR_TO_LAB = 44, // Transform the color space from BGR to CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_RGB_TO_LAB = 45, // Transform the color space from RGB to CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_BAYER_RG_TO_BGR = 46, // Transform the color space from BayerRG to BGR (supports images of type USINT or UINT).
		CST_BAYER_BG_TO_RGB = 46, // Transform the color space from BayerBG to RGB (supports images of type USINT or UINT).
		CST_BAYER_GR_TO_BGR = 47, // Transform the color space from BayerGR to BGR (supports images of type USINT or UINT).
		CST_BAYER_GB_TO_RGB = 47, // Transform the color space from BayerGB to RGB (supports images of type USINT or UINT).
		CST_BAYER_BG_TO_BGR = 48, // Transform the color space from BayerBG to BGR (supports images of type USINT or UINT).
		CST_BAYER_RG_TO_RGB = 48, // Transform the color space from BayerRG to RGB (supports images of type USINT or UINT).
		CST_BAYER_GB_TO_BGR = 49, // Transform the color space from BayerGB to BGR (supports images of type USINT or UINT).
		CST_BAYER_GR_TO_RGB = 49, // Transform the color space from BayerGR to RGB (supports images of type USINT or UINT).
		CST_BGR_TO_LUV = 50, // Transform the color space from BGR to CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_RGB_TO_LUV = 51, // Transform the color space from RGB to CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_BGR_TO_HLS = 52, // Transform the color space from BGR to HLS (for images of type USINT, H is scaled to a range from 0 to 180 and L,S from 0 to 255).
		CST_RGB_TO_HLS = 53, // Transform the color space from RGB to HLS (for images of type USINT, H is scaled to a range from 0 to 180 and L,S from 0 to 255).
		CST_HSV_TO_BGR = 54, // Transform the color space from HSV (for images of type USINT, H is scaled to a range from 0 to 180 and S,V from 0 to 255) to BGR.
		CST_HSV_TO_RGB = 55, // Transform the color space from HSV (for images of type USINT, H is scaled to a range from 0 to 180 and S,V from 0 to 255) to RGB.
		CST_LAB_TO_BGR = 56, // Transform the color space from CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255) to BGR.
		CST_LAB_TO_RGB = 57, // Transform the color space from CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255) to RGB.
		CST_LUV_TO_BGR = 58, // Transform the color space from CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255) to BGR.
		CST_LUV_TO_RGB = 59, // Transform the color space from CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255) to RGB.
		CST_HLS_TO_BGR = 60, // Transform the color space from HLS (for images of type USINT, H is scaled to a range from 0 to 180 and L,S from 0 to 255) to BGR.
		CST_HLS_TO_RGB = 61, // Transform the color space from HLS (for images of type USINT, H is scaled to a range from 0 to 180 and L,S from 0 to 255) to RGB.
		CST_BAYER_RG_TO_BGR_VNG = 62, // Transform the color space from BayerRG to BGR, using Variable Number of Gradients (supports images of type USINT).
		CST_BAYER_GR_TO_BGR_VNG = 63, // Transform the color space from BayerGR to BGR, using Variable Number of Gradients (supports images of type USINT).
		CST_BAYER_BG_TO_BGR_VNG = 64, // Transform the color space from BayerBG to BGR, using Variable Number of Gradients (supports images of type USINT).
		CST_BAYER_GB_TO_BGR_VNG = 65, // Transform the color space from BayerGB to BGR, using Variable Number of Gradients (supports images of type USINT).
		CST_BAYER_RG_TO_RGB_VNG = 64, // Transform the color space from BayerRG to RGB, using Variable Number of Gradients (supports images of type USINT).
		CST_BAYER_GR_TO_RGB_VNG = 65, // Transform the color space from BayerGR to RGB, using Variable Number of Gradients (supports images of type USINT).
		CST_BAYER_BG_TO_RGB_VNG = 62, // Transform the color space from BayerBG to RGB, using Variable Number of Gradients (supports images of type USINT).
		CST_BAYER_GB_TO_RGB_VNG = 63, // Transform the color space from BayerGB to RGB, using Variable Number of Gradients (supports images of type USINT).
		CST_BGR_TO_HSV_FULL = 66, // Transform the color space from BGR to HSV (supports images of type USINT or REAL; for USINT, all channels are scaled to a range from 0 to 255).
		CST_RGB_TO_HSV_FULL = 67, // Transform the color space from RGB to HSV (supports images of type USINT or REAL; for USINT, all channels are scaled to a range from 0 to 255).
		CST_BGR_TO_HLS_FULL = 68, // Transform the color space from BGR to HLS (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_RGB_TO_HLS_FULL = 69, // Transform the color space from RGB to HLS (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_HSV_TO_BGR_FULL = 70, // Transform the color space from HSV (for images of type USINT, all channels are scaled to a range from 0 to 255) to BGR.
		CST_HSV_TO_RGB_FULL = 71, // Transform the color space from HSV (for images of type USINT, all channels are scaled to a range from 0 to 255) to RGB.
		CST_HLS_TO_BGR_FULL = 72, // Transform the color space from HLS (for images of type USINT, all channels are scaled to a range from 0 to 255) to BGR.
		CST_HLS_TO_RGB_FULL = 73, // Transform the color space from HLS (for images of type USINT, all channels are scaled to a range from 0 to 255) to RGB.
		CST_LBGR_TO_LAB = 74, // Transform the color space from LBGR to CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_LRGB_TO_LAB = 75, // Transform the color space from LRGB to CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_LBGR_TO_LUV = 76, // Transform the color space from LBGR to CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_LRGB_TO_LUV = 77, // Transform the color space from LRGB to CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255).
		CST_LAB_TO_LBGR = 78, // Transform the color space from CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255) to LBGR.
		CST_LAB_TO_LRGB = 79, // Transform the color space from CIE L*a*b* (for images of type USINT, all channels are scaled to a range from 0 to 255) to LRGB.
		CST_LUV_TO_LBGR = 80, // Transform the color space from CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255) to LBGR.
		CST_LUV_TO_LRGB = 81, // Transform the color space from CIE L*u*v* (for images of type USINT, all channels are scaled to a range from 0 to 255) to LRGB.
		CST_BGR_TO_YUV = 82, // Transform the color space from BGR to YUV (scaled to the full value range of the image).
		CST_RGB_TO_YUV = 83, // Transform the color space from RGB to YUV (scaled to the full value range of the image).
		CST_YUV_TO_BGR = 84, // Transform the color space from YUV (scaled to the full value range of the image) to BGR.
		CST_YUV_TO_RGB = 85, // Transform the color space from YUV (scaled to the full value range of the image) to RGB.
		CST_BAYER_RG_TO_GRAY = 86, // Transform the color space from BayerRG to Gray (supports images of type USINT or UINT).
		CST_BAYER_GR_TO_GRAY = 87, // Transform the color space from BayerGR to Gray (supports images of type USINT or UINT).
		CST_BAYER_BG_TO_GRAY = 88, // Transform the color space from BayerBG to Gray (supports images of type USINT or UINT).
		CST_BAYER_GB_TO_GRAY = 89, // Transform the color space from BayerGB to Gray (supports images of type USINT or UINT).
		CST_YUV_420_NV12_TO_RGB = 90, // Transform the color space from YUV420 NV12 to RGB.
		CST_YUV_420_NV12_TO_BGR = 91, // Transform the color space from YUV420 NV12 to BGR.
		CST_YUV_420_NV21_TO_RGB = 92, // Transform the color space from YUV420 NV21 (SP) to RGB.
		CST_YUV_420_NV21_TO_BGR = 93, // Transform the color space from YUV420 NV21 (SP) to BGR.
		CST_YUV_420_SP_TO_RGB = 92, // Transform the color space from YUV420 NV21 (SP) to RGB.
		CST_YUV_420_SP_TO_BGR = 93, // Transform the color space from YUV420 NV21 (SP) to BGR.
		CST_YUV_420_NV12_TO_RGBA = 94, // Transform the color space from YUV420 NV12 to RGBA.
		CST_YUV_420_NV12_TO_BGRA = 95, // Transform the color space from YUV420 NV12 to BGRA.
		CST_YUV_420_NV21_TO_RGBA = 96, // Transform the color space from YUV420 NV21 (SP) to RGBA.
		CST_YUV_420_NV21_TO_BGRA = 97, // Transform the color space from YUV420 NV21 (SP) to BGRA.
		CST_YUV_420_SP_TO_RGBA = 96, // Transform the color space from YUV420 NV21 (SP) to RGBA.
		CST_YUV_420_SP_TO_BGRA = 97, // Transform the color space from YUV420 NV21 (SP) to BGRA.
		CST_YUV_420_YV12_TO_RGB = 98, // Transform the color space from YUV420 YV12 (P) to RGB.
		CST_YUV_420_YV12_TO_BGR = 99, // Transform the color space from YUV420 YV12 (P) to BGR.
		CST_YUV_420_IYUV_TO_RGB = 100, // Transform the color space from YUV420 IYUV (I420) to RGB.
		CST_YUV_420_IYUV_TO_BGR = 101, // Transform the color space from YUV420 IYUV (I420) to BGR.
		CST_YUV_420_I420_TO_RGB = 100, // Transform the color space from YUV420 IYUV (I420) to RGB.
		CST_YUV_420_I420_TO_BGR = 101, // Transform the color space from YUV420 IYUV (I420) to BGR.
		CST_YUV_420_P_TO_RGB = 98, // Transform the color space from YUV420 YV12 (P) to RGB.
		CST_YUV_420_P_TO_BGR = 99, // Transform the color space from YUV420 YV12 (P) to BGR.
		CST_YUV_420_YV12_TO_RGBA = 102, // Transform the color space from YUV420 YV12 (P) to RGBA.
		CST_YUV_420_YV12_TO_BGRA = 103, // Transform the color space from YUV420 YV12 (P) to BGRA.
		CST_YUV_420_IYUV_TO_RGBA = 104, // Transform the color space from YUV420 IYUV (I420) to RGBA.
		CST_YUV_420_IYUV_TO_BGRA = 105, // Transform the color space from YUV420 IYUV (I420) to BGRA.
		CST_YUV_420_I420_TO_RGBA = 104, // Transform the color space from YUV420 IYUV (I420) to RGBA.
		CST_YUV_420_I420_TO_BGRA = 105, // Transform the color space from YUV420 IYUV (I420) to BGRA.
		CST_YUV_420_P_TO_RGBA = 102, // Transform the color space from YUV420 YV12 (P) to RGBA.
		CST_YUV_420_P_TO_BGRA = 103, // Transform the color space from YUV420 YV12 (P) to BGRA.
		CST_YUV_420_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_420_NV21_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_420_NV12_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_420_YV12_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_420_IYUV_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_420_I420_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_420_SP_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_420_P_TO_GRAY = 106, // Transform the color space from YUV420 to Gray.
		CST_YUV_422_UYVY_TO_RGB = 107, // Transform the color space from YUV422 UYVY (Y422, UYNV) to RGB.
		CST_YUV_422_UYVY_TO_BGR = 108, // Transform the color space from YUV422 UYVY (Y422, UYNV) to BGR.
		CST_YUV_422_Y422_TO_RGB = 107, // Transform the color space from YUV422 UYVY (Y422, UYNV) to RGB.
		CST_YUV_422_Y422_TO_BGR = 108, // Transform the color space from YUV422 UYVY (Y422, UYNV) to BGR.
		CST_YUV_422_UYNV_TO_RGB = 107, // Transform the color space from YUV422 UYVY (Y422, UYNV) to RGB.
		CST_YUV_422_UYNV_TO_BGR = 108, // Transform the color space from YUV422 UYVY (Y422, UYNV) to BGR.
		CST_YUV_422_UYVY_TO_RGBA = 111, // Transform the color space from YUV422 UYVY (Y422, UYNV) to RGBA.
		CST_YUV_422_UYVY_TO_BGRA = 112, // Transform the color space from YUV422 UYVY (Y422, UYNV) to BGRA.
		CST_YUV_422_Y422_TO_RGBA = 111, // Transform the color space from YUV422 UYVY (Y422, UYNV) to RGB.
		CST_YUV_422_Y422_TO_BGRA = 112, // Transform the color space from YUV422 UYVY (Y422, UYNV) to BGRA.
		CST_YUV_422_UYNV_TO_RGBA = 111, // Transform the color space from YUV422 UYVY (Y422, UYNV) to RGB.
		CST_YUV_422_UYNV_TO_BGRA = 112, // Transform the color space from YUV422 UYVY (Y422, UYNV) to BGRA.
		CST_YUV_422_YUY2_TO_RGB = 115, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to RGB.
		CST_YUV_422_YUY2_TO_BGR = 116, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to BGR.
		CST_YUV_422_YVYU_TO_RGB = 117, // Transform the color space from YUV422 YVYU to RGB.
		CST_YUV_422_YVYU_TO_BGR = 118, // Transform the color space from YUV422 YVYU to BGR.
		CST_YUV_422_YUYV_TO_RGB = 115, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to RGB.
		CST_YUV_422_YUYV_TO_BGR = 116, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to BGR.
		CST_YUV_422_YUNV_TO_RGB = 115, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to RGB.
		CST_YUV_422_YUNV_TO_BGR = 116, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to BGR.
		CST_YUV_422_YUY2_TO_RGBA = 119, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to RGBA.
		CST_YUV_422_YUY2_TO_BGRA = 120, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to BGRA.
		CST_YUV_422_YVYU_TO_RGBA = 121, // Transform the color space from YUV422 YVYU to RGBA.
		CST_YUV_422_YVYU_TO_BGRA = 122, // Transform the color space from YUV422 YVYU to BGRA.
		CST_YUV_422_YUYV_TO_RGBA = 119, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to RGBA.
		CST_YUV_422_YUYV_TO_BGRA = 120, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to BGRA.
		CST_YUV_422_YUNV_TO_RGBA = 119, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to RGBA.
		CST_YUV_422_YUNV_TO_BGRA = 120, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to BGRA.
		CST_YUV_422_UYVY_TO_GRAY = 123, // Transform the color space from YUV422 UYVY (Y422, UYNV) to Gray.
		CST_YUV_422_YUY2_TO_GRAY = 124, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to Gray.
		CST_YUV_422_Y422_TO_GRAY = 123, // Transform the color space from YUV422 UYVY (Y422, UYNV) to Gray.
		CST_YUV_422_UYNV_TO_GRAY = 123, // Transform the color space from YUV422 UYVY (Y422, UYNV) to Gray.
		CST_YUV_422_YVYU_TO_GRAY = 124, // Transform the color space from YUV422 YVYU to Gray.
		CST_YUV_422_YUYV_TO_GRAY = 124, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to Gray.
		CST_YUV_422_YUNV_TO_GRAY = 124, // Transform the color space from YUV422 YUYV (YUY2, YUNV) to Gray.
		CST_RGBA_TO_PREMULTIPLICATED_RGBA = 125, // Transform the color space from RGBA to premultiplicated RGBA.
		CST_PREMULTIPLICATED_RGBA_TO_RGBA = 126, // Transform the color space from premultiplicated RGBA to RGBA.
		CST_RGB_TO_YUV_420_I420 = 127, // Transform the color space from RGB to YUV420 IYUV (I420).
		CST_BGR_TO_YUV_420_I420 = 128, // Transform the color space from BGR to YUV420 IYUV (I420).
		CST_RGB_TO_YUV_420_IYUV = 127, // Transform the color space from RGB to YUV420 IYUV (I420).
		CST_BGR_TO_YUV_420_IYUV = 128, // Transform the color space from BGR to YUV420 IYUV (I420).
		CST_RGBA_TO_YUV_420_I420 = 129, // Transform the color space from RGBA to YUV420 IYUV (I420).
		CST_BGRA_TO_YUV_420_I420 = 130, // Transform the color space from BGRA to YUV420 IYUV (I420).
		CST_RGBA_TO_YUV_420_IYUV = 129, // Transform the color space from RGBA to YUV420 IYUV (I420).
		CST_BGRA_TO_YUV_420_IYUV = 130, // Transform the color space from BGRA to YUV420 IYUV (I420).
		CST_RGB_TO_YUV_420_YV12 = 131, // Transform the color space from RGB to YUV420 YV12 (P).
		CST_BGR_TO_YUV_420_YV12 = 132, // Transform the color space from BGR to YUV420 YV12 (P).
		CST_RGBA_TO_YUV_420_YV12 = 133, // Transform the color space from RGBA to YUV420 YV12 (P).
		CST_BGRA_TO_YUV_420_YV12 = 134, // Transform the color space from BGRA to YUV420 YV12 (P).
		CST_BAYER_RG_TO_BGR_EA = 135, // Transform the color space from BayerRG to BGR, using an Edge Aware algorithm.
		CST_BAYER_GR_TO_BGR_EA = 136, // Transform the color space from BayerGR to BGR, using an Edge Aware algorithm.
		CST_BAYER_BG_TO_BGR_EA = 137, // Transform the color space from BayerBG to BGR, using an Edge Aware algorithm.
		CST_BAYER_GB_TO_BGR_EA = 138, // Transform the color space from BayerGB to BGR, using an Edge Aware algorithm.
		CST_BAYER_RG_TO_RGB_EA = 137, // Transform the color space from BayerRG to RGB, using an Edge Aware algorithm.
		CST_BAYER_GR_TO_RGB_EA = 138, // Transform the color space from BayerGR to RGB, using an Edge Aware algorithm.
		CST_BAYER_BG_TO_RGB_EA = 135, // Transform the color space from BayerBG to RGB, using an Edge Aware algorithm.
		CST_BAYER_GB_TO_RGB_EA = 136, // Transform the color space from BayerGB to RGB, using an Edge Aware algorithm.
		CST_BAYER_RG_TO_BGRA = 139, // Transform the color space from BayerRG to BGRA.
		CST_BAYER_GR_TO_BGRA = 140, // Transform the color space from BayerGR to BGRA.
		CST_BAYER_BG_TO_BGRA = 141, // Transform the color space from BayerBG to BGRA.
		CST_BAYER_GB_TO_BGRA = 142, // Transform the color space from BayerGB to BGRA.
		CST_BAYER_RG_TO_RGBA = 141, // Transform the color space from BayerRG to RGBA.
		CST_BAYER_GR_TO_RGBA = 142, // Transform the color space from BayerGR to RGBA.
		CST_BAYER_BG_TO_RGBA = 139, // Transform the color space from BayerBG to RGBA.
		CST_BAYER_GB_TO_RGBA = 140, // Transform the color space from BayerGB to RGBA.
		CST_MAX = 143, // For internal use only, adapted when adding new values.
	};

	/// <summary>
	/// Offers color training methods.
	/// </summary>
	enum ETcVnColorTrainingMethod : LONG
	{
		CTM_LAB = 0, // Trains the color in CIE L*a*b* color space.
		CTM_RGB = 1, // Trains the color in RGB color space.
	};

	/// <summary>
	/// Offers connected components algorithms.
	/// </summary>
	enum ETcVnConnectedComponentsAlgorithm : LONG
	{
		CCA_WU = 0, // SAUF algorithm
		CCA_GRANA = 1, // BBDT algorithm for 8-way connectivity, SAUF algorithm for 4-way connectivity
	};

	/// <summary>
	/// Offers container export formats.
	/// </summary>
	enum ETcVnContainerExportFormat : USHORT
	{
		CEF_XML = 0, // XML format with human readable data
		CEF_XML_SERIALIZED = 1, // XML format with serialized data
		CEF_CSV = 2, // CSV format (limited to two dimensional representation, so not applicable for all container types)
		CEF_BINARY = 3, // Binary serialized data (recommended for large containers)
	};

	/// <summary>
	/// Offers methods for contour approximation.
	/// </summary>
	enum ETcVnContourApproximationMethod : LONG
	{
		CAM_NONE = 1, // No approximation, every single point is stored, i.e. two subsequent points are always direct neighbors (horizontal, vertical or diagonal).
		CAM_SIMPLE = 2, // Lossless compression of segments that form straight lines in horizontal, vertical or diagonal direction leaving only their endpoints (For instance, an up-right rectangle is reduced to its four corner points.)
		CAM_TC89_L1 = 3, // Compression using a Teh-Chin chain approximation algorithm (IEEE-paper C. Teh, R. Chin, On the Detection of Dominant Points on Digital Curves, 1989).
		CAM_TC89_KCOS = 4, // Compression using a Teh-Chin chain approximation algorithm (IEEE-paper C. Teh, R. Chin, On the Detection of Dominant Points on Digital Curves, 1989).
	};

	/// <summary>
	/// Offers retrieval modes for a contour search.
	/// </summary>
	enum ETcVnContourRetrievalMode : LONG
	{
		CRM_EXTERNAL = 0, // Returns only external contours.
		CRM_LIST = 1, // Returns all found contours, not considering their hierarchy.
		CRM_CONNECTED_COMPONENTS = 2, // Returns all contours with a 2-level hierarchy (External contours are assigned level 0, internal contours level 1).
		CRM_TREE = 3, // Returns all contours and their full hierarchy.
		CRM_FLOODFILL = 4, // Returns the found contours using a floodfill algorithm (only available for DINT images).
	};

	/// <summary>
	/// Offers comparison methods for contour matching.
	/// </summary>
	enum ETcVnContoursMatchComparisonMethod : LONG
	{
		CMCM_CONTOURS_MATCH_I1 = 1, // Contours are compared using the sum over the differences between the reciprocal individual characteristics.
		CMCM_CONTOURS_MATCH_I2 = 2, // Contours are compared using the sum over the differences between the individual characteristics.
		CMCM_CONTOURS_MATCH_I3 = 3, // Contours are compared using only the maximum difference between the individual characteristics.
	};

	/// <summary>
	/// Offers image data layouts.
	/// </summary>
	enum ETcVnDataLayout : ULONGLONG
	{
		DL_DEFAULT = 0x0, // Default
		DL_2D_HW = 0x12, // 2D data HW, multi/single channel image
		DL_2D_WH = 0x21, // 2D data WH, multi/single channel image
		DL_3D_CHW = 0x123, // 3D data CHW, single channel image
		DL_3D_HWC = 0x231, // 3D data HWC, single channel image
		DL_4D_NCHW = 0x1234, // 4D data NCHW, single channel image
		DL_4D_NHWC = 0x1342, // 4D data NHWC, single channel image
	};

	/// <summary>
	/// Offers Data Matrix code detection options.
	/// </summary>
	enum ETcVnDataMatrixOptions : ULONGLONG
	{
		DMO_DEFAULT = 0, // Expects a graylevel image as input. Applies an adaptive local threshold and creates a dynamic grid based on the clock pattern.
		DMO_BINARY_INPUT = 1, // Expects a binary image as input (all pixels must contain 0 or 255, disables internal preprocessing)
		DMO_GLOBAL_THRESHOLD = 2, // Applies a global instead of an adaptive local threshold (requires uniform illumination)
		DMO_BINARY_GRID = 4, // Create the dynamic grid based on the binary instead of the graylevel image
		DMO_STATIC_GRID = 8, // Use an equally spaced static grid instead of a dynamic one
		DMO_REGULAR_COLOR = 16, // Only search for regular color (dark code on light background)
		DMO_INVERTED_COLOR = 32, // Only search for inverted color (light code on dark background)
	};

	/// <summary>
	/// Offers diffusivity types for feature detection methods KAZE and AKAZE.
	/// </summary>
	enum ETcVnDiffusivityTypeKAZE : LONG
	{
		DT1_KAZE_PM_G1 = 0, // Uses the Perona-Malik diffusivity filter g1.
		DT1_KAZE_PM_G2 = 1, // Uses the Perona-Malik diffusivity filter g2.
		DT1_KAZE_WEICKERT = 2, // Uses the Weickert diffusivity filter.
		DT1_KAZE_CHARBONNIER = 3, // Uses the Charbonnier diffusivity filter.
	};

	/// <summary>
	/// Offers types of the label array to build.
	/// </summary>
	enum ETcVnDistanceTransformationLabel : LONG
	{
		DTL_CCOMP = 0, // Labels connected components (Each connected component of zeros in the source image and the pixels closest to the connected component will be assigned the same label).
		DTL_PIXEL = 1, // Labels pixels (Each zero pixel and the non-zero pixels closest to it get their own label).
	};

	/// <summary>
	/// Offers different sizes of the distance transformation mask. Please note, that some sizes are not supported by certain distance types.
	/// </summary>
	enum ETcVnDistanceTransformationMask : LONG
	{
		DTM_PRECISE = 0, // Uses a precise mask.
		DTM_3 = 3, // Uses a 3x3 mask.
		DTM_5 = 5, // Uses a 5x5 mask.
	};

	/// <summary>
	/// Offers distance types.
	/// </summary>
	enum ETcVnDistanceType : LONG
	{
		DT_USER = -1, // User defined distance
		DT_L1 = 1, // |x1 - x2| + |y1 - y2|
		DT_L2 = 2, // Euclidean distance
		DT_C = 3, // max(|x1 - x2|, |y1 - y2|)
		DT_L12 = 4, // L1 - L2 : 2*(sqrt(1 + x*x/2) - 1))
		DT_FAIR = 5, // c^2(|x|/c-log(1+|x|/c)), c = 1.3998
		DT_WELSCH = 6, // c^2/2(1-exp(-(x/c)^2)), c = 2.9846
		DT_HUBER = 7, // |x|<c ? x^2/2 : c(|x|-c/2), c=1.345
	};

	/// <summary>
	/// Offers a combination of flags to support overdrawing an existing destination image and/or skipping single (i.e. non-matched) keypoints and/or drawing additional (rich-)keypoint information (size and orientation). Used by F_VN_DrawKeypointsExp.
	/// </summary>
	enum ETcVnDrawMatchesFlags : LONG
	{
		DMF_DEFAULT = 0, // Draw all keypoints into a new image.
		DMF_OVERDRAW = 1, // Draw all keypoints into the existing destination image.
		DMF_SKIPSINGLE = 2, // Draw the keypoints into a new image but skip single keypoints.
		DMF_OVERDRAW_SKIPSINGLE = 3, // Draw the keypoints into the existing destination image but skip single keypoints.
		DMF_RICHKEYPOINT = 4, // Draw all keypoints with rich information into a new image.
		DMF_OVERDRAW_RICHKEYPOINT = 5, // Draw all keypoints with rich information into the existing destination image.
		DMF_SKIPSINGLE_RICHKEYPOINT = 6, // Draw the keypoints with rich information into a new image but skip single keypoints.
		DMF_OVERDRAW_SKIPSINGLE_RICHKEYPOINT = 7, // Draw the keypoints with rich information into the existing destination image but skip single keypoints.
	};

	/// <summary>
	/// Offers shapes to be drawn.
	/// </summary>
	enum ETcVnDrawShape : LONG
	{
		DS_RANDOM = -1, // Randomly select a circle, square, plus, X or diamond.
		DS_CIRCLE = 0, // Circle
		DS_SQUARE = 1, // Square
		DS_PLUS = 2, // +
		DS_X = 3, // x
		DS_DIAMOND = 4, // Diamond
		DS_MAX = 5, // For internal use only, adapted when adding new values.
	};

	/// <summary>
	/// Offers edge detection algorithms.
	/// </summary>
	enum ETcVnEdgeDetectionAlgorithm : LONG
	{
		EDA_INTERPOLATION = 0, // Interpolates pixels (bilinear) and then finds the maximum gradient. This approach is fast and stable, but usually less precise than the function approximation methods.
		EDA_APPROX_ERF = 1, // Approximates the edge with an erf function. This approach is slower than the interpolation method, but usually more precise. However, it can be inaccurate if the edge does not suit the erf model. 
		EDA_APPROX_GAUSSIAN = 2, // Approximates the edge with a gaussian function. This method is intended to find the center of relatively thin lines, so it is likely to be inaccurate for other edges.
	};

	/// <summary>
	/// Offers edge directions relative to the search direction.
	/// </summary>
	enum ETcVnEdgeDirection : LONG
	{
		ED_DARK_TO_LIGHT = 0, // Dark to light
		ED_LIGHT_TO_DARK = 1, // Light to dark
	};

	/// <summary>
	/// Offers element types.
	/// </summary>
	using ETcVnElementType = VN_ETcVnElementType;

	/// <summary>
	/// Offers estimation algorithms for matching point sets.
	/// </summary>
	enum ETcVnEstimationAlgorithm : LONG
	{
		EA_DEFAULT = 0, // Use all points.
		EA_LMEDS = 4, // Least Median of Squares
		EA_RANSAC = 8, // Random Sample Consensus
		EA_RHO = 16, // Progressive Sample Consensus
	};

	/// <summary>
	/// Offers search directions for the extreme point.
	/// </summary>
	enum ETcVnExtremePointDirection : LONG
	{
		EPD_TOP_LEFT = 0, // Find the topmost point (min y, take left one if more than 1).
		EPD_TOP_MEDIAN = 1, // Find the topmost point (min y, take median one if more than 1).
		EPD_TOP_RIGHT = 2, // Find the topmost point (min y, take right one if more than 1).
		EPD_BOTTOM_LEFT = 3, // Find the bottommost point (max y, take left one if more than 1).
		EPD_BOTTOM_MEDIAN = 4, // Find the bottommost point (max y, take median one if more than 1).
		EPD_BOTTOM_RIGHT = 5, // Find the bottommost point (max y, take right one if more than 1).
		EPD_LEFT_TOP = 6, // Find the leftmost point (min x, take top one if more than 1).
		EPD_LEFT_MEDIAN = 7, // Find the leftmost point (min x, take median one if more than 1).
		EPD_LEFT_BOTTOM = 8, // Find the leftmost point (min x, take bottom one if more than 1).
		EPD_RIGHT_TOP = 9, // Find the rightmost point (max x, take top one if more than 1).
		EPD_RIGHT_MEDIAN = 10, // Find the rightmost point (max x, take median one if more than 1).
		EPD_RIGHT_BOTTOM = 11, // Find the rightmost point (max x, take bottom one if more than 1).
	};

	/// <summary>
	/// Offers descriptor types for AKAZE method.
	/// </summary>
	enum ETcVnFeatureDescriptorTypeAKAZE : LONG
	{
		FDT_AKAZE_KAZE_UPRIGHT = 2, // KAZE descriptor (upright, i.e. rotation dependend).
		FDT_AKAZE_KAZE = 3, // KAZE descriptor (rotation invariant).
		FDT_AKAZE_MLDB_UPRIGHT = 4, // MLDB descriptor (upright, i.e. rotation dependend).
		FDT_AKAZE_MLDB = 5, // MLDB descriptor (rotation invariant).
	};

	/// <summary>
	/// Offers feature scaling types
	/// </summary>
	enum ETcVnFeatureScalingType : LONG
	{
		FST1_MAXABS = 0, // Use the max of the absolute values of the feature vector. The normlized values are in the range [-1 to 1] or [0 to 1] if all the original values are positive.
		FST1_MINMAX = 1, // Use the min and max values of the feature vector. The normlized values are in the range [0 to 1]
		FST1_STANDARDIZATION = 2, // Use the mean and the standard deviation of the feature vector. The normalized vector has a mean value equal to zero and standard deviation equal to one
	};

	/// <summary>
	/// Offers algorithms used to rank features.
	/// </summary>
	enum ETcVnFeatureScoreTypeORB : LONG
	{
		FST_ORB_HARRIS = 0, // Harris algorithm (produces more stable keypoints, but computation takes longer).
		FST_ORB_FAST = 1, // FAST algorithm (produces slightly less stable keypoints, but computation is faster).
	};

	/// <summary>
	/// Offers directions, in which to apply filter.
	/// </summary>
	enum ETcVnFilterDirection : SHORT
	{
		FD_X = 0, // X-direction
		FD_Y = 1, // Y-direction
	};

	/// <summary>
	/// Defines the axis around which to flip (mirror) the image.
	/// </summary>
	enum ETcVnFlipAxis : SHORT
	{
		FA_XY = -1, // Flip the image around both axes
		FA_X = 0, // Flip the image around the X axis
		FA_Y = 1, // Flip the image around the Y axis
	};

	/// <summary>
	/// Offers font types.
	/// </summary>
	enum ETcVnFontType : LONG
	{
		FT_HERSHEY_SIMPLEX = 0, // Normal size sans-serif font.
		FT_HERSHEY_PLAIN = 1, // Small size sans-serif font.
		FT_HERSHEY_DUPLEX = 2, // More complex normal size sans-serif font.
		FT_HERSHEY_COMPLEX = 3, // Normal size serif font.
		FT_HERSHEY_TRIPLEX = 4, // More complex normal size serif font.
		FT_HERSHEY_COMPLEX_SMALL = 5, // Small size serif font.
		FT_HERSHEY_SCRIPT_SIMPLEX = 6, // Hand-writing style font.
		FT_HERSHEY_SCRIPT_COMPLEX = 7, // More complex hand-writing style font.
		FT_HERSHEY_PLAIN_ITALIC = 17, // Small size sans-serif font (italic).
		FT_HERSHEY_COMPLEX_ITALIC = 19, // Normal size serif font (italic).
		FT_HERSHEY_TRIPLEX_ITALIC = 20, // More complex normal size serif font (italic).
		FT_HERSHEY_COMPLEX_SMALL_ITALIC = 21, // Small size serif font (italic).
	};

	/// <summary>
	/// Offers Hough methods.
	/// </summary>
	enum ETcVnHoughMethod : LONG
	{
		HM_STANDARD = 0, // Classical or standard Hough transform. Every line is represented by two floating-point numbers (f1, f2), where f1 is a distance between (0,0) origin and the line, and f2 is the angle between x-axis and the normal to the line.
		HM_PROBABILISTIC = 1, // Probabilistic Hough transform. More efficient for pictures containing long linear segments. Returns line segments rather than the whole line, while each segment is represented by start and end point.
		HM_MULTI_SCALE = 2, // Multi scale variant of classical Hough transform.
		HM_GRADIENT = 3, // Method designed to find circles. See paper: HK Yuen, John Princen, John Illingworth, and Josef Kittler. Comparative study of hough transform methods for circle finding. Image and Vision Computing, 8(1):7177, 1990
		HM_GRADIENT_ALT = 4, // Variation of the GRADIENT method.
	};

	/// <summary>
	/// Offers initializable functions.
	/// </summary>
	enum ETcVnInitializableFunction : LONG
	{
		IF_OCR = 0, // F_VN_OCR
		IF_CODEDETECTION = 1, // F_VN_CODEDETECTION
	};

	/// <summary>
	/// Offers interpolation types.
	/// </summary>
	enum ETcVnInterpolationType : LONG
	{
		IT_NEAREST_NEIGHBOR = 0, // Nearest neighbor interpolation
		IT_BILINEAR = 1, // Bilinear interpolation
		IT_BICUBIC = 2, // Bicubic interpolation
		IT_AREA_BASED = 3, // Area based interpolation
		IT_LANCZOS4 = 4, // Lanczos4 interpolation
	};

	/// <summary>
	/// Offers different neighborhood types for AGAST method (For details see paper: E. Mair et al.: Adaptive and Generic Corner Detection Based on the Accelerated Segment Test, 2010).
	/// </summary>
	enum ETcVnKeypointDetectionTypeAGAST : LONG
	{
		KDT_AGAST_5_8 = 0, // 5 of 8
		KDT_AGAST_7_12d = 1, // 7 of 12 diamond
		KDT_AGAST_7_12s = 2, // 7 of 12 square
		KDT_AGAST_9_16 = 3, // 9 of 16
	};

	/// <summary>
	/// Offers different neighborhood types for FAST method (For details see paper: E. Rosten: Machine Learning for High-speed Corner Detection, 2006).
	/// </summary>
	enum ETcVnKeypointDetectionTypeFAST : LONG
	{
		KDT_FAST_5_8 = 0, // 5 of 8
		KDT_FAST_7_12 = 1, // 7 of 12
		KDT_FAST_9_16 = 2, // 9 of 16
	};

	/// <summary>
	/// Offers kNN model types.
	/// </summary>
	enum ETcVnKnn : ULONG
	{
		KNN_CLASSIFIER = 1, // Classifier
		KNN_NOVELTY_DETECTOR = 2, // Novelty detector
		KNN_REGRESSOR = 4, // Regressor
	};

	/// <summary>
	/// Offer different types of neural network model layer names
	/// </summary>
	enum ETcVnLayerNameType : LONG
	{
		LNT_ALL = 0, // Return the name of all layers
		LNT_OUTPUTS = 1, // Return the names of unconnected output layers
		LNT_INPUTS = 2, // Return the names of model inputs
	};

	/// <summary>
	/// Offers line types.
	/// </summary>
	enum ETcVnLineType : LONG
	{
		LT_4_CONNECTED = 4, // 4-connected (pixels are connected horizontally and vertically).
		LT_8_CONNECTED = 8, // 8-connected (pixels are connected horizontally, vertically and diagonally).
		LT_ANTIALIASED = 16, // Antialiased (drawn using Gaussian filtering, only implemented for 8-bit images).
	};

	/// <summary>
	/// Offers morphological operators.
	/// </summary>
	enum ETcVnMorphologicalOperator : LONG
	{
		MO_EROSION = 0x0, // Shrinks objects (regions of foreground (i.e. white) pixels), removing regions smaller than the structuring element completely.
		MO_DILATION = 0x1, // Expands objects and thereby closes small holes inside objects.
		MO_OPENING = 0x2, // Applies an erosion first, a dilation second. Objects smaller than the structuring element are removed while outer shapes remain largely the same.
		MO_CLOSING = 0x3, // Applies a dilation first, an erosion second. Holes inside objects that fit into the structuring element are closed completely while outer shapes remain largely the same.
		MO_GRADIENT = 0x4, // Difference between the dilation and the erosion of an image.
		MO_WHITE_TOPHAT = 0x5, // Difference between an input image and its opening.
		MO_BLACK_TOPHAT = 0x6, // Difference between an input image and its closing.
		MO_OPENING_BY_RECONSTRUCTION = 0x40000002, // Opening with subsequent reconstruction of objects that were not removed by the opening.
		MO_CLOSING_BY_RECONSTRUCTION = 0x40000003, // Closing with subsequent reconstruction of objects that were not removed by the closing.
		MO_WHITE_TOPHAT_BY_RECONSTRUCTION = 0x40000005, // White tophat with subsequent reconstruction of objects that were not removed by the white tophat.
		MO_BLACK_TOPHAT_BY_RECONSTRUCTION = 0x40000006, // Black tophat with subsequent reconstruction of objects that were not removed by the black tophat.
	};

	/// <summary>
	/// Offers normal Bayes classifier types.
	/// </summary>
	enum ETcVnNbc : ULONG
	{
		NBC_CLASSIFIER = 1, // Classifier
		NBC_NOVELTY_DETECTOR = 2, // Novelty detector
	};

	/// <summary>
	/// Offers normalization types.
	/// </summary>
	enum ETcVnNormalizationType : LONG
	{
		NT_INF = 1, // Infinity norm
		NT_L1 = 2, // L1 norm
		NT_L2 = 4, // L2 (euclidean) norm
		NT_L2SQR = 5, // Squared L2 norm
		NT_HAMMING = 6, // Hamming distance (bitwise)
		NT_HAMMING2 = 7, // Hamming distance (each 2 bits combined to one)
		NT_RELATIVE_INF = 9, // Infinity norm (when comparing 2 arrays, the norm of their difference is divided by the norm of the second array)
		NT_RELATIVE_L1 = 10, // L1 norm (when comparing 2 arrays, the norm of their difference is divided by the norm of the second array)
		NT_RELATIVE_L2 = 12, // L2 (euclidean) norm (when comparing 2 arrays, the norm of their difference is divided by the norm of the second array)
		NT_RELATIVE_L2SQR = 13, // Squared L2 norm (when comparing 2 arrays, the norm of their difference is divided by the norm of the second array)
		NT_RELATIVE_HAMMING = 14, // Hamming distance (bitwise; when comparing 2 arrays, the norm of their difference is divided by the norm of the second array)
		NT_RELATIVE_HAMMING2 = 15, // Hamming distance (each 2 bits combined to one; when comparing 2 arrays, the norm of their difference is divided by the norm of the second array)
		NT_MINMAX = 32, // Normalize the values to a range given by a minimum and a maximum value.
	};

	/// <summary>
	/// Offers different OCR model types
	/// </summary>
	enum ETcVnOcrModelType : ULONGLONG
	{
		OMT_NUMBERS = 580542139465730, // Classify numbers
		OMT_NUMBERS_SC = 580542139465732, // Classify numbers and special characters
		OMT_UCLETTERS = 580542139465736, // Classify uppercase letters
		OMT_NUMBERS_SC_UCLETTERS = 580542139465744, // Classify numbers, special characters and uppercase letters
	};

	/// <summary>
	/// Provides different options to indicate whether certain actions must be performed to achieve the intended result.
	/// </summary>
	enum ETcVnOcrOptions : ULONG
	{
		OO_NONE = 0, // No options
		OO_WITHBLANKS = 1, // Indicates that if blanks were found, they should be included in the result. By default, all blanks are omitted from the result.
	};

	/// <summary>
	/// Offers methods to calculate the orientation of a set of points.
	/// </summary>
	enum ETcVnOrientationMethod : LONG
	{
		OM_PCA = 0, // Apply the PCA on the points and calculate the mean point as the center point and the rotation angle of the main principal axis
		OM_FITELLIPSE = 1, // Fit an ellipse around the points and calculate the center point and the rotation angle of the main axis
		OM_MOMENTS = 2, // Calculate the moments of the points and estimate the center and the rotation angle
		OM_ENCLOSINGRECT = 3, // Calculate a minimum area rectangle enclosing the points and calculate the center point and the rotation angle of the rectangle
	};

	/// <summary>
	/// Offers padding modes.
	/// </summary>
	enum ETcVnPaddingMode : LONG
	{
		PM_NONE = 0, // Resize the image to the desired size without extra processing
		PM_CROP_CENTER = 1, // Resize and crop the image
		PM_LETTERBOX = 2, // Resize the image to the desired size while preserving the aspect ratio of the original image
	};

	/// <summary>
	/// Offers pixel connectivities.
	/// </summary>
	enum ETcVnPixelConnectivity : LONG
	{
		PC_4 = 4, // 4-way
		PC_8 = 8, // 8-way
	};

	/// <summary>
	/// Offers pixel encodings.
	/// </summary>
	using ETcVnPixelEncoding = VN_ETcVnPixelEncoding;

	/// <summary>
	/// Offers pixel packing modes.
	/// </summary>
	using ETcVnPixelPackMode = VN_ETcVnPixelPackMode;

	/// <summary>
	/// Offers prototype clusterer model types.
	/// </summary>
	enum ETcVnPrototypeClusterer : ULONG
	{
		PC_NOVELTY_DETECTOR = 2, // Novelty detector
		PC_CLUSTERER = 8, // Clusterer
	};

	/// <summary>
	/// Offers rectangle intersection types.
	/// </summary>
	enum ETcVnRectangleIntersection : LONG
	{
		RI_NONE = 0, // No intersection
		RI_PARTIAL = 1, // Partial intersection
		RI_FULL = 2, // Full intersection
	};

	/// <summary>
	/// Offers reduction types.
	/// </summary>
	enum ETcVnReduceType : LONG
	{
		RT_REDUCE_SUM = 0, // The sum (column/row-wise) of all rows/columns
		RT_REDUCE_AVG = 1, // The mean (column/row-wise) of all rows/columns
		RT_REDUCE_MAX = 2, // The maximum (column/row-wise) of all rows/columns
		RT_REDUCE_MIN = 3, // The minimum (column/row-wise) of all rows/columns
	};

	/// <summary>
	/// Offers rotation angles.
	/// </summary>
	enum ETcVnRotationAngle : LONG
	{
		RA_90_DEG = 0, // 90 degrees
		RA_180_DEG = 1, // 180 degrees
		RA_270_DEG = 2, // 270 degrees
	};

	/// <summary>
	/// Offers RTrees model types.
	/// </summary>
	enum ETcVnRTrees : ULONG
	{
		RT_CLASSIFIER = 1, // Classifier
		RT_REGRESSOR = 4, // Regressor
	};

	/// <summary>
	/// Offers options for normalizing images with signed data types.
	/// </summary>
	enum ETcVnSignedNormalization : SHORT
	{
		SN_FIX_ZERO = 0, // The value 0 is fixed, i.e. the normalized image might only reach either the minimum or maximum value.
		SN_FULL_SCALE = 1, // The image is normalized to the full value range, i.e. a prior value of 0 might be != 0 after normalization.
	};

	/// <summary>
	/// Offers SolvePnP methods.
	/// </summary>
	enum ETcVnSolvePnPMethod : LONG
	{
		SPM_ITERATIVE = 0, // Levenberg-Marquardt optimization. Requires at least 4 planar or 6 non-planar reference points.
		SPM_EPNP = 1, // Efficient perspective-n-point camera pose estimation. Requires at least 4 reference points.
		SPM_P3P = 2, // Complete solution classification for the perspective-three-point problem. Requires exactly 4 reference points to find a unique solution.
		SPM_AP3P = 5, // An efficient algebraic solution to the perspective-three-point problem. Requires exactly 4 reference points to find a unique solution.
		SPM_IPPE = 6, // Infinitesimal plane-based pose estimation. Requires at least 4 coplanar reference points.
		SPM_IPPE_SQUARE = 7, // IPPE specialization for squares. Requires exactly 4 reference points in the following order (hsl: half square length): (-hsl, hsl, 0), (hsl, hsl, 0), (hsl, -hsl, 0), (-hsl, -hsl, 0)
		SPM_SQPNP = 8, // A consistently fast and globally optimal solution to the perspective-n-point problem. Requires at least 4 reference points.
	};

	/// <summary>
	/// Offers Simplified TopoART model types.
	/// </summary>
	enum ETcVnSta : ULONG
	{
		STA_CLASSIFIER = 1, // Classifier
		STA_NOVELTY_DETECTOR = 2, // Novelty detector
		STA_REGRESSOR = 4, // Regressor
		STA_CLUSTERER = 8, // Clusterer
	};

	/// <summary>
	/// Offers shapes for a structuring element.
	/// </summary>
	enum ETcVnStructuringElementShape : LONG
	{
		SES_RECTANGLE = 0, // Rectangle
		SES_CROSS = 1, // Cross
		SES_ELLIPSE = 2, // Ellipse
	};

	/// <summary>
	/// Offers SVM model types.
	/// </summary>
	enum ETcVnSvm : ULONG
	{
		SVM_C_CLASSIFIER = 1, // Classifier
		SVM_NU_CLASSIFIER = 65537, // Classifier
		SVM_NOVELTY_DETECTOR = 2, // Novelty detector
		SVM_EPS_REGRESSOR = 4, // Regressor
		SVM_NU_REGRESSOR = 65540, // Regressor
	};

	/// <summary>
	/// Offers SVM kernel types.
	/// </summary>
	enum ETcVnSvmKernelType : LONG
	{
		SKT_LINEAR = 0, // Linear kernel (fast)
		SKT_POLY = 1, // Polynomial kernel
		SKT_RBF = 2, // Radial basis function (RBF) kernel (good default)
		SKT_SIGMOID = 3, // Sigmoid kernel
		SKT_CHI2 = 4, // Chi-squared kernel
		SKT_INTER = 5, // Histogram intersection kernel
	};

	/// <summary>
	/// Offers different margin types for SVMSGD classifiers.
	/// </summary>
	enum ETcVnSvmSgdClassifierMarginType : LONG
	{
		SSCMT_SOFT_MARGIN = 0, // Soft margin allowing outliers. (beneficial for classes that cannot be separated linearly)
		SSCMT_HARD_MARGIN = 1, // Hard margin. (best-suited for linearly separable classes)
	};

	/// <summary>
	/// Offers different types of SVMSGD classifiers.
	/// </summary>
	enum ETcVnSvmSgdClassifierType : LONG
	{
		SSCT_SGD = 0, // Stochastic Gradient Descent
		SSCT_ASGD = 1, // Average Stochastic Gradient Descent
	};

	/// <summary>
	/// Offers methods for template matching.
	/// </summary>
	enum ETcVnTemplateMatchMethod : LONG
	{
		TMM_SQDIFF = 0, // Squared difference (supports template mask)
		TMM_SQDIFF_NORMED = 1, // Normalized squared difference
		TMM_CCORR = 2, // Cross-correlation
		TMM_CCORR_NORMED = 3, // Normalized cross-correlation (supports template mask)
		TMM_CCOEFF = 4, // Correlation coefficient
		TMM_CCOEFF_NORMED = 5, // Normalized correlation coefficient
	};

	/// <summary>
	/// Offers threshold types.
	/// </summary>
	enum ETcVnThresholdType : LONG
	{
		TT_BINARY = 0, // Binary threshold
		TT_BINARY_INV = 1, // Inverted binary threshold
		TT_TRUNC = 2, // Truncated threshold (pixels > thresh are set to thresh, others keep their value)
		TT_TOZERO = 3, // To zero threshold (pixels < thresh are set to zero, others keep their value)
		TT_TOZERO_INV = 4, // Inverted to zero threshold (pixels > thresh are set to zero, others keep their value)
		TT_OTSU_BINARY = 8, // Binary threshold with the threshold value selected according to the Otsu algorithm
		TT_OTSU_BINARY_INV = 9, // Inverted binary threshold with the threshold value selected according to the Otsu algorithm
		TT_OTSU_TRUNC = 10, // Truncated threshold with the threshold value selected according to the Otsu algorithm
		TT_OTSU_TOZERO = 11, // To zero threshold with the threshold value selected according to the Otsu algorithm
		TT_OTSU_TOZERO_INV = 12, // Inverted to zero threshold with the threshold value selected according to the Otsu algorithm
		TT_TRIANGLE_BINARY = 16, // Binary threshold with the threshold value selected according to the Triangle algorithm
		TT_TRIANGLE_BINARY_INV = 17, // Inverted binary threshold with the threshold value selected according to the Triangle algorithm
		TT_TRIANGLE_TRUNC = 18, // Truncated threshold with the threshold value selected according to the Triangle algorithm
		TT_TRIANGLE_TOZERO = 19, // To zero threshold with the threshold value selected according to the Triangle algorithm
		TT_TRIANGLE_TOZERO_INV = 20, // Inverted to zero threshold with the threshold value selected according to the Triangle algorithm
	};

	/// <summary>
	/// Offers image acquisition timestamps.
	/// </summary>
	enum ETcVnTimestamp : ULONGLONG
	{
		TS_IMAGE_COMPLETED = 1, // Timestamp when the image was completed, i.e. all packets were received by the GigEVision driver.
	};

	/// <summary>
	/// Offers methods for vector comparison.
	/// </summary>
	enum ETcVnVectorCompareMethod : LONG
	{
		VCM_EUCLIDEAN = 0, // Euclidean
		VCM_ELEMENTWISE = 1, // Elementwise
	};

	/// <summary>
	/// Offers world coordinate system orientations.
	/// </summary>
	enum ETcVnWorldCoordinateSystem : LONG
	{
		WCS_X_RIGHT_Y_DOWN = 0, // X axis points right, Y axis down (same orientation as image coordinate system)
		WCS_X_DOWN_Y_RIGHT = 1, // X axis points down, Y axis right
		WCS_X_LEFT_Y_DOWN = 2, // X axis points left, Y axis down
		WCS_X_UP_Y_RIGHT = 3, // X axis points up, Y axis right
		WCS_X_RIGHT_Y_UP = 4, // X axis points right, Y axis up
		WCS_X_DOWN_Y_LEFT = 5, // X axis points down, Y axis left
		WCS_X_LEFT_Y_UP = 6, // X axis points left, Y axis up
		WCS_X_UP_Y_LEFT = 7, // X axis points up, Y axis left
	};

	/// <summary>
	/// Offers camera calibration options.
	/// </summary>
	using TcVnCameraCalibrationOptions = VN_TcVnCameraCalibrationOptions;

	/// <summary>
	/// Describes a circular arc.
	/// </summary>
	using TcVnCircularArc = VN_TcVnCircularArc;

	/// <summary>
	/// Describes code quality grades for 1D barcodes according to ISO / IEC 15416:2016. The grades range from 0 (very bad) to 4 (very good) and are averaged over several scan lines.
	/// </summary>
	struct TcVnCodeGrades1D
	{
		float fDecode; // Decode grade
		float fSymbolContrast; // Symbol contrast grade
		float fMinReflectance; // Minimum reflectance grade
		float fMinEdgeContrast; // Minimum edge contrast grade
		float fModulation; // Modulation grade
		float fDefects; // Defects grade
		float fDecodability; // Decodability grade
		float fOverall; // Overall code grade, i.e. the minimum achieved individual grade averaged over all scan lines. If different scan lines lead to different decoded data, the overall grade is 0.
	};

	static_assert(sizeof(TcVnCodeGrades1D) == 32);

	/// <summary>
	/// Describes code quality grades for Data Matrix codes according to ISO / IEC 15415:2011. The grades range from 0 (very bad) to 4 (very good).
	/// </summary>
	struct TcVnCodeGradesDM
	{
		unsigned char nDecode; // Decode grade
		unsigned char nSymbolContrast; // Symbol contrast grade
		unsigned char nModulation; // Modulation grade
		unsigned char nReflectanceMargin; // Reflectance margin grade
		unsigned char nFixedPatternDamage; // Fixed pattern damage grade
		unsigned char nAxialNonuniformity; // Axial nonuniformity grade
		unsigned char nGridNonuniformity; // Grid nonuniformity grade
		unsigned char nUnusedErrorCorrection; // Unused error correction grade
		unsigned char nOverall; // Overall code grade, i.e. the minimum achieved individual grade
	};

	static_assert(sizeof(TcVnCodeGradesDM) == 9);

	/// <summary>
	/// Describes code quality grades for QR codes according to ISO / IEC 15415:2011. The grades range from 0 (very bad) to 4 (very good).
	/// </summary>
	struct TcVnCodeGradesQR
	{
		unsigned char nDecode; // Decode grade
		unsigned char nSymbolContrast; // Symbol contrast grade
		unsigned char nModulation; // Modulation grade
		unsigned char nReflectanceMargin; // Reflectance margin grade
		unsigned char nFixedPatternDamage; // Fixed pattern damage grade
		unsigned char nAxialNonuniformity; // Axial nonuniformity grade
		unsigned char nGridNonuniformity; // Grid nonuniformity grade
		unsigned char nUnusedErrorCorrection; // Unused error correction grade
		unsigned char nFormatInfo; // Format information grade
		unsigned char nVersionInfo; // Version information grade
		unsigned char nOverall; // Overall code grade, i.e. the minimum achieved individual grade
	};

	static_assert(sizeof(TcVnCodeGradesQR) == 11);

	/// <summary>
	/// Describes a descriptor match
	/// </summary>
	using TcVnDMatch = VN_TcVnDMatch;

	/// <summary>
	/// Shows image information.
	/// </summary>
	using TcVnImageInfo = VN_TcVnImageInfo;

	/// <summary>
	/// Describes a key point.
	/// </summary>
	using TcVnKeyPoint = VN_TcVnKeyPoint;

	/// <summary>
	/// Offers a user-defined matrix with variable rows, columns and element-type.
	/// </summary>
	using TcVnMatrix = VN_TcVnMatrix;

	/// <summary>
	/// Offers image or contour moments.
	/// </summary>
	using TcVnMoments = VN_TcVnMoments;

	/// <summary>
	/// Offers parameters for AGAST method.
	/// </summary>
	struct TcVnParamsAGAST
	{
		LONG nThreshold = 10; // Threshold for the intensity difference between the center pixel and its surrounding circle
		bool bNonMaxSuppression = true; // If true, non-maximum suppression is applied.
	private:
		UCHAR reserved1[3];
	public:
		ETcVnKeypointDetectionTypeAGAST eType = KDT_AGAST_9_16; // Neighborhood type

		TcVnParamsAGAST() { }
		TcVnParamsAGAST(LONG nThreshold, bool bNonMaxSuppression, ETcVnKeypointDetectionTypeAGAST eType) : nThreshold(nThreshold), bNonMaxSuppression(bNonMaxSuppression), eType(eType) { }
	};

	static_assert(sizeof(TcVnParamsAGAST) == 12);

	/// <summary>
	/// Offers parameters for AKAZE method.
	/// </summary>
	struct TcVnParamsAKAZE
	{
		ETcVnFeatureDescriptorTypeAKAZE eDescrType = FDT_AKAZE_MLDB; // Type of the descriptor
		ULONG nDescrSize = 0; // Size of the descriptor in bits (only for MLDB; 0 = full size)
		ULONG nDescrChannels = 3; // Number of descriptor channels (currently only 3 supported for MLDB)
		float fThreshold = 0.001f; // Detector response threshold
		ULONG nOctaves = 2; // Maximum octave evolution
		ULONG nOctaveLayers = 1; // Number of sublevels per scale level
		ETcVnDiffusivityTypeKAZE eDiffusivity = DT1_KAZE_PM_G2; // Diffusivity type
	};

	static_assert(sizeof(TcVnParamsAKAZE) == 28);

	/// <summary>
	/// Offers parameters for blob detection
	/// </summary>
	struct TcVnParamsBlobDetection
	{
		bool bFilterByArea = true; // Enable filtering by area (fMinArea <= area <= fMaxArea); strongly recommended to activate for filtering noise with fMinArea.
		bool bFilterByCircularity = false; // Enable filtering by circularity (fMinCircularity <= circularity(4pi * area / perimeter^2) <= fMaxCircularity).
		bool bFilterByConvexity = false; // Enable filtering by convexity (fMinConvexity <= convexity(area / hullArea) <= fMaxConvexity).
		bool bFilterByEccentricity = false; // Enable filtering by eccentricity (fMinEccentricity <= eccentricity <= fMaxEccentricity).
		bool bFilterByInertiaRatio = false; // Enable filtering by inertia ratio (fMinInertiaRatio <= inertia ratio <= fMaxInertiaRatio).
	private:
		UCHAR reserved1[3];
	public:
		float fMinArea = 10; // Min estimated blob area in pixel
		float fMaxArea = 100000000; // Max estimated blob area in pixel
		float fMinCircularity = 0; // Min circularity (1.0: ideal circle, < 1: less circular, 0: not circular at all)
		float fMaxCircularity = 1; // Max circularity (1.0: ideal circle, < 1: less circular, 0: not circular at all)
		float fMinConvexity = 0; // Min convexity (1.0: blob fully convex, < 1: less convex)
		float fMaxConvexity = 1; // Max convexity (1.0: blob fully convex, < 1: less convex)
		float fMinEccentricity = 0; // Min eccentricity (0.0: circular, 1.0: linear)
		float fMaxEccentricity = 1; // Max eccentricity (0.0: circular, 1.0: linear)
		float fMinInertiaRatio = 0; // Min inertia ratio (1.0: equal width and height, 0.0: linear)
		float fMaxInertiaRatio = 1; // Max inertia ratio (1.0: equal width and height, 0.0: linear)
		ETcVnThresholdType eThresholdType = TT_BINARY; // Threshold type for internally applied threshold method (OTSU_XXX only supported for USINT images).
		float fMinThreshold = 30; // Threshold to start with (if fThresholdStep > 0, otherwise this is the only threshold used).
		float fMaxThreshold = 225; // Threshold to end with (if fThresholdStep > 0, otherwise this value is not used).
		float fThresholdStep = 0; // Sets to 0 if only 1 threshold should be used (much faster than multiple thresholds and combining the results).
		float fMinBlobDistance = 5; // Minimum distance between the center points of two different blobs (only used if fThresholdStep > 0; if distance < fMinBlobDistance, the blobs are treated as the same).
		ULONG nMinRepeatability = 2; // Minimum number of threshold steps, for which the same contour has to be detected (only used if fThresholdStep > 0; same means center point distance < fMinBlobDistance).
		ETcVnBlobCombination eBlobCombination = BC_MEDIAN_THRESHOLD; // Selects, which of the multi-threshold blob contours should be returned.
		bool bExcludeBorderBlobs = false; // If true, blobs touching the image border are excluded from the results.

		TcVnParamsBlobDetection() { }
		TcVnParamsBlobDetection(bool bFilterByArea, bool bFilterByCircularity, bool bFilterByConvexity, bool bFilterByEccentricity, bool bFilterByInertiaRatio, float fMinArea, float fMaxArea, float fMinCircularity, float fMaxCircularity, float fMinConvexity, float fMaxConvexity, float fMinEccentricity, float fMaxEccentricity, float fMinInertiaRatio, float fMaxInertiaRatio, ETcVnThresholdType eThresholdType, float fMinThreshold, float fMaxThreshold, float fThresholdStep, float fMinBlobDistance, ULONG nMinRepeatability, ETcVnBlobCombination eBlobCombination, bool bExcludeBorderBlobs) : bFilterByArea(bFilterByArea), bFilterByCircularity(bFilterByCircularity), bFilterByConvexity(bFilterByConvexity), bFilterByEccentricity(bFilterByEccentricity), bFilterByInertiaRatio(bFilterByInertiaRatio), fMinArea(fMinArea), fMaxArea(fMaxArea), fMinCircularity(fMinCircularity), fMaxCircularity(fMaxCircularity), fMinConvexity(fMinConvexity), fMaxConvexity(fMaxConvexity), fMinEccentricity(fMinEccentricity), fMaxEccentricity(fMaxEccentricity), fMinInertiaRatio(fMinInertiaRatio), fMaxInertiaRatio(fMaxInertiaRatio), eThresholdType(eThresholdType), fMinThreshold(fMinThreshold), fMaxThreshold(fMaxThreshold), fThresholdStep(fThresholdStep), fMinBlobDistance(fMinBlobDistance), nMinRepeatability(nMinRepeatability), eBlobCombination(eBlobCombination), bExcludeBorderBlobs(bExcludeBorderBlobs) { }
	};

	static_assert(sizeof(TcVnParamsBlobDetection) == 80);

	/// <summary>
	/// Offers parameters for BRISK method.
	/// </summary>
	struct TcVnParamsBRISK
	{
		LONG nThreshold = 30; // Detection threshold
		ULONG nOctaves = 3; // Detection octaves (0 for single scale)
		float fPatternScale = 1; // Scale factor for the neighborhood pattern
	};

	static_assert(sizeof(TcVnParamsBRISK) == 12);

	/// <summary>
	/// Offers parameters for FAST method.
	/// </summary>
	struct TcVnParamsFAST
	{
		LONG nThreshold = 10; // Threshold for the intensity difference between the center pixel and its surrounding circle
		bool bNonMaxSuppression = true; // If true, non-maximum suppression is applied.
	private:
		UCHAR reserved1[3];
	public:
		ETcVnKeypointDetectionTypeFAST eType = KDT_FAST_9_16; // Neighborhood type

		TcVnParamsFAST() { }
		TcVnParamsFAST(LONG nThreshold, bool bNonMaxSuppression, ETcVnKeypointDetectionTypeFAST eType) : nThreshold(nThreshold), bNonMaxSuppression(bNonMaxSuppression), eType(eType) { }
	};

	static_assert(sizeof(TcVnParamsFAST) == 12);

	/// <summary>
	/// Offers parameters for GFTT method.
	/// </summary>
	struct TcVnParamsGFTT
	{
		ULONG nMaxCorners = 1000; // Maximum number of corners to return (strongest ones)
	private:
		UCHAR reserved1[4];
	public:
		double fQualityLevel = 0.01; // Minimum accepted corner quality, relative to the strongest one
		double fMinDistance = 1; // Minimum euclidean distance between returned keypoints
		ULONG nBlockSize = 3; // Neighborhood block size
		bool bUseHarrisDetector = false; // If true, a Harris detector is used instead of the default method.
	private:
		UCHAR reserved2[3];
	public:
		double fHarrisK = 0.04; // Free parameter of the Harris detector

		TcVnParamsGFTT() { }
		TcVnParamsGFTT(ULONG nMaxCorners, double fQualityLevel, double fMinDistance, ULONG nBlockSize, bool bUseHarrisDetector, double fHarrisK) : nMaxCorners(nMaxCorners), fQualityLevel(fQualityLevel), fMinDistance(fMinDistance), nBlockSize(nBlockSize), bUseHarrisDetector(bUseHarrisDetector), fHarrisK(fHarrisK) { }
	};

	static_assert(sizeof(TcVnParamsGFTT) == 40);

	/// <summary>
	/// Offers parameters for KAZE method
	/// </summary>
	struct TcVnParamsKAZE
	{
		bool bExtended = false; // If true, the descriptor size is extended from the default 64 byte to 128 byte.
		bool bUpright = false; // If true, upright (rotation dependent) descriptors are computed.
	private:
		UCHAR reserved1[2];
	public:
		float fThreshold = 0.001f; // Detector response threshold
		ULONG nOctaves = 4; // Maximum octave evolution of the image
		ULONG nOctaveLayers = 2; // Number of sublevels per scale level
		ETcVnDiffusivityTypeKAZE eDiffusivity = DT1_KAZE_PM_G2; // Diffusivity type

		TcVnParamsKAZE() { }
		TcVnParamsKAZE(bool bExtended, bool bUpright, float fThreshold, ULONG nOctaves, ULONG nOctaveLayers, ETcVnDiffusivityTypeKAZE eDiffusivity) : bExtended(bExtended), bUpright(bUpright), fThreshold(fThreshold), nOctaves(nOctaves), nOctaveLayers(nOctaveLayers), eDiffusivity(eDiffusivity) { }
	};

	static_assert(sizeof(TcVnParamsKAZE) == 20);

	/// <summary>
	/// Offers parameters for MSER method
	/// </summary>
	struct TcVnParamsMSER
	{
		LONG nDelta = 5; // Delta for size comparison
		ULONG nMinArea = 60; // Minimum blob size
		ULONG nMaxArea = 14400; // Maximum blob size
	private:
		UCHAR reserved1[4];
	public:
		double fMaxVariation = 0.25; // Maximum blob size variation
		double fMinDiversity = 0.2; // Minimum MSER diversity
		ULONG nMaxEvolution = 200; // Maximum evolution steps (only used for color images)
	private:
		UCHAR reserved2[4];
	public:
		double fAreaThreshold = 1.01; // Area threshold to cause re-initialization (only used for color images)
		double fMinMargin = 0.003; // Minimum margin (only used for color images)
		ULONG nEdgeBlurSize = 5; // Aperture size for edge bluring (only used for color images)

		TcVnParamsMSER() { }
		TcVnParamsMSER(LONG nDelta, ULONG nMinArea, ULONG nMaxArea, double fMaxVariation, double fMinDiversity, ULONG nMaxEvolution, double fAreaThreshold, double fMinMargin, ULONG nEdgeBlurSize) : nDelta(nDelta), nMinArea(nMinArea), nMaxArea(nMaxArea), fMaxVariation(fMaxVariation), fMinDiversity(fMinDiversity), nMaxEvolution(nMaxEvolution), fAreaThreshold(fAreaThreshold), fMinMargin(fMinMargin), nEdgeBlurSize(nEdgeBlurSize) { }
	};

	static_assert(sizeof(TcVnParamsMSER) == 64);

	/// <summary>
	/// Offers parameters for ORB method.
	/// </summary>
	struct TcVnParamsORB
	{
		ULONG nMaxPoints = 500; // Maximum number of returned keypoints
		float fPyramidScale = 1.2f; // Pyramid decimation ratio (must be greater than 1, should be smaller than 2)
		ULONG nPyramidLevels = 8; // Number of pyramid levels
		ULONG nEdgeThreshold = 31; // Size of the border, where no features are detected (should match nPatchSize)
		ULONG nFirstLevel = 0; // First pyramid level (currently, only 0 is supported)
		ULONG nBriefPoints = 2; // Number of points to produce each BRIEF descriptor element (2, 3, 4)
		ETcVnFeatureScoreTypeORB eScoreType = FST_ORB_HARRIS; // Score type (HARRIS is more stable but slightly slower than FAST)
		ULONG nPatchSize = 31; // Patch size of the BRIEF descriptor
		LONG nFastThreshold = 20; // Threshold for the FAST keypoint detection
	};

	static_assert(sizeof(TcVnParamsORB) == 36);

	/// <summary>
	/// Offers parameters for SB method (a simple blob detector with multiple thresholds).
	/// </summary>
	struct TcVnParamsSB
	{
		bool bFilterByArea = true; // Enable filtering by area (fMinArea <= area < fMaxArea).
		bool bFilterByCircularity = false; // Enable filtering by circularity (fMinCircularity <= circularity(4pi * area / perimeter^2) < fMaxCircularity).
		bool bFilterByColor = false; // Enable filtering by color (thresholdedColor(0 or 255) = nBlobColor).
		bool bFilterByConvexity = false; // Enable filtering by convexity (fMinConvexity <= convexity(area / hullArea) < fMaxConvexity).
		bool bFilterByInertia = false; // Enable filtering by inertia ratio (fMinInertiaRatio <= inertia ratio < fMaxInertiaRatio).
	private:
		UCHAR reserved1[3];
	public:
		float fMinArea = 25; // Min estimated blob area in pixel
		float fMaxArea = 15000; // Max estimated blob area in pixel
		float fMinCircularity = 0; // Min circularity (1.0: ideal circle, < 1: less circular, 0: not circular at all)
		float fMaxCircularity = 1; // Max circularity (1.0: ideal circle, < 1: less circular, 0: not circular at all)
		unsigned char nBlobColor = 255; // 0 or 255
	private:
		UCHAR reserved2[3];
	public:
		float fMinConvexity = 0; // Min convexity (1.0: blob fully convex, < 1: less convex)
		float fMaxConvexity = 1; // Max convexity (1.0: blob fully convex, < 1: less convex)
		float fMinInertiaRatio = 0; // Min inertia ratio (0.0 .. 1.0)
		float fMaxInertiaRatio = 1; // Max inertia ratio (0.0 .. 1.0)
		float fMinBlobDist = 5; // Min distance between different blobs
		ULONG nMinRepeatability = 2; // Min number of same detected blobs (dist < fMinBlobDist) in different thresholds
		float fMinThreshold = 30; // Min threshold (start)
		float fMaxThreshold = 225; // Max threshold (stop)
		float fThresholdStep = 10; // Threshold step between min and max threshold

		TcVnParamsSB() { }
		TcVnParamsSB(bool bFilterByArea, bool bFilterByCircularity, bool bFilterByColor, bool bFilterByConvexity, bool bFilterByInertia, float fMinArea, float fMaxArea, float fMinCircularity, float fMaxCircularity, unsigned char nBlobColor, float fMinConvexity, float fMaxConvexity, float fMinInertiaRatio, float fMaxInertiaRatio, float fMinBlobDist, ULONG nMinRepeatability, float fMinThreshold, float fMaxThreshold, float fThresholdStep) : bFilterByArea(bFilterByArea), bFilterByCircularity(bFilterByCircularity), bFilterByColor(bFilterByColor), bFilterByConvexity(bFilterByConvexity), bFilterByInertia(bFilterByInertia), fMinArea(fMinArea), fMaxArea(fMaxArea), fMinCircularity(fMinCircularity), fMaxCircularity(fMaxCircularity), nBlobColor(nBlobColor), fMinConvexity(fMinConvexity), fMaxConvexity(fMaxConvexity), fMinInertiaRatio(fMinInertiaRatio), fMaxInertiaRatio(fMaxInertiaRatio), fMinBlobDist(fMinBlobDist), nMinRepeatability(nMinRepeatability), fMinThreshold(fMinThreshold), fMaxThreshold(fMaxThreshold), fThresholdStep(fThresholdStep) { }
	};

	static_assert(sizeof(TcVnParamsSB) == 64);

	/// <summary>
	/// Contains detailed information about the pixel format.
	/// </summary>
	using TcVnPixelFormat = VN_TcVnPixelFormat;

	/// <summary>
	/// Contains origin and size of a rectangle.
	/// </summary>
	using TcVnRectangle_DINT = VN_TcVnRectangle_DINT;

	/// <summary>
	/// Contains origin and size of a rectangle.
	/// </summary>
	using TcVnRectangle_UDINT = VN_TcVnRectangle_UDINT;

	/// <summary>
	/// Contains center, size and angle of a rotated rectangle.
	/// </summary>
	using TcVnRotatedRectangle = VN_TcVnRotatedRectangle;

	/// <summary>
	/// Contains width and height.
	/// </summary>
	using TcVnSize2_REAL = VN_TcVnSize2_REAL;

	/// <summary>
	/// Contains origin and size of a rectangle.
	/// </summary>
	using TcVnRectangle = VN_TcVnRectangle;

	/// <summary>
	/// Ten-element array of type ITcVnImage.
	/// </summary>
	using TcVnArray10_ITcVnImage = VN_TcVnArray10_ITcVnImage;
	/// <summary>
	/// Three-dimensional array of element-type Point2_REAL.
	/// </summary>
	using TcVnArray3_Point2_REAL = VN_TcVnArray3_Point2_REAL;
	/// <summary>
	/// 33-dimensional array of element-type UDINT.
	/// </summary>
	using TcVnArray33_UDINT = VN_TcVnArray33_UDINT;
	/// <summary>
	/// Four-dimensional array of element-type LREAL.
	/// </summary>
	using TcVnArray4_LREAL = VN_TcVnArray4_LREAL;
	/// <summary>
	/// Four-dimensional array of element-type Point2_REAL.
	/// </summary>
	using TcVnArray4_Point2_REAL = VN_TcVnArray4_Point2_REAL;
	/// <summary>
	/// Seven-dimensional array of element-type LREAL.
	/// </summary>
	using TcVnArray7_LREAL = VN_TcVnArray7_LREAL;
	/// <summary>
	/// Eight-dimensional array of element-type LREAL.
	/// </summary>
	using TcVnArray8_LREAL = VN_TcVnArray8_LREAL;
	/// <summary>
	/// 2x3 matrix of type LREAL
	/// </summary>
	using TcVnMatrix2x3_LREAL = VN_TcVnMatrix2x3_LREAL;
	/// <summary>
	/// 3x3 matrix of type LREAL.
	/// </summary>
	using TcVnMatrix3x3_LREAL = VN_TcVnMatrix3x3_LREAL;

	/// <summary>
	/// Offers an interface for custom, elementwise container operations (for containers of containers) with up to 3 different containers.
	/// </summary>
	struct __declspec(novtable) ITcVnCustomContainerOperation_ITcVnContainer
	{
		/// <summary>
		/// Executes the custom operation on the container elements.
		/// </summary>
		/// <param name="ipElement1">Current element of the 1st container.</param>
		/// <param name="ipElement2">Current element of the 2nd container.</param>
		/// <param name="ipElement3">Current element of the 3rd container.</param>
		/// <returns>HRESULT</returns>
		virtual HRESULT TCOMAPI Execute(ITcVnContainer* ipElement1, ITcVnContainer* ipElement2, ITcVnContainer* ipElement3) = 0;
	};

	/// <summary>
	/// Offers an interface for custom, elementwise container operations with up to 3 different containers.
	/// </summary>
	struct __declspec(novtable) ITcVnCustomContainerOperation_ITcVnForwardIterator
	{
		/// <summary>
		/// Executes the custom operation on the container elements.
		/// </summary>
		/// <param name="ipElement1">Current element of the 1st container.</param>
		/// <param name="ipElement2">Current element of the 2nd container.</param>
		/// <param name="ipElement3">Current element of the 3rd container.</param>
		/// <returns>HRESULT</returns>
		virtual HRESULT TCOMAPI Execute(ITcVnForwardIterator* ipElement1, ITcVnForwardIterator* ipElement2, ITcVnForwardIterator* ipElement3) = 0;
	};

	/// <summary>
	/// Offers an interface for a custom condition computed for a container.
	/// </summary>
	struct __declspec(novtable) ITcVnCustomElementCondition_ITcVnContainer
	{
		/// <summary>
		/// Evaluates the condition for the container.
		/// </summary>
		/// <param name="ipElement">The container for which the condition is evaluated.</param>
		/// <returns>BOOL</returns>
		virtual bool TCOMAPI Condition(ITcVnContainer* ipElement) = 0;
	};

	/// <summary>
	/// Offers an interface for a custom condition computed for an element represented by an ITcVnForwardIterator.
	/// </summary>
	struct __declspec(novtable) ITcVnCustomElementCondition_ITcVnForwardIterator
	{
		/// <summary>
		/// Evaluates the condition for the provided element.
		/// </summary>
		/// <param name="ipElement">Element for which the condition is evaluated.</param>
		/// <returns>BOOL</returns>
		virtual bool TCOMAPI Condition(ITcVnForwardIterator* ipElement) = 0;
	};

	const GUID ContainerType_Vector_SINT = { 0x11db9361, 0xbe50, 0x4a9e, { 0xb9, 0x8d, 0x83, 0xeb, 0xd3, 0xdc, 0x19, 0xc7 } };
	const GUID ContainerType_Vector_USINT = { 0x7abdde3b, 0x5b25, 0x4081, { 0x86, 0xd3, 0x7f, 0x33, 0x73, 0xcf, 0x0f, 0x85 } };
	const GUID ContainerType_Vector_INT = { 0x417cc9dc, 0xe3b2, 0x4a5a, { 0x98, 0x61, 0x8b, 0x5a, 0xb7, 0x6e, 0x0c, 0x8f } };
	const GUID ContainerType_Vector_UINT = { 0xbe52ca6a, 0xc175, 0x42fb, { 0xa8, 0xd1, 0x78, 0x33, 0x59, 0x01, 0x8f, 0x03 } };
	const GUID ContainerType_Vector_DINT = { 0x87768f26, 0xd00a, 0x40d8, { 0xaf, 0xb0, 0x47, 0xdb, 0x7a, 0xf1, 0x76, 0x67 } };
	const GUID ContainerType_Vector_UDINT = { 0x717c0403, 0x47d1, 0x4303, { 0x89, 0xdb, 0x97, 0x1d, 0x5f, 0xa7, 0x3b, 0x1e } };
	const GUID ContainerType_Vector_ULINT = { 0xc3347ae0, 0x110a, 0x46ab, { 0xb6, 0xc7, 0xff, 0xae, 0xd9, 0xd6, 0xf7, 0x65 } };
	const GUID ContainerType_Vector_REAL = { 0x4697d18b, 0x33c6, 0x47d3, { 0xa3, 0xcd, 0x5f, 0x05, 0x62, 0xac, 0xc3, 0x87 } };
	const GUID ContainerType_Vector_LREAL = { 0xcef79716, 0x6b1f, 0x4a2c, { 0xa7, 0x9f, 0x3a, 0xac, 0xc1, 0x8f, 0x61, 0x9d } };
	const GUID ContainerType_Vector_ITcVnImage = { 0xe0282a58, 0x3de5, 0x4078, { 0xad, 0x89, 0x81, 0xd4, 0x0c, 0xdc, 0x49, 0x27 } };
	const GUID ContainerType_Vector_TcVnPoint2_DINT = { 0x7a190c0b, 0x0ffd, 0x43ea, { 0x86, 0x96, 0x11, 0xaa, 0x43, 0x97, 0x21, 0x2e } };
	const GUID ContainerType_Vector_TcVnPoint2_REAL = { 0xa23984cc, 0x62c5, 0x4e2d, { 0x97, 0x79, 0xca, 0x57, 0x2d, 0xc9, 0xd7, 0x18 } };
	const GUID ContainerType_Vector_TcVnPoint2_LREAL = { 0x576552bb, 0x1d78, 0x444b, { 0xae, 0x54, 0x95, 0xc6, 0x82, 0x09, 0xd6, 0x96 } };
	const GUID ContainerType_Vector_TcVnPoint3_REAL = { 0x79c0038a, 0x3de0, 0x4542, { 0x82, 0x4e, 0x04, 0x8f, 0x7b, 0xa6, 0xa8, 0xb9 } };
	const GUID ContainerType_Vector_TcVnPoint3_LREAL = { 0x426ef61d, 0x2bd8, 0x483e, { 0xaf, 0x10, 0x2f, 0x57, 0xbb, 0xac, 0xd4, 0x3e } };
	const GUID ContainerType_Vector_Vector_TcVnPoint2_DINT = { 0xc36f3009, 0xcebd, 0x4557, { 0x9a, 0x37, 0xcd, 0x4b, 0x4d, 0x3b, 0xb5, 0x2e } };
	const GUID ContainerType_Vector_Vector_TcVnPoint2_REAL = { 0xa6e79460, 0x59a8, 0x46ae, { 0x90, 0xef, 0x18, 0xab, 0xb5, 0x2f, 0x15, 0xb6 } };
	const GUID ContainerType_Vector_Vector_TcVnPoint3_REAL = { 0x57faef4f, 0x32f9, 0x4dc5, { 0x8c, 0x51, 0xe2, 0xa3, 0xcc, 0xd5, 0x53, 0xa5 } };
	const GUID ContainerType_Vector_Vector_UDINT = { 0xf52fda4c, 0xaef3, 0x4f55, { 0xa4, 0x32, 0x18, 0xf0, 0x82, 0x01, 0xf0, 0x9e } };
	const GUID ContainerType_Vector_Vector_ULINT = { 0x1f5e58d1, 0x3f29, 0x4c2c, { 0x8a, 0x34, 0x08, 0xe9, 0xf1, 0x46, 0x59, 0xac } };
	const GUID ContainerType_Vector_Vector_REAL = { 0xe58f0192, 0x5497, 0x4abf, { 0x83, 0xcd, 0x46, 0x10, 0xbb, 0x1c, 0xfe, 0x01 } };
	const GUID ContainerType_Vector_Vector_LREAL = { 0x5741fea9, 0xdf85, 0x43da, { 0xac, 0xcf, 0xe7, 0x0e, 0x9d, 0x04, 0x40, 0xc9 } };
	const GUID ContainerType_Vector_TcVnVector2_SINT = { 0xae621f76, 0x37c8, 0x4c5e, { 0xa8, 0xcf, 0xe0, 0x05, 0xdd, 0x7b, 0xd6, 0xab } };
	const GUID ContainerType_Vector_TcVnVector2_USINT = { 0x80b12ad4, 0xa6bf, 0x4286, { 0x91, 0xfc, 0xf8, 0x5a, 0x50, 0xb0, 0x0c, 0x62 } };
	const GUID ContainerType_Vector_TcVnVector2_INT = { 0x308f69a3, 0xda09, 0x422a, { 0xa4, 0x20, 0xd8, 0x55, 0xe1, 0x15, 0x9f, 0xf8 } };
	const GUID ContainerType_Vector_TcVnVector2_UINT = { 0x597a9087, 0x7fce, 0x4459, { 0xb5, 0xbc, 0x00, 0xb5, 0x57, 0xc4, 0xc6, 0x96 } };
	const GUID ContainerType_Vector_TcVnVector2_DINT = { 0x6addce85, 0xca76, 0x462d, { 0xa0, 0xee, 0x25, 0x11, 0x3e, 0xcc, 0xd4, 0x82 } };
	const GUID ContainerType_Vector_TcVnVector2_REAL = { 0x4d236387, 0xf860, 0x4de5, { 0xa2, 0xeb, 0x60, 0x96, 0x38, 0x66, 0x8f, 0xb4 } };
	const GUID ContainerType_Vector_TcVnVector3_SINT = { 0x300dbbe8, 0x5084, 0x483b, { 0x8e, 0xa2, 0x9c, 0x6d, 0xb0, 0x19, 0x4e, 0x3a } };
	const GUID ContainerType_Vector_TcVnVector3_USINT = { 0x8d069f99, 0x9ef4, 0x472c, { 0xb9, 0xf3, 0x0c, 0x04, 0xa8, 0x7a, 0xae, 0xf3 } };
	const GUID ContainerType_Vector_TcVnVector3_INT = { 0xf0b212b4, 0x666e, 0x494a, { 0x97, 0xda, 0x80, 0x9f, 0x58, 0x23, 0xf6, 0x9d } };
	const GUID ContainerType_Vector_TcVnVector3_UINT = { 0xfd0f00c1, 0x68b9, 0x4101, { 0xaa, 0xfe, 0x85, 0xff, 0xf6, 0x54, 0x66, 0xc9 } };
	const GUID ContainerType_Vector_TcVnVector3_REAL = { 0xbff791f1, 0xaf31, 0x4fd2, { 0x9c, 0x75, 0x29, 0x51, 0x99, 0xba, 0x48, 0xb7 } };
	const GUID ContainerType_Vector_TcVnVector4_SINT = { 0x37654efd, 0xdac8, 0x4a4b, { 0x9e, 0x6e, 0x1d, 0x27, 0x0d, 0x4b, 0x8a, 0x9c } };
	const GUID ContainerType_Vector_TcVnVector4_USINT = { 0x26cf7a56, 0x1b6e, 0x4e71, { 0xa8, 0xe8, 0xb8, 0x23, 0x5b, 0xe3, 0x90, 0x89 } };
	const GUID ContainerType_Vector_TcVnVector4_INT = { 0x52d501b5, 0x0617, 0x42ff, { 0xb2, 0x77, 0x12, 0x30, 0xe7, 0xa9, 0xc7, 0x24 } };
	const GUID ContainerType_Vector_TcVnVector4_UINT = { 0x0724bd49, 0xa4c9, 0x4cf9, { 0xbc, 0x95, 0xf9, 0xdc, 0xa3, 0xc1, 0xa6, 0xed } };
	const GUID ContainerType_Vector_TcVnVector4_DINT = { 0x446b8a43, 0x034f, 0x4c74, { 0xb1, 0xe8, 0x21, 0x5d, 0x91, 0x92, 0x67, 0xde } };
	const GUID ContainerType_Vector_TcVnVector4_REAL = { 0x6e417899, 0xb0ef, 0x46a6, { 0xbb, 0xb6, 0x64, 0xf2, 0x5b, 0x16, 0x5a, 0x6c } };
	const GUID ContainerType_Vector_TcVnVector4_LREAL = { 0x4327c32d, 0x212c, 0x48e8, { 0xb3, 0x95, 0x01, 0x5d, 0x1a, 0xe4, 0x19, 0xbf } };
	const GUID ContainerType_Vector_TcVnRectangle_DINT = { 0x95e46136, 0xcfe6, 0x4e90, { 0x83, 0xa2, 0x06, 0x54, 0x9a, 0x02, 0x60, 0x5e } };
	const GUID ContainerType_Vector_TcVnRotatedRectangle = { 0x541664eb, 0x7aad, 0x42cc, { 0x86, 0x2d, 0xb6, 0x46, 0x03, 0xb0, 0xcb, 0x56 } };
	const GUID ContainerType_Vector_TcVnKeyPoint = { 0xf826b1e5, 0xa575, 0x47c9, { 0x9f, 0x08, 0x64, 0xcd, 0xf7, 0x07, 0xf1, 0x77 } };
	const GUID ContainerType_Vector_TcVnDMatch = { 0xa7c1228d, 0x6d54, 0x4f67, { 0x97, 0xd3, 0xc9, 0x06, 0x54, 0x23, 0x69, 0x98 } };
	const GUID ContainerType_Vector_Vector_TcVnDMatch = { 0xc1a190fa, 0x2e6d, 0x41c1, { 0xa8, 0x05, 0x23, 0xa4, 0xf1, 0xdb, 0x36, 0x56 } };
	const GUID ContainerType_String_SINT = { 0xca003923, 0x8736, 0x47f2, { 0x81, 0xcb, 0x3b, 0x91, 0xdf, 0xbf, 0xfa, 0x67 } };
	const GUID ContainerType_Vector_String_SINT = { 0x5d27d832, 0xca23, 0x47dd, { 0x93, 0xda, 0x98, 0x0e, 0xe7, 0x46, 0xdc, 0x6d } };

	/// <summary>
	/// Interface to train and classify an image color.
	/// </summary>
	struct __declspec(novtable) ITcVnColorModel : public ITcVnMlModel
	{
		/// <summary>
		/// Train the color of the provided image.
		/// </summary>
		/// <param name="ipSrcImage">Source image.</param>
		/// <param name="nDifferentColors">Number of different colors to differentiate.</param>
		/// <param name="ipMask">Optional image mask.</param>
		/// <param name="nSkipPixels">Number of pixels to skip between each evaluated color sample (to achieve a better performance). 0 takes every pixel into account and tends to be more accurate.</param>
		/// <returns>HRESULT</returns>
		virtual HRESULT TCOMAPI TrainImageColor(ITcVnImage* ipSrcImage, ULONG nDifferentColors, ITcVnImage* ipMask, ULONG nSkipPixels) = 0;
		/// <summary>
		/// Compute the similarity of each image pixel to the trained reference color.
		/// </summary>
		/// <param name="ipSrcImage">Source image.</param>
		/// <param name="pipDestImage">Returns the color similarity.</param>
		/// <param name="fVariance">Allowed color variance.</param>
		/// <param name="fLuminanceWeight">Weight the impact of the luminance.</param>
		/// <returns>HRESULT</returns>
		virtual HRESULT TCOMAPI ClassifyImageColor(ITcVnImage* ipSrcImage, ITcVnImage** pipDestImage, float fVariance, float fLuminanceWeight) = 0;
	};

	class _FB_BASE
	{
	public:
		virtual ~_FB_BASE() {}
	};
	
	struct PLC_PARAM_Main
	{
		void* pInstance;
	};
	
	struct PLC_PARAM_Init : PLC_PARAM_Main
	{
		bool bInitRetains;
		bool bInCopyCode;
		bool returnValue;
	};
	
	struct PLC_PARAM_Exit : PLC_PARAM_Main
	{
		bool bInCopyCode;
		bool returnValue;
	};
	
	class TmlHandler
	{
	private:
	
		static bool IsObjInState(TCOM_STATE state)
		{
			if(ITComObjectPtr spObj = s_ipInst)
			{
				TCOM_STATE currentState;
				spObj->TcGetObjState(&currentState);
				return currentState == state;
			}
			return false;
		}
	
		static HRESULT Create(ITComObjectServer* ipSrv, OTCID parentObjId, TcTmlVersionedLibraryInfo* pVersionedLibraryInfo, TcTraceLevel traceLevel)
		{
			HRESULT hr = E_FAIL;
	
			if(!pVersionedLibraryInfo)
				ipSrv->TcReportLog(ADSLOG_MSGTYPE_WARN | ADSLOG_MSGTYPE_STRING, const_cast<char*>(FNAMEA "VersionedLibraryInfo not present."));
			else
			{
				if(s_ipInst)
					hr = ADS_E_EXISTS;
				else
				{
					if(ITComCreateInstancePtr spCreateInstance = ipSrv)
					{
						hr = spCreateInstance->TcCreateAndInitInstance(CID_TcTmlHandler, IID_ITcModuleLibraryHandler, (PPVOID)&s_ipInst, OTCID_CreateNewId, parentObjId, const_cast<char*>(pVersionedLibraryInfo->sLibraryId), TCOM_STATE_PREOP);
						ipSrv->TcReportLog(ADSLOG_MSGTYPE_HINT | ADSLOG_MSGTYPE_STRING, const_cast<char*>(FNAMEA "TcCreateAndInitInstance returned hr=0x%08x"), hr);
					}
	
					if(s_ipInst)
					{
						hr = s_ipInst->SetVersionedLibraryInfo(pVersionedLibraryInfo);
						ipSrv->TcReportLog(ADSLOG_MSGTYPE_HINT | ADSLOG_MSGTYPE_STRING, const_cast<char*>(FNAMEA "SetVersionedLibraryInfo returned hr=0x%08x"), hr);
	
						if(SUCCEEDED(hr))
						{
							if(ITComObjectPtr spObj = s_ipInst)
							{
								hr = spObj->TcSetObjPara(PID_TcTraceLevel, sizeof(TcTraceLevel), &traceLevel);
								hr = FAILED(hr) ? hr : SetObjStatePS();
							}
							else
								hr = ADS_E_NOINTERFACE;
						}
					}
				}
			}
	
			return hr;
		}
	
		static HRESULT TransitionHelper(ITComObjectServer* ipSrv, TCOM_STATE from, TCOM_STATE to)
		{
			if(ITComObjectPtr spObj = s_ipInst)
				return (IsObjInState(from) ? spObj->TcSetObjState(to, ipSrv, NULL) : ADS_E_INVALIDSTATE);
			else
				return ADS_E_NOINTERFACE;
		}
	
	public:
	
		static inline ITcModuleLibraryHandler* s_ipInst = nullptr;
	
		static bool IsReady()
		{
			return IsObjInState(TCOM_STATE_OP);
		}
	
		static HRESULT SetObjStateSO()
		{
			return TransitionHelper(NULL, TCOM_STATE_SAFEOP, TCOM_STATE_OP);
		}
	
		static HRESULT SetObjStateOS()
		{
			return TransitionHelper(NULL, TCOM_STATE_OP, TCOM_STATE_SAFEOP);
		}
	
		static HRESULT SetObjStatePS()
		{
			return TransitionHelper(NULL, TCOM_STATE_PREOP, TCOM_STATE_SAFEOP);
		}
	
		static HRESULT SetObjStateSP()
		{
			return TransitionHelper(NULL, TCOM_STATE_SAFEOP, TCOM_STATE_PREOP);
		}
	
		static HRESULT Create(ITComObjectServer* ipSrv, OTCID parentObjId, TcTraceLevel traceLevel = TcTraceLevel::tlWarning)
		{
			return Create(ipSrv, parentObjId, &libraryInfo, traceLevel);
		}
	
		static HRESULT Destroy(ITComObjectServer* ipSrv)
		{
			HRESULT hr = E_FAIL;
	
			if(FAILED(hr = TransitionHelper(ipSrv, TCOM_STATE_SAFEOP, TCOM_STATE_PREOP)))
				ipSrv->TcReportLog(ADSLOG_MSGTYPE_WARN | ADSLOG_MSGTYPE_STRING, const_cast<char*>(FLEAVEA "SafeOp -> PreOp hr=0x%08x"), hr);
	
			if(SUCCEEDED(hr = TransitionHelper(ipSrv, TCOM_STATE_PREOP, TCOM_STATE_INIT)))
			{
				s_ipInst->TcRelease();
				s_ipInst = NULL;
				hr = S_OK;
			}
			else
				ipSrv->TcReportLog(ADSLOG_MSGTYPE_WARN | ADSLOG_MSGTYPE_STRING, const_cast<char*>(FLEAVEA "PreOp -> Init hr=0x%08x"), hr);
	
			return hr;
		}
	};

#ifdef LIC_TC3_Vision_Base

	namespace Internal
	{
		struct AdaptiveThreshold_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fMaxValue;
			ETcVnAdaptiveThresholdMethod eAdaptiveMethod;
			ETcVnThresholdType eThresholdType;
			ULONG nBlockSize;
			double fConstant;
			HRESULT hrPrev;
			HRESULT retVal;

			AdaptiveThreshold_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fMaxValue, ETcVnAdaptiveThresholdMethod eAdaptiveMethod, ETcVnThresholdType eThresholdType, ULONG nBlockSize, double fConstant, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fMaxValue(fMaxValue), eAdaptiveMethod(eAdaptiveMethod), eThresholdType(eThresholdType), nBlockSize(nBlockSize), fConstant(fConstant), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply an adaptive threshold to a gray level image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel, elements of type USINT)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fMaxValue">Value assigned to pixels for which the threshold condition is true</param>
	/// <param name="eAdaptiveMethod">Adaptive threshold method to be applied (MEAN: threshold value will be calculated as a mean of the nBlockSize x nBlockSize neighborhood of (x,y) minus fConstant. GAUSSIAN: threshold value is a weighted sum (cross-correlation with a Gaussian window) of the nBlockSize x nBlockSize neighborhood of (x,y) minus fConstant.</param>
	/// <param name="eThresholdType">Threshold type to be applied (only BINARY and BINARY_INV are supported)</param>
	/// <param name="nBlockSize">Size of the pixel neighborhood to calculate the local threshold (3, 5, 7, ...)</param>
	/// <param name="fConstant">Constant that is subtracted from the weighted mean of the pixel neighborhood, which leads to the local threshold</param>
	/// <returns>HRESULT</returns>
	static HRESULT AdaptiveThreshold(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fMaxValue, ETcVnAdaptiveThresholdMethod eAdaptiveMethod = ATM_MEAN, ETcVnThresholdType eThresholdType = TT_BINARY, ULONG nBlockSize = 3, double fConstant = 5)
	{
		Internal::AdaptiveThreshold_Params params(ipSrcImage, ipDestImage, fMaxValue, eAdaptiveMethod, eThresholdType, nBlockSize, fConstant, hrPrev);

		libraryInfo.functions[0 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddContainers_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddContainers_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise addition of two containers (same length and type).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddContainers(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::AddContainers_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[1 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			AddImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise addition of two images using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::AddImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[2 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddImagesWeighted_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			double fWeight1;
			double fWeight2;
			double fDelta;
			ETcVnElementType eDestType;
			HRESULT hrPrev;
			HRESULT retVal;

			AddImagesWeighted_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, double fWeight1, double fWeight2, double fDelta, ETcVnElementType eDestType, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), fWeight1(fWeight1), fWeight2(fWeight2), fDelta(fDelta), eDestType(eDestType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Weighted, element-wise addition of two images using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fWeight1">Weight factor applied to ipSrcImage1</param>
	/// <param name="fWeight2">Weight factor applied to ipSrcImage2</param>
	/// <param name="fDelta">Value added to the weighted sum of both images</param>
	/// <param name="eDestType">Destination image depth</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddImagesWeighted(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, double fWeight1, double fWeight2, double fDelta, ETcVnElementType eDestType = TCVN_ET_SAME_AS_SOURCE)
	{
		Internal::AddImagesWeighted_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, fWeight1, fWeight2, fDelta, eDestType, hrPrev);

		libraryInfo.functions[3 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddScalarToImage_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			AddScalarToImage_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a scalar value to each image pixel using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddScalarToImage(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::AddScalarToImage_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[4 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_DINT_Params
		{
			LONG nValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_DINT_Params(LONG nValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : nValue(nValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nValue">Value</param>
	/// <param name="ipContainer">Container with DINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, LONG nValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_DINT_Params params(nValue, ipContainer, hrPrev);

		libraryInfo.functions[5 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_INT_Params
		{
			SHORT nValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_INT_Params(SHORT nValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : nValue(nValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nValue">Value</param>
	/// <param name="ipContainer">Container with INT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, SHORT nValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_INT_Params params(nValue, ipContainer, hrPrev);

		libraryInfo.functions[6 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_LREAL_Params
		{
			double fValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_LREAL_Params(double fValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : fValue(fValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fValue">Value</param>
	/// <param name="ipContainer">Container with LREAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, double fValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_LREAL_Params params(fValue, ipContainer, hrPrev);

		libraryInfo.functions[7 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_REAL_Params
		{
			float fValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_REAL_Params(float fValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : fValue(fValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fValue">Value</param>
	/// <param name="ipContainer">Container with REAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, float fValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_REAL_Params params(fValue, ipContainer, hrPrev);

		libraryInfo.functions[8 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_SINT_Params
		{
			char nValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_SINT_Params(char nValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : nValue(nValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nValue">Value</param>
	/// <param name="ipContainer">Container with SINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, char nValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_SINT_Params params(nValue, ipContainer, hrPrev);

		libraryInfo.functions[9 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnKeyPoint_Params
		{
			TcVnKeyPoint& stValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnKeyPoint_Params(TcVnKeyPoint& stValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : stValue(stValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stValue">Value</param>
	/// <param name="ipContainer">Container with TcVnKeyPoint elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnKeyPoint& stValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnKeyPoint_Params params(stValue, ipContainer, hrPrev);

		libraryInfo.functions[10 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnPoint2_DINT_Params
		{
			VN_TcVnPoint2_DINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnPoint2_DINT_Params(TcVnPoint2_DINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnPoint2_DINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnPoint2_DINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnPoint2_DINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[11 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnPoint2_LREAL_Params
		{
			VN_TcVnPoint2_LREAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnPoint2_LREAL_Params(TcVnPoint2_LREAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnPoint2_LREAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnPoint2_LREAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnPoint2_LREAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[12 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnPoint2_REAL_Params
		{
			VN_TcVnPoint2_REAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnPoint2_REAL_Params(TcVnPoint2_REAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnPoint2_REAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnPoint2_REAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnPoint2_REAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[13 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnPoint3_LREAL_Params
		{
			VN_TcVnPoint3_LREAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnPoint3_LREAL_Params(TcVnPoint3_LREAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnPoint3_LREAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnPoint3_LREAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnPoint3_LREAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[14 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnPoint3_REAL_Params
		{
			VN_TcVnPoint3_REAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnPoint3_REAL_Params(TcVnPoint3_REAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnPoint3_REAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnPoint3_REAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnPoint3_REAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[15 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnRectangle_DINT_Params
		{
			TcVnRectangle_DINT& stValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnRectangle_DINT_Params(TcVnRectangle_DINT& stValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : stValue(stValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stValue">Value</param>
	/// <param name="ipContainer">Container with TcVnRectangle_DINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnRectangle_DINT& stValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnRectangle_DINT_Params params(stValue, ipContainer, hrPrev);

		libraryInfo.functions[16 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnRotatedRectangle_Params
		{
			TcVnRotatedRectangle& stValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnRotatedRectangle_Params(TcVnRotatedRectangle& stValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : stValue(stValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stValue">Value</param>
	/// <param name="ipContainer">Container with TcVnRotatedRectangle elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnRotatedRectangle& stValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnRotatedRectangle_Params params(stValue, ipContainer, hrPrev);

		libraryInfo.functions[17 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector2_DINT_Params
		{
			VN_TcVnVector2_DINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector2_DINT_Params(TcVnVector2_DINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector2_DINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector2_DINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector2_DINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[18 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector2_INT_Params
		{
			VN_TcVnVector2_INT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector2_INT_Params(TcVnVector2_INT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector2_INT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector2_INT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector2_INT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[19 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector2_REAL_Params
		{
			VN_TcVnVector2_REAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector2_REAL_Params(TcVnVector2_REAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector2_REAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector2_REAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector2_REAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[20 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector2_SINT_Params
		{
			VN_TcVnVector2_SINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector2_SINT_Params(TcVnVector2_SINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector2_SINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector2_SINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector2_SINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[21 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector2_UINT_Params
		{
			VN_TcVnVector2_UINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector2_UINT_Params(TcVnVector2_UINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector2_UINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector2_UINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector2_UINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[22 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector2_USINT_Params
		{
			VN_TcVnVector2_USINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector2_USINT_Params(TcVnVector2_USINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector2_USINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector2_USINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector2_USINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[23 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector3_INT_Params
		{
			VN_TcVnVector3_INT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector3_INT_Params(TcVnVector3_INT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector3_INT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector3_INT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector3_INT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[24 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector3_REAL_Params
		{
			VN_TcVnVector3_REAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector3_REAL_Params(TcVnVector3_REAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector3_REAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector3_REAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector3_REAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[25 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector3_SINT_Params
		{
			VN_TcVnVector3_SINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector3_SINT_Params(TcVnVector3_SINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector3_SINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector3_SINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector3_SINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[26 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector3_UINT_Params
		{
			VN_TcVnVector3_UINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector3_UINT_Params(TcVnVector3_UINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector3_UINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector3_UINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector3_UINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[27 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector3_USINT_Params
		{
			VN_TcVnVector3_USINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector3_USINT_Params(TcVnVector3_USINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector3_USINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector3_USINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector3_USINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[28 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector4_DINT_Params
		{
			VN_TcVnVector4_DINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector4_DINT_Params(TcVnVector4_DINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector4_DINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector4_DINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector4_DINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[29 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector4_INT_Params
		{
			VN_TcVnVector4_INT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector4_INT_Params(TcVnVector4_INT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector4_INT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector4_INT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector4_INT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[30 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector4_LREAL_Params
		{
			VN_TcVnVector4_LREAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector4_LREAL_Params(TcVnVector4_LREAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector4_LREAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector4_LREAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector4_LREAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[31 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector4_REAL_Params
		{
			VN_TcVnVector4_REAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector4_REAL_Params(TcVnVector4_REAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector4_REAL elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector4_REAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector4_REAL_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[32 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector4_SINT_Params
		{
			VN_TcVnVector4_SINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector4_SINT_Params(TcVnVector4_SINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector4_SINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector4_SINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector4_SINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[33 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector4_UINT_Params
		{
			VN_TcVnVector4_UINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector4_UINT_Params(TcVnVector4_UINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector4_UINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector4_UINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector4_UINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[34 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_TcVnVector4_USINT_Params
		{
			VN_TcVnVector4_USINT& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_TcVnVector4_USINT_Params(TcVnVector4_USINT& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with TcVnVector4_USINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, TcVnVector4_USINT& aValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_TcVnVector4_USINT_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[35 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_UDINT_Params
		{
			ULONG nValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_UDINT_Params(ULONG nValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : nValue(nValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nValue">Value</param>
	/// <param name="ipContainer">Container with UDINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, ULONG nValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_UDINT_Params params(nValue, ipContainer, hrPrev);

		libraryInfo.functions[36 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_UINT_Params
		{
			USHORT nValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_UINT_Params(USHORT nValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : nValue(nValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nValue">Value</param>
	/// <param name="ipContainer">Container with UINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, USHORT nValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_UINT_Params params(nValue, ipContainer, hrPrev);

		libraryInfo.functions[37 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_ULINT_Params
		{
			ULONGLONG nValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_ULINT_Params(ULONGLONG nValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : nValue(nValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nValue">Value</param>
	/// <param name="ipContainer">Container with ULINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, ULONGLONG nValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_ULINT_Params params(nValue, ipContainer, hrPrev);

		libraryInfo.functions[38 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddToContainerElements_USINT_Params
		{
			unsigned char nValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AddToContainerElements_USINT_Params(unsigned char nValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : nValue(nValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a value to each container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nValue">Value</param>
	/// <param name="ipContainer">Container with USINT elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddToContainerElements(HRESULT hrPrev, unsigned char nValue, ITcVnContainer* ipContainer)
	{
		Internal::AddToContainerElements_USINT_Params params(nValue, ipContainer, hrPrev);

		libraryInfo.functions[39 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AddVectorToImage_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			AddVectorToImage_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add a vector (1 element for each image channel) to each image pixel using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT AddVectorToImage(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::AddVectorToImage_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[40 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AdjustActiveContour_Params
		{
			ITcVnImage* ipImage;
			ITcVnContainer* ipActiveContour;
			float fAlpha;
			float fBeta;
			float fGamma;
			ULONG nWindowWidth;
			ULONG nWindowHeight;
			ULONG nMaxIterations;
			bool bUseGradient;
			HRESULT hrPrev;
			HRESULT retVal;

			AdjustActiveContour_Params(ITcVnImage* ipImage, ITcVnContainer* ipActiveContour, float fAlpha, float fBeta, float fGamma, ULONG nWindowWidth, ULONG nWindowHeight, ULONG nMaxIterations, bool bUseGradient, HRESULT hrPrev) : ipImage(ipImage), ipActiveContour(ipActiveContour), fAlpha(fAlpha), fBeta(fBeta), fGamma(fGamma), nWindowWidth(nWindowWidth), nWindowHeight(nWindowHeight), nMaxIterations(nMaxIterations), bUseGradient(bUseGradient), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Adjust active contour (snake) in order to minimize its cummulative (internal and external) energy.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image (1 channel, USINT elements)</param>
	/// <param name="ipActiveContour">Initial contour, which will be adjusted</param>
	/// <param name="fAlpha">Continuity energy coefficient</param>
	/// <param name="fBeta">Curvature energy coefficient</param>
	/// <param name="fGamma">Image energy coefficient</param>
	/// <param name="nWindowWidth">Window width (3, 5, 7, ...)</param>
	/// <param name="nWindowHeight">Window height (3, 5, 7, ...)</param>
	/// <param name="nMaxIterations">Maximum iterations</param>
	/// <param name="bUseGradient">If true, the gradient magnitude is used as image energy (otherwise: pixel intensity)</param>
	/// <returns>HRESULT</returns>
	static HRESULT AdjustActiveContour(HRESULT hrPrev, ITcVnImage* ipImage, ITcVnContainer* ipActiveContour, float fAlpha, float fBeta, float fGamma, ULONG nWindowWidth, ULONG nWindowHeight, ULONG nMaxIterations, bool bUseGradient)
	{
		Internal::AdjustActiveContour_Params params(ipImage, ipActiveContour, fAlpha, fBeta, fGamma, nWindowWidth, nWindowHeight, nMaxIterations, bUseGradient, hrPrev);

		libraryInfo.functions[41 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AdvanceIterator_Params
		{
			ITcVnForwardIterator* ipIterator;
			LONGLONG nOffset;
			HRESULT hrPrev;
			HRESULT retVal;

			AdvanceIterator_Params(ITcVnForwardIterator* ipIterator, LONGLONG nOffset, HRESULT hrPrev) : ipIterator(ipIterator), nOffset(nOffset), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Advance an iterator by the specified offset.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIterator">Iterator to be advanced</param>
	/// <param name="nOffset">Offset, by which ipIterator is advanced</param>
	/// <returns>HRESULT</returns>
	static HRESULT AdvanceIterator(HRESULT hrPrev, ITcVnForwardIterator* ipIterator, LONGLONG nOffset)
	{
		Internal::AdvanceIterator_Params params(ipIterator, nOffset, hrPrev);

		libraryInfo.functions[42 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL AlignRotatedImageRegion_aBorderValueDefault = {0, 0, 0, 0};

		struct AlignRotatedImageRegion_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnRotatedRectangle& stRegion;
			ETcVnInterpolationType eInterpolationType;
			ETcVnBorderInterpolationMethod eBorderInterpolation;
			VN_TcVnVector4_LREAL& aBorderValue;
			HRESULT hrPrev;
			HRESULT retVal;

			AlignRotatedImageRegion_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnRotatedRectangle& stRegion, ETcVnInterpolationType eInterpolationType, ETcVnBorderInterpolationMethod eBorderInterpolation, TcVnVector4_LREAL& aBorderValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), stRegion(stRegion), eInterpolationType(eInterpolationType), eBorderInterpolation(eBorderInterpolation), aBorderValue(aBorderValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Copies the provided image region and aligns it to the image axes. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="stRegion">Image region to be aligned</param>
	/// <param name="eInterpolationType">Interpolation method</param>
	/// <param name="eBorderInterpolation">Border interpolation method (ISOLATED not supported)</param>
	/// <param name="aBorderValue">Border value, if CONSTANT is used</param>
	/// <returns>HRESULT</returns>
	static HRESULT AlignRotatedImageRegion(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnRotatedRectangle& stRegion, ETcVnInterpolationType eInterpolationType = IT_BILINEAR, ETcVnBorderInterpolationMethod eBorderInterpolation = BIM_CONSTANT, TcVnVector4_LREAL& aBorderValue = Internal::AlignRotatedImageRegion_aBorderValueDefault)
	{
		Internal::AlignRotatedImageRegion_Params params(ipSrcImage, ipDestImage, stRegion, eInterpolationType, eBorderInterpolation, aBorderValue, hrPrev);

		libraryInfo.functions[43 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_DINT_Params
		{
			LONG nElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_DINT_Params(LONG nElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type DINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, LONG nElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_DINT_Params params(nElement, ipContainer, hrPrev);

		libraryInfo.functions[44 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_INT_Params
		{
			SHORT nElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_INT_Params(SHORT nElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type INT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, SHORT nElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_INT_Params params(nElement, ipContainer, hrPrev);

		libraryInfo.functions[45 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_ITcVnContainer_Params
		{
			ITcVnContainer* ipElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_ITcVnContainer_Params(ITcVnContainer* ipElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element to a container or concatenate containers (if ipElement has the same typeId as ipContainer).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Single element to append to ipContainer or container with several elements to be concatenated</param>
	/// <param name="ipContainer">Container to which the element(s) will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, ITcVnContainer* ipElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_ITcVnContainer_Params params(ipElement, ipContainer, hrPrev);

		libraryInfo.functions[46 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_ITcVnForwardIterator_Params
		{
			ITcVnForwardIterator* ipElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_ITcVnForwardIterator_Params(ITcVnForwardIterator* ipElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element (represented by an iterator)to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element(s) will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, ITcVnForwardIterator* ipElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_ITcVnForwardIterator_Params params(ipElement, ipContainer, hrPrev);

		libraryInfo.functions[47 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_ITcVnImage_Params
		{
			ITcVnImage* ipElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_ITcVnImage_Params(ITcVnImage* ipElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type ITcVnImage to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, ITcVnImage* ipElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_ITcVnImage_Params params(ipElement, ipContainer, hrPrev);

		libraryInfo.functions[48 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_LREAL_Params
		{
			double fElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_LREAL_Params(double fElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : fElement(fElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type LREAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, double fElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_LREAL_Params params(fElement, ipContainer, hrPrev);

		libraryInfo.functions[49 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_REAL_Params
		{
			float fElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_REAL_Params(float fElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : fElement(fElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type REAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, float fElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_REAL_Params params(fElement, ipContainer, hrPrev);

		libraryInfo.functions[50 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_SINT_Params
		{
			char nElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_SINT_Params(char nElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type SINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, char nElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_SINT_Params params(nElement, ipContainer, hrPrev);

		libraryInfo.functions[51 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnDMatch_Params
		{
			TcVnDMatch& stElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnDMatch_Params(TcVnDMatch& stElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnDMatch to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnDMatch& stElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnDMatch_Params params(stElement, ipContainer, hrPrev);

		libraryInfo.functions[52 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnKeyPoint_Params
		{
			TcVnKeyPoint& stElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnKeyPoint_Params(TcVnKeyPoint& stElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnKeyPoint to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnKeyPoint& stElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnKeyPoint_Params params(stElement, ipContainer, hrPrev);

		libraryInfo.functions[53 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnPoint2_DINT_Params
		{
			VN_TcVnPoint2_DINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnPoint2_DINT_Params(TcVnPoint2_DINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnPoint2_DINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnPoint2_DINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnPoint2_DINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[54 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnPoint2_LREAL_Params
		{
			VN_TcVnPoint2_LREAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnPoint2_LREAL_Params(TcVnPoint2_LREAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnPoint2_LREAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnPoint2_LREAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnPoint2_LREAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[55 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnPoint2_REAL_Params
		{
			VN_TcVnPoint2_REAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnPoint2_REAL_Params(TcVnPoint2_REAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnPoint2_REAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnPoint2_REAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnPoint2_REAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[56 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnPoint3_LREAL_Params
		{
			VN_TcVnPoint3_LREAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnPoint3_LREAL_Params(TcVnPoint3_LREAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnPoint3_LREAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnPoint3_LREAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnPoint3_LREAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[57 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnPoint3_REAL_Params
		{
			VN_TcVnPoint3_REAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnPoint3_REAL_Params(TcVnPoint3_REAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnPoint3_REAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnPoint3_REAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnPoint3_REAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[58 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnRectangle_DINT_Params
		{
			TcVnRectangle_DINT& stElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnRectangle_DINT_Params(TcVnRectangle_DINT& stElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnRectangle_DINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnRectangle_DINT& stElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnRectangle_DINT_Params params(stElement, ipContainer, hrPrev);

		libraryInfo.functions[59 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnRotatedRectangle_Params
		{
			TcVnRotatedRectangle& stElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnRotatedRectangle_Params(TcVnRotatedRectangle& stElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnRotatedRectangle to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnRotatedRectangle& stElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnRotatedRectangle_Params params(stElement, ipContainer, hrPrev);

		libraryInfo.functions[60 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector2_DINT_Params
		{
			VN_TcVnVector2_DINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector2_DINT_Params(TcVnVector2_DINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector2_DINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector2_DINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector2_DINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[61 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector2_INT_Params
		{
			VN_TcVnVector2_INT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector2_INT_Params(TcVnVector2_INT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector2_INT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector2_INT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector2_INT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[62 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector2_REAL_Params
		{
			VN_TcVnVector2_REAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector2_REAL_Params(TcVnVector2_REAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector2_REAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector2_REAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector2_REAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[63 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector2_SINT_Params
		{
			VN_TcVnVector2_SINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector2_SINT_Params(TcVnVector2_SINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector2_SINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector2_SINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector2_SINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[64 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector2_UINT_Params
		{
			VN_TcVnVector2_UINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector2_UINT_Params(TcVnVector2_UINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector2_UINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector2_UINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector2_UINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[65 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector2_USINT_Params
		{
			VN_TcVnVector2_USINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector2_USINT_Params(TcVnVector2_USINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector2_USINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector2_USINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector2_USINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[66 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector3_INT_Params
		{
			VN_TcVnVector3_INT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector3_INT_Params(TcVnVector3_INT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector3_INT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector3_INT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector3_INT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[67 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector3_REAL_Params
		{
			VN_TcVnVector3_REAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector3_REAL_Params(TcVnVector3_REAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector3_REAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector3_REAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector3_REAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[68 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector3_SINT_Params
		{
			VN_TcVnVector3_SINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector3_SINT_Params(TcVnVector3_SINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector3_SINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector3_SINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector3_SINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[69 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector3_UINT_Params
		{
			VN_TcVnVector3_UINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector3_UINT_Params(TcVnVector3_UINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector3_UINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector3_UINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector3_UINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[70 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector3_USINT_Params
		{
			VN_TcVnVector3_USINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector3_USINT_Params(TcVnVector3_USINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector3_USINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector3_USINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector3_USINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[71 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector4_DINT_Params
		{
			VN_TcVnVector4_DINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector4_DINT_Params(TcVnVector4_DINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector4_DINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector4_DINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector4_DINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[72 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector4_INT_Params
		{
			VN_TcVnVector4_INT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector4_INT_Params(TcVnVector4_INT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector4_INT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector4_INT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector4_INT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[73 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector4_LREAL_Params
		{
			VN_TcVnVector4_LREAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector4_LREAL_Params(TcVnVector4_LREAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector4_LREAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector4_LREAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector4_LREAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[74 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector4_REAL_Params
		{
			VN_TcVnVector4_REAL& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector4_REAL_Params(TcVnVector4_REAL& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector4_REAL to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector4_REAL& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector4_REAL_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[75 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector4_SINT_Params
		{
			VN_TcVnVector4_SINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector4_SINT_Params(TcVnVector4_SINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector4_SINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector4_SINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector4_SINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[76 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector4_UINT_Params
		{
			VN_TcVnVector4_UINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector4_UINT_Params(TcVnVector4_UINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector4_UINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector4_UINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector4_UINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[77 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_TcVnVector4_USINT_Params
		{
			VN_TcVnVector4_USINT& aElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_TcVnVector4_USINT_Params(TcVnVector4_USINT& aElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type TcVnVector4_USINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, TcVnVector4_USINT& aElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_TcVnVector4_USINT_Params params(aElement, ipContainer, hrPrev);

		libraryInfo.functions[78 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_UDINT_Params
		{
			ULONG nElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_UDINT_Params(ULONG nElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type UDINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, ULONG nElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_UDINT_Params params(nElement, ipContainer, hrPrev);

		libraryInfo.functions[79 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_UINT_Params
		{
			USHORT nElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_UINT_Params(USHORT nElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type UINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, USHORT nElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_UINT_Params params(nElement, ipContainer, hrPrev);

		libraryInfo.functions[80 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_ULINT_Params
		{
			ULONGLONG nElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_ULINT_Params(ULONGLONG nElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type ULINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, ULONGLONG nElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_ULINT_Params params(nElement, ipContainer, hrPrev);

		libraryInfo.functions[81 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct AppendToContainer_USINT_Params
		{
			unsigned char nElement;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			AppendToContainer_USINT_Params(unsigned char nElement, ITcVnContainer* ipContainer, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Append a single element of type USINT to a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to append to ipContainer</param>
	/// <param name="ipContainer">Container to which the element will be appended</param>
	/// <returns>HRESULT</returns>
	static HRESULT AppendToContainer(HRESULT hrPrev, unsigned char nElement, ITcVnContainer* ipContainer)
	{
		Internal::AppendToContainer_USINT_Params params(nElement, ipContainer, hrPrev);

		libraryInfo.functions[82 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ApplyColorMap_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnContainer* ipColorMap;
			HRESULT hrPrev;
			HRESULT retVal;

			ApplyColorMap_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnContainer* ipColorMap, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipColorMap(ipColorMap), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a color map to a gray-level image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (TCVN_ET_USINT or TCVN_ET_UINT, 1 channel)</param>
	/// <param name="ipDestImage">Returns the colored image (TCVN_ET_USINT, 3 channel. An appropriate image will be created if required.)</param>
	/// <param name="ipColorMap">Color map to be applied to ipSrcImage (ContainerType_Vector_TcVnVector3_REAL with 256 or 65536 elements, dependent on ipSrcImage type). Can be either custom or created with F_VN_GenerateColorMap.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ApplyColorMap(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnContainer* ipColorMap)
	{
		Internal::ApplyColorMap_Params params(ipSrcImage, ipDestImage, ipColorMap, hrPrev);

		libraryInfo.functions[83 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ApplyLut_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnContainer* ipLut;
			HRESULT hrPrev;
			HRESULT retVal;

			ApplyLut_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnContainer* ipLut, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipLut(ipLut), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a lookup table to an image to manipulate its colors.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1-4 channels of 8 or 16 bit types SINT, USINT, INT, UINT)</param>
	/// <param name="ipDestImage">Returns the result image (same size, type and channels as ipSrcImage. An appropriate image will be created if required.)</param>
	/// <param name="ipLut">Lookup table with elements matching ipSrcImage type and either 256 (8 bit images) or 65536 (16 bit images) elements. E.g. ContainerType_Vector_USINT for 1-4 channel USINT image (in this case, the same lookup values are used for each channel) or ContainerType_Vector_TcVnVector3_USINT for a 3 channel USINT image (in this case, each channel uses an individual lookup value). </param>
	/// <returns>HRESULT</returns>
	static HRESULT ApplyLut(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnContainer* ipLut)
	{
		Internal::ApplyLut_Params params(ipSrcImage, ipDestImage, ipLut, hrPrev);

		libraryInfo.functions[84 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ApplyRotationToAffineTransformation_Params
		{
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			double fAngle;
			bool bUsePreMultiplication;
			HRESULT hrPrev;
			HRESULT retVal;

			ApplyRotationToAffineTransformation_Params(TcVnMatrix2x3_LREAL& aTransformationMatrix, double fAngle, bool bUsePreMultiplication, HRESULT hrPrev) : aTransformationMatrix(aTransformationMatrix), fAngle(fAngle), bUsePreMultiplication(bUsePreMultiplication), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a rotation to an existing 2D affine transformation matrix. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix to which the rotation is applied</param>
	/// <param name="fAngle">Angle in radians (positive means counter-clockwise)</param>
	/// <param name="bUsePreMultiplication">Select if pre- or post-multiplication should be used</param>
	/// <returns>HRESULT</returns>
	static HRESULT ApplyRotationToAffineTransformation(HRESULT hrPrev, TcVnMatrix2x3_LREAL& aTransformationMatrix, double fAngle, bool bUsePreMultiplication = true)
	{
		Internal::ApplyRotationToAffineTransformation_Params params(aTransformationMatrix, fAngle, bUsePreMultiplication, hrPrev);

		libraryInfo.functions[85 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ApplyScalingToAffineTransformation_Params
		{
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			double fScaleX;
			double fScaleY;
			bool bUsePreMultiplication;
			HRESULT hrPrev;
			HRESULT retVal;

			ApplyScalingToAffineTransformation_Params(TcVnMatrix2x3_LREAL& aTransformationMatrix, double fScaleX, double fScaleY, bool bUsePreMultiplication, HRESULT hrPrev) : aTransformationMatrix(aTransformationMatrix), fScaleX(fScaleX), fScaleY(fScaleY), bUsePreMultiplication(bUsePreMultiplication), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a scaling to an existing 2D affine transformation matrix. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix to which the scaling is applied</param>
	/// <param name="fScaleX">Scaling factor in x direction</param>
	/// <param name="fScaleY">Scaling factor in y direction</param>
	/// <param name="bUsePreMultiplication">Select if pre- or post-multiplication should be used</param>
	/// <returns>HRESULT</returns>
	static HRESULT ApplyScalingToAffineTransformation(HRESULT hrPrev, TcVnMatrix2x3_LREAL& aTransformationMatrix, double fScaleX, double fScaleY, bool bUsePreMultiplication = true)
	{
		Internal::ApplyScalingToAffineTransformation_Params params(aTransformationMatrix, fScaleX, fScaleY, bUsePreMultiplication, hrPrev);

		libraryInfo.functions[86 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ApplyTranslationToAffineTransformation_Params
		{
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			double fDeltaX;
			double fDeltaY;
			bool bUsePreMultiplication;
			HRESULT hrPrev;
			HRESULT retVal;

			ApplyTranslationToAffineTransformation_Params(TcVnMatrix2x3_LREAL& aTransformationMatrix, double fDeltaX, double fDeltaY, bool bUsePreMultiplication, HRESULT hrPrev) : aTransformationMatrix(aTransformationMatrix), fDeltaX(fDeltaX), fDeltaY(fDeltaY), bUsePreMultiplication(bUsePreMultiplication), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a translation to an existing 2D affine transformation matrix. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix to which the translation is applied</param>
	/// <param name="fDeltaX">Translation in x direction</param>
	/// <param name="fDeltaY">Translation in y direction</param>
	/// <param name="bUsePreMultiplication">Select if pre- or post-multiplication should be used</param>
	/// <returns>HRESULT</returns>
	static HRESULT ApplyTranslationToAffineTransformation(HRESULT hrPrev, TcVnMatrix2x3_LREAL& aTransformationMatrix, double fDeltaX, double fDeltaY, bool bUsePreMultiplication = true)
	{
		Internal::ApplyTranslationToAffineTransformation_Params params(aTransformationMatrix, fDeltaX, fDeltaY, bUsePreMultiplication, hrPrev);

		libraryInfo.functions[87 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ApplyYAxisInversionToAffineTransformation_Params
		{
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			bool bUsePreMultiplication;
			HRESULT hrPrev;
			HRESULT retVal;

			ApplyYAxisInversionToAffineTransformation_Params(TcVnMatrix2x3_LREAL& aTransformationMatrix, bool bUsePreMultiplication, HRESULT hrPrev) : aTransformationMatrix(aTransformationMatrix), bUsePreMultiplication(bUsePreMultiplication), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply an inversion of the y-axis direction to an existing 2D affine transformation matrix. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix to which the inversion of the y-axis direction is applied</param>
	/// <param name="bUsePreMultiplication">Select if pre- or post-multiplication should be used</param>
	/// <returns>HRESULT</returns>
	static HRESULT ApplyYAxisInversionToAffineTransformation(HRESULT hrPrev, TcVnMatrix2x3_LREAL& aTransformationMatrix, bool bUsePreMultiplication = true)
	{
		Internal::ApplyYAxisInversionToAffineTransformation_Params params(aTransformationMatrix, bUsePreMultiplication, hrPrev);

		libraryInfo.functions[88 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ApproximatePolygon_Params
		{
			ITcVnContainer* ipSrcContour;
			ITcVnContainer*& ipDestContour;
			double fMaxDist;
			bool bClosed;
			HRESULT hrPrev;
			HRESULT retVal;

			ApproximatePolygon_Params(ITcVnContainer* ipSrcContour, ITcVnContainer*& ipDestContour, double fMaxDist, bool bClosed, HRESULT hrPrev) : ipSrcContour(ipSrcContour), ipDestContour(ipDestContour), fMaxDist(fMaxDist), bClosed(bClosed), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Approximate a contour to a simplified polygon (using the Douglas-Peucker algorithm).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="ipDestContour">Returns a container which is filled with the approximated polygon points (same type ID as ipSrcContour; Non-zero interface pointers are reused.)</param>
	/// <param name="fMaxDist">Maximum distance between the original contour and its approximation</param>
	/// <param name="bClosed">Specify, if the contour is closed (first and last points connected) or not</param>
	/// <returns>HRESULT</returns>
	static HRESULT ApproximatePolygon(HRESULT hrPrev, ITcVnContainer* ipSrcContour, ITcVnContainer*& ipDestContour, double fMaxDist, bool bClosed)
	{
		Internal::ApproximatePolygon_Params params(ipSrcContour, ipDestContour, fMaxDist, bClosed, hrPrev);

		libraryInfo.functions[89 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BilateralFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			LONG nDiameter;
			double fSigmaColor;
			double fSigmaSpace;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			BilateralFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, LONG nDiameter, double fSigmaColor, double fSigmaSpace, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nDiameter(nDiameter), fSigmaColor(fSigmaColor), fSigmaSpace(fSigmaSpace), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a Bilateral filter to smooth the image but preserve edges. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (Must be different from ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <param name="nDiameter">Diameter of the pixel neighborhood used for filtering (e.g. 5, 7, 9). If &lt;= 0, it is automatically chosen dependend on fSigmaSpace.</param>
	/// <param name="fSigmaColor">Sigma used for color space filtering (&gt; 0). A larger value means that farther colors are mixed together.</param>
	/// <param name="fSigmaSpace">Sigma used for coordinate space filtering (&gt; 0). A larger value means that farther pixels can influence each other.</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT BilateralFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, LONG nDiameter, double fSigmaColor, double fSigmaSpace, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::BilateralFilter_Params params(ipSrcImage, ipDestImage, nDiameter, fSigmaColor, fSigmaSpace, eBorderType, hrPrev);

		libraryInfo.functions[90 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseAndContainers_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseAndContainers_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise AND operator to two containers (same length and type, integer only).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseAndContainers(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::BitwiseAndContainers_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[91 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseAndImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseAndImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise AND operator to two images.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseAndImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseAndImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[92 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseAndImagesExp_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseAndImagesExp_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise AND operator to two images. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask to limit the operation to specific pixel positions (mask value 0: skip pixel, mask value &gt; 0: apply operation to pixel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseAndImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::BitwiseAndImagesExp_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[93 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseAndScalarWithImage_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseAndScalarWithImage_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Bitwise and a scalar value with each image pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseAndScalarWithImage(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseAndScalarWithImage_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[94 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseAndVectorWithImage_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseAndVectorWithImage_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Bitwise and a vector (1 element for each image channel) with each image pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseAndVectorWithImage(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseAndVectorWithImage_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[95 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseNotContainer_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseNotContainer_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise NOT operator to a container (integer only).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseNotContainer(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer)
	{
		Internal::BitwiseNotContainer_Params params(ipSrcContainer, ipDestContainer, hrPrev);

		libraryInfo.functions[96 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseNotImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseNotImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise NOT operator to an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseNotImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseNotImage_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[97 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseNotImageExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseNotImageExp_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise NOT operator to an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask to limit the operation to specific pixel positions (mask value 0: skip pixel, mask value &gt; 0: apply operation to pixel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseNotImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::BitwiseNotImageExp_Params params(ipSrcImage, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[98 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseOrContainers_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseOrContainers_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise OR operator to two containers (same length and type, integer only).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseOrContainers(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::BitwiseOrContainers_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[99 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseOrImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseOrImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise OR operator to two images.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseOrImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseOrImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[100 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseOrImagesExp_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseOrImagesExp_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise OR operator to two images. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask to limit the operation to specific pixel positions (mask value 0: skip pixel, mask value &gt; 0: apply operation to pixel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseOrImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::BitwiseOrImagesExp_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[101 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseOrScalarWithImage_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseOrScalarWithImage_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Bitwise or a scalar value with each image pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseOrScalarWithImage(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseOrScalarWithImage_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[102 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseOrVectorWithImage_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseOrVectorWithImage_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Bitwise or a vector (1 element for each image channel) with each image pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseOrVectorWithImage(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseOrVectorWithImage_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[103 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseXorContainers_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseXorContainers_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise XOR operator to two containers (same length and type, integer only).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseXorContainers(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::BitwiseXorContainers_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[104 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseXorImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseXorImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise XOR operator to two images.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseXorImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseXorImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[105 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseXorImagesExp_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseXorImagesExp_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise application of a bit-wise XOR operator to two images. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask to limit the operation to specific pixel positions (mask value 0: skip pixel, mask value &gt; 0: apply operation to pixel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseXorImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::BitwiseXorImagesExp_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[106 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseXorScalarWithImage_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseXorScalarWithImage_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Bitwise xor a scalar value with each image pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseXorScalarWithImage(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseXorScalarWithImage_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[107 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BitwiseXorVectorWithImage_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BitwiseXorVectorWithImage_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Bitwise xor a vector (1 element for each image channel) with each image pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BitwiseXorVectorWithImage(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BitwiseXorVectorWithImage_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[108 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BlendImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage* ipWeights1;
			ITcVnImage* ipWeights2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BlendImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage* ipWeights1, ITcVnImage* ipWeights2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipWeights1(ipWeights1), ipWeights2(ipWeights2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Blends two images, i.e. dest = (src1 * weight1 + src2 * weight2) / (weight1 + weight2).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image (ET_USINT or ET_REAL)</param>
	/// <param name="ipSrcImage2">Second source image (same type and size as ipSrcImage1)</param>
	/// <param name="ipWeights1">Weights for ipSrcImage1 (1 channel, ET_REAL)</param>
	/// <param name="ipWeights2">Weights for ipSrcImage2 (1 channel, ET_REAL)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BlendImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage* ipWeights1, ITcVnImage* ipWeights2, ITcVnImage*& ipDestImage)
	{
		Internal::BlendImages_Params params(ipSrcImage1, ipSrcImage2, ipWeights1, ipWeights2, ipDestImage, hrPrev);

		libraryInfo.functions[109 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnPoint BoxFilter_aAnchorDefault = {-1, -1};

		struct BoxFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ULONG nFilterWidth;
			ULONG nFilterHeight;
			ETcVnElementType eDestDepth;
			VN_TcVnPoint& aAnchor;
			bool bNormalize;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			BoxFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nFilterWidth, ULONG nFilterHeight, ETcVnElementType eDestDepth, TcVnPoint& aAnchor, bool bNormalize, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nFilterWidth(nFilterWidth), nFilterHeight(nFilterHeight), eDestDepth(eDestDepth), aAnchor(aAnchor), bNormalize(bNormalize), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a box filter to an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="nFilterWidth">Filter width in pixels</param>
	/// <param name="nFilterHeight">Filter height in pixels</param>
	/// <param name="eDestDepth">Destination image depth</param>
	/// <param name="aAnchor">Anchor point of the kernel ([-1, -1] for center)</param>
	/// <param name="bNormalize">If true, the kernel is normalized by nFilterWidth * nFilterHeight</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT BoxFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nFilterWidth, ULONG nFilterHeight, ETcVnElementType eDestDepth = TCVN_ET_SAME_AS_SOURCE, TcVnPoint& aAnchor = Internal::BoxFilter_aAnchorDefault, bool bNormalize = true, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::BoxFilter_Params params(ipSrcImage, ipDestImage, nFilterWidth, nFilterHeight, eDestDepth, aAnchor, bNormalize, eBorderType, hrPrev);

		libraryInfo.functions[110 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct BrightBorderObjects_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			BrightBorderObjects_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Find bright objects connected to the image border within a gray-scale single-channel image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, UINT, INT, REAL, or LREAL, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT BrightBorderObjects(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::BrightBorderObjects_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[111 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CalibrateCameraPlanar_Params
		{
			ITcVnImage* ipSrcImage;
			TcVnArray4_Point2_REAL& aMarkerPositions;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			TcVnArray4_Point2_REAL& aMarkerImagePositions;
			ULONG nMinMarkerArea;
			ULONG nMaxMarkerArea;
			double fMaxMarkerEccentricity;
			HRESULT hrPrev;
			HRESULT retVal;

			CalibrateCameraPlanar_Params(ITcVnImage* ipSrcImage, TcVnArray4_Point2_REAL& aMarkerPositions, TcVnMatrix3x3_LREAL& aTransformationMatrix, TcVnArray4_Point2_REAL& aMarkerImagePositions, ULONG nMinMarkerArea, ULONG nMaxMarkerArea, double fMaxMarkerEccentricity, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aMarkerPositions(aMarkerPositions), aTransformationMatrix(aTransformationMatrix), aMarkerImagePositions(aMarkerImagePositions), nMinMarkerArea(nMinMarkerArea), nMaxMarkerArea(nMaxMarkerArea), fMaxMarkerEccentricity(fMaxMarkerEccentricity), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calibrate camera using a planar calibration pattern comprised of four circles marking the corners of a rectangle. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Binary source image (background zero, markers non-zero)</param>
	/// <param name="aMarkerPositions">Marker positions within their plane using world units (right-handed coordinate system)</param>
	/// <param name="aTransformationMatrix">Returns a 3-by-3 matrix for the transformation from image coordinates into the reference coordinate system</param>
	/// <param name="aMarkerImagePositions">Returns the marker positions in image coordinates (left-handed coordinate system)</param>
	/// <param name="nMinMarkerArea">Minimum area for the detection of markers (Smaller markers are ignored.)</param>
	/// <param name="nMaxMarkerArea">Maximum area for the detection of markers (Larger markers are ignored.)</param>
	/// <param name="fMaxMarkerEccentricity">Maximum eccenticity for the detection of markers (The eccentricity measures deviations from a round shape (eccentricity = 0: round object; eccentricity = 1.0: linear object).)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CalibrateCameraPlanar(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnArray4_Point2_REAL& aMarkerPositions, TcVnMatrix3x3_LREAL& aTransformationMatrix, TcVnArray4_Point2_REAL& aMarkerImagePositions, ULONG nMinMarkerArea = 100, ULONG nMaxMarkerArea = 10000, double fMaxMarkerEccentricity = 0.05)
	{
		Internal::CalibrateCameraPlanar_Params params(ipSrcImage, aMarkerPositions, aTransformationMatrix, aMarkerImagePositions, nMinMarkerArea, nMaxMarkerArea, fMaxMarkerEccentricity, hrPrev);

		libraryInfo.functions[112 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CannyEdgeDetection_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fThresholdLow;
			double fThresholdHigh;
			ULONG nApertureSize;
			bool bL2Gradient;
			HRESULT hrPrev;
			HRESULT retVal;

			CannyEdgeDetection_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fThresholdLow, double fThresholdHigh, ULONG nApertureSize, bool bL2Gradient, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fThresholdLow(fThresholdLow), fThresholdHigh(fThresholdHigh), nApertureSize(nApertureSize), bL2Gradient(bL2Gradient), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Find edges using the Canny edge detection algorithm. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (elements of type USINT)</param>
	/// <param name="ipDestImage">Destination image (elements of type USINT. An appropriate destination image will be created if required.)</param>
	/// <param name="fThresholdLow">Low threshold</param>
	/// <param name="fThresholdHigh">High threshold</param>
	/// <param name="nApertureSize">Aperture size for the Sobel operator (3, 5, 7)</param>
	/// <param name="bL2Gradient">If true, the more accurate (and slower) L2 norm is used instead of the L1 norm</param>
	/// <returns>HRESULT</returns>
	static HRESULT CannyEdgeDetection(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fThresholdLow, double fThresholdHigh, ULONG nApertureSize = 3, bool bL2Gradient = false)
	{
		Internal::CannyEdgeDetection_Params params(ipSrcImage, ipDestImage, fThresholdLow, fThresholdHigh, nApertureSize, bL2Gradient, hrPrev);

		libraryInfo.functions[113 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CheckColorRange_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			VN_TcVnVector4_LREAL& aLowerBounds;
			VN_TcVnVector4_LREAL& aUpperBounds;
			HRESULT hrPrev;
			HRESULT retVal;

			CheckColorRange_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnVector4_LREAL& aLowerBounds, TcVnVector4_LREAL& aUpperBounds, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aLowerBounds(aLowerBounds), aUpperBounds(aUpperBounds), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Check if the pixel values of an image lie in a given range. The destination image has the same size as the source image but only one channel with a pixel element size of 8 bit. Its elements are set to 255 if the corresponding pixels of the source image are in the checked range and set to 0 otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="aLowerBounds">Channel-wise lower bounds (Unused channels are ignored.)</param>
	/// <param name="aUpperBounds">Channel-wise upper bounds (Unused channels are ignored.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CheckColorRange(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnVector4_LREAL& aLowerBounds, TcVnVector4_LREAL& aUpperBounds)
	{
		Internal::CheckColorRange_Params params(ipSrcImage, ipDestImage, aLowerBounds, aUpperBounds, hrPrev);

		libraryInfo.functions[114 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CheckFunctionInitialization_Params
		{
			ETcVnInitializableFunction eFunction;
			ULONGLONG nOptions;
			HRESULT hrPrev;
			HRESULT retVal;

			CheckFunctionInitialization_Params(ETcVnInitializableFunction eFunction, ULONGLONG nOptions, HRESULT hrPrev) : eFunction(eFunction), nOptions(nOptions), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Check if a function is initialized with the specified options.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="eFunction">Initializable function</param>
	/// <param name="nOptions">Initialization options for the function</param>
	/// <returns>HRESULT</returns>
	static HRESULT CheckFunctionInitialization(HRESULT hrPrev, ETcVnInitializableFunction eFunction, ULONGLONG nOptions)
	{
		Internal::CheckFunctionInitialization_Params params(eFunction, nOptions, hrPrev);

		libraryInfo.functions[115 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CheckIfEmpty_Params
		{
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			CheckIfEmpty_Params(ITcVnContainer* ipContainer, HRESULT hrPrev) : ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Checks if the container is empty. (Alternatively use interface method .CheckIfEmpty.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container</param>
	/// <returns>HRESULT</returns>
	static HRESULT CheckIfEmpty(HRESULT hrPrev, ITcVnContainer* ipContainer)
	{
		Internal::CheckIfEmpty_Params params(ipContainer, hrPrev);

		libraryInfo.functions[116 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CheckIfIteratorIsAtEnd_Params
		{
			ITcVnForwardIterator* ipIterator;
			HRESULT hrPrev;
			HRESULT retVal;

			CheckIfIteratorIsAtEnd_Params(ITcVnForwardIterator* ipIterator, HRESULT hrPrev) : ipIterator(ipIterator), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Checks if the iterator points to the past-the-end element. (Alternatively use interface method .CheckIfEnd.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIterator">Iterator</param>
	/// <returns>HRESULT</returns>
	static HRESULT CheckIfIteratorIsAtEnd(HRESULT hrPrev, ITcVnForwardIterator* ipIterator)
	{
		Internal::CheckIfIteratorIsAtEnd_Params params(ipIterator, hrPrev);

		libraryInfo.functions[117 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CheckIfPointIsInsideContour_Params
		{
			ITcVnContainer* ipContour;
			VN_TcVnPoint2_REAL& aPoint;
			double& fDist;
			bool bMeasureDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			CheckIfPointIsInsideContour_Params(ITcVnContainer* ipContour, TcVnPoint2_REAL& aPoint, double& fDist, bool bMeasureDistance, HRESULT hrPrev) : ipContour(ipContour), aPoint(aPoint), fDist(fDist), bMeasureDistance(bMeasureDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Checks if a point is inside a contour (and optionally return the distance to it).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aPoint">Point position to check</param>
	/// <param name="fDist">Returns the result (&gt; 0: the point is inside the contour; 0: the point is on the contour; &lt; 0: the point is outside the contour)</param>
	/// <param name="bMeasureDistance">If true, fDist returns the distance to the nearest contour edge. Otherwise, fDist only returns -1, 0 or +1 (recommended to set to false if the distance is not required, as this is faster).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CheckIfPointIsInsideContour(HRESULT hrPrev, ITcVnContainer* ipContour, TcVnPoint2_REAL& aPoint, double& fDist, bool bMeasureDistance)
	{
		Internal::CheckIfPointIsInsideContour_Params params(ipContour, aPoint, fDist, bMeasureDistance, hrPrev);

		libraryInfo.functions[118 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct Clahe_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fClipLimit;
			ULONG nTilesX;
			ULONG nTilesY;
			HRESULT hrPrev;
			HRESULT retVal;

			Clahe_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fClipLimit, ULONG nTilesX, ULONG nTilesY, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fClipLimit(fClipLimit), nTilesX(nTilesX), nTilesY(nTilesY), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply Constrast Limited Adaptive Histogram Equalization. This applies local histogram equalization to individual tiles. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (TCVN_ET_USINT or TCVN_ET_UINT, 1 channel)</param>
	/// <param name="ipDestImage">Returns the resulting image (An appropriate image will be created if required.)</param>
	/// <param name="fClipLimit">Threshold for contrast limit (set to &lt;= 0 to disable clipping)</param>
	/// <param name="nTilesX">Number of tiles in x direction</param>
	/// <param name="nTilesY">Number of tiles in y direction</param>
	/// <returns>HRESULT</returns>
	static HRESULT Clahe(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fClipLimit = 40, ULONG nTilesX = 8, ULONG nTilesY = 8)
	{
		Internal::Clahe_Params params(ipSrcImage, ipDestImage, fClipLimit, nTilesX, nTilesY, hrPrev);

		libraryInfo.functions[119 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ClipLineToBoundary_Params
		{
			VN_TcVnVector4_LREAL& aLine;
			LONG nX1;
			LONG nY1;
			LONG nX2;
			LONG nY2;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			HRESULT hrPrev;
			HRESULT retVal;

			ClipLineToBoundary_Params(TcVnVector4_LREAL& aLine, LONG nX1, LONG nY1, LONG nX2, LONG nY2, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, HRESULT hrPrev) : aLine(aLine), nX1(nX1), nY1(nY1), nX2(nX2), nY2(nY2), aStartPoint(aStartPoint), aEndPoint(aEndPoint), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Clips a line to a rectangular boundary.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine">The first and second element describe the x and y component of the direction vector. The third and fourth element describe the x and y component of the position vector.</param>
	/// <param name="nX1">x of top left rectangle point</param>
	/// <param name="nY1">y of top left rectangle point</param>
	/// <param name="nX2">x of bottom right rectangle point</param>
	/// <param name="nY2">Y of bottom right rectangle point</param>
	/// <param name="aStartPoint">Returns the clipped starting point of the line.</param>
	/// <param name="aEndPoint">Returns the clipped end point of the line.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ClipLineToBoundary(HRESULT hrPrev, TcVnVector4_LREAL& aLine, LONG nX1, LONG nY1, LONG nX2, LONG nY2, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint)
	{
		Internal::ClipLineToBoundary_Params params(aLine, nX1, nY1, nX2, nY2, aStartPoint, aEndPoint, hrPrev);

		libraryInfo.functions[120 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ClipLineToBoundary_ITcVnImage_Params
		{
			VN_TcVnVector4_LREAL& aLine;
			ITcVnImage* ipImage;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			HRESULT hrPrev;
			HRESULT retVal;

			ClipLineToBoundary_ITcVnImage_Params(TcVnVector4_LREAL& aLine, ITcVnImage* ipImage, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, HRESULT hrPrev) : aLine(aLine), ipImage(ipImage), aStartPoint(aStartPoint), aEndPoint(aEndPoint), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Clips a line to the boundary of an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine">The first and second element describe the x and y component of the direction vector. The third and fourth element describe the x and y component of the position vector.</param>
	/// <param name="ipImage">Image, from which to derive the boundary</param>
	/// <param name="aStartPoint">Returns the clipped starting point of the line.</param>
	/// <param name="aEndPoint">Returns the clipped end point of the line.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ClipLineToBoundary(HRESULT hrPrev, TcVnVector4_LREAL& aLine, ITcVnImage* ipImage, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint)
	{
		Internal::ClipLineToBoundary_ITcVnImage_Params params(aLine, ipImage, aStartPoint, aEndPoint, hrPrev);

		libraryInfo.functions[121 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ClipLineToBoundary_TcVnRectangle_DINT_Params
		{
			VN_TcVnVector4_LREAL& aLine;
			TcVnRectangle_DINT& stRectangle;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			HRESULT hrPrev;
			HRESULT retVal;

			ClipLineToBoundary_TcVnRectangle_DINT_Params(TcVnVector4_LREAL& aLine, TcVnRectangle_DINT& stRectangle, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, HRESULT hrPrev) : aLine(aLine), stRectangle(stRectangle), aStartPoint(aStartPoint), aEndPoint(aEndPoint), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Clips a line to a rectangular boundary.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine">The first and second element describe the x and y component of the direction vector. The third and fourth element describe the x and y component of the position vector.</param>
	/// <param name="stRectangle">Rectangular boundary</param>
	/// <param name="aStartPoint">Returns the clipped starting point of the line.</param>
	/// <param name="aEndPoint">Returns the clipped end point of the line.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ClipLineToBoundary(HRESULT hrPrev, TcVnVector4_LREAL& aLine, TcVnRectangle_DINT& stRectangle, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint)
	{
		Internal::ClipLineToBoundary_TcVnRectangle_DINT_Params params(aLine, stRectangle, aStartPoint, aEndPoint, hrPrev);

		libraryInfo.functions[122 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CombineImageChannels_Params
		{
			PVOID pSrcImages;
			ITcVnImage*& ipDestImage;
			USHORT nSrcArraySize;
			HRESULT hrPrev;
			HRESULT retVal;

			CombineImageChannels_Params(PVOID pSrcImages, ITcVnImage*& ipDestImage, USHORT nSrcArraySize, HRESULT hrPrev) : pSrcImages(pSrcImages), ipDestImage(ipDestImage), nSrcArraySize(nSrcArraySize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Combines several single-channel images into one multi-channel image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="pSrcImages">Pointer to an array of single-channel source images</param>
	/// <param name="ipDestImage">Multi-channel destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="nSrcArraySize">pSrcImages array size</param>
	/// <returns>HRESULT</returns>
	static HRESULT CombineImageChannels(HRESULT hrPrev, PVOID pSrcImages, ITcVnImage*& ipDestImage, USHORT nSrcArraySize)
	{
		Internal::CombineImageChannels_Params params(pSrcImages, ipDestImage, nSrcArraySize, hrPrev);

		libraryInfo.functions[123 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConnectedComponents_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipLabelImage;
			LONG& nLabels;
			ETcVnPixelConnectivity eConnectivity;
			ETcVnElementType eLabelType;
			ETcVnConnectedComponentsAlgorithm eAlgorithm;
			HRESULT hrPrev;
			HRESULT retVal;

			ConnectedComponents_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipLabelImage, LONG& nLabels, ETcVnPixelConnectivity eConnectivity, ETcVnElementType eLabelType, ETcVnConnectedComponentsAlgorithm eAlgorithm, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipLabelImage(ipLabelImage), nLabels(nLabels), eConnectivity(eConnectivity), eLabelType(eLabelType), eAlgorithm(eAlgorithm), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the connected components of an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, binary)</param>
	/// <param name="ipLabelImage">Returns the labels for each source image pixel (1 channel, type depends on eLabelType. An appropriate destination image will be created if required.)</param>
	/// <param name="nLabels">Returns the number of labels</param>
	/// <param name="eConnectivity">Selects if 4- or 8-way pixel connectivity should be used</param>
	/// <param name="eLabelType">Selects the type of ipLabelImage (only UINT or DINT supported)</param>
	/// <param name="eAlgorithm">Selects the applied algorithm</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConnectedComponents(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipLabelImage, LONG& nLabels, ETcVnPixelConnectivity eConnectivity = PC_8, ETcVnElementType eLabelType = TCVN_ET_DINT, ETcVnConnectedComponentsAlgorithm eAlgorithm = CCA_GRANA)
	{
		Internal::ConnectedComponents_Params params(ipSrcImage, ipLabelImage, nLabels, eConnectivity, eLabelType, eAlgorithm, hrPrev);

		libraryInfo.functions[124 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConnectedComponentsWithStats_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipLabelImage;
			ITcVnContainer*& ipBoundingBoxes;
			ITcVnContainer*& ipNumPixels;
			ITcVnContainer*& ipCentroids;
			LONG& nLabels;
			ETcVnPixelConnectivity eConnectivity;
			ETcVnElementType eLabelType;
			ETcVnConnectedComponentsAlgorithm eAlgorithm;
			HRESULT hrPrev;
			HRESULT retVal;

			ConnectedComponentsWithStats_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipLabelImage, ITcVnContainer*& ipBoundingBoxes, ITcVnContainer*& ipNumPixels, ITcVnContainer*& ipCentroids, LONG& nLabels, ETcVnPixelConnectivity eConnectivity, ETcVnElementType eLabelType, ETcVnConnectedComponentsAlgorithm eAlgorithm, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipLabelImage(ipLabelImage), ipBoundingBoxes(ipBoundingBoxes), ipNumPixels(ipNumPixels), ipCentroids(ipCentroids), nLabels(nLabels), eConnectivity(eConnectivity), eLabelType(eLabelType), eAlgorithm(eAlgorithm), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the connected components and corresponding statistics of an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, binary)</param>
	/// <param name="ipLabelImage">Returns the labels for each source image pixel (1 channel, DINT. An appropriate destination image will be created if required.)</param>
	/// <param name="ipBoundingBoxes">Returns the bounding boxes for each labeled region. (ContainerType_Vector_TcVnRectangle_DINT; Non-zero interface pointers are reused.)</param>
	/// <param name="ipNumPixels">Returns the number of pixels for each labeled region. (ContainerType_Vector_DINT; Non-zero interface pointers are reused.)</param>
	/// <param name="ipCentroids">Returns the centroids for each labeled region. (ContainerType_Vector_TcVnPoint2_LREAL; Non-zero interface pointers are reused.)</param>
	/// <param name="nLabels">Returns the number of labels</param>
	/// <param name="eConnectivity">Selects if 4- or 8-way pixel connectivity should be used</param>
	/// <param name="eLabelType">Selects the type of ipLabelImage (only UINT or DINT supported)</param>
	/// <param name="eAlgorithm">Selects the applied algorithm</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConnectedComponentsWithStats(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipLabelImage, ITcVnContainer*& ipBoundingBoxes, ITcVnContainer*& ipNumPixels, ITcVnContainer*& ipCentroids, LONG& nLabels, ETcVnPixelConnectivity eConnectivity = PC_8, ETcVnElementType eLabelType = TCVN_ET_DINT, ETcVnConnectedComponentsAlgorithm eAlgorithm = CCA_GRANA)
	{
		Internal::ConnectedComponentsWithStats_Params params(ipSrcImage, ipLabelImage, ipBoundingBoxes, ipNumPixels, ipCentroids, nLabels, eConnectivity, eLabelType, eAlgorithm, hrPrev);

		libraryInfo.functions[125 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverage_Params
		{
			ITcVnContainer* ipSrcContainer;
			double& fAverage;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverage_Params(ITcVnContainer* ipSrcContainer, double& fAverage, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), fAverage(fAverage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the average of elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container (Arithmetic, point and vector element types are supported. For points and vectors, the euclidean norm is used.)</param>
	/// <param name="fAverage">Returns the calculated average value</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverage(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, double& fAverage)
	{
		Internal::ContainerAverage_Params params(ipSrcContainer, fAverage, hrPrev);

		libraryInfo.functions[126 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverageElementwise2_Params
		{
			ITcVnContainer* ipSrcContainer;
			VN_TcVnVector2_LREAL& aAverage;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverageElementwise2_Params(ITcVnContainer* ipSrcContainer, TcVnVector2_LREAL& aAverage, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), aAverage(aAverage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the elementwise average of 2D elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container with 2D points or vectors</param>
	/// <param name="aAverage">Returns the calculated average values</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverageElementwise(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, TcVnVector2_LREAL& aAverage)
	{
		Internal::ContainerAverageElementwise2_Params params(ipSrcContainer, aAverage, hrPrev);

		libraryInfo.functions[127 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverageElementwise3_Params
		{
			ITcVnContainer* ipSrcContainer;
			VN_TcVnVector3_LREAL& aAverage;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverageElementwise3_Params(ITcVnContainer* ipSrcContainer, TcVnVector3_LREAL& aAverage, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), aAverage(aAverage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the elementwise average of 3D elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container with 3D points or vectors</param>
	/// <param name="aAverage">Returns the calculated average values</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverageElementwise(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, TcVnVector3_LREAL& aAverage)
	{
		Internal::ContainerAverageElementwise3_Params params(ipSrcContainer, aAverage, hrPrev);

		libraryInfo.functions[128 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverageElementwise4_Params
		{
			ITcVnContainer* ipSrcContainer;
			VN_TcVnVector4_LREAL& aAverage;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverageElementwise4_Params(ITcVnContainer* ipSrcContainer, TcVnVector4_LREAL& aAverage, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), aAverage(aAverage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the elementwise average of 4D elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container with 4D vectors</param>
	/// <param name="aAverage">Returns the calculated average values</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverageElementwise(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, TcVnVector4_LREAL& aAverage)
	{
		Internal::ContainerAverageElementwise4_Params params(ipSrcContainer, aAverage, hrPrev);

		libraryInfo.functions[129 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverageVariance_Params
		{
			ITcVnContainer* ipSrcContainer;
			double& fAverage;
			double& fVariance;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverageVariance_Params(ITcVnContainer* ipSrcContainer, double& fAverage, double& fVariance, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), fAverage(fAverage), fVariance(fVariance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the average and variance of elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container (Arithmetic, point and vector element types are supported. For points and vectors, the euclidean norm is used.)</param>
	/// <param name="fAverage">Returns the calculated average value</param>
	/// <param name="fVariance">Returns the calculated variance value</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverageVariance(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, double& fAverage, double& fVariance)
	{
		Internal::ContainerAverageVariance_Params params(ipSrcContainer, fAverage, fVariance, hrPrev);

		libraryInfo.functions[130 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverageVarianceElementwise2_Params
		{
			ITcVnContainer* ipSrcContainer;
			VN_TcVnVector2_LREAL& aAverage;
			VN_TcVnVector2_LREAL& aVariance;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverageVarianceElementwise2_Params(ITcVnContainer* ipSrcContainer, TcVnVector2_LREAL& aAverage, TcVnVector2_LREAL& aVariance, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), aAverage(aAverage), aVariance(aVariance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the elementwise average and variance of 2D elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container with 2D points or vectors</param>
	/// <param name="aAverage">Returns the calculated average values</param>
	/// <param name="aVariance">Returns the calculated variance values</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverageVarianceElementwise(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, TcVnVector2_LREAL& aAverage, TcVnVector2_LREAL& aVariance)
	{
		Internal::ContainerAverageVarianceElementwise2_Params params(ipSrcContainer, aAverage, aVariance, hrPrev);

		libraryInfo.functions[131 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverageVarianceElementwise3_Params
		{
			ITcVnContainer* ipSrcContainer;
			VN_TcVnVector3_LREAL& aAverage;
			VN_TcVnVector3_LREAL& aVariance;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverageVarianceElementwise3_Params(ITcVnContainer* ipSrcContainer, TcVnVector3_LREAL& aAverage, TcVnVector3_LREAL& aVariance, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), aAverage(aAverage), aVariance(aVariance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the elementwise average and variance of 3D elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container with 3D points or vectors</param>
	/// <param name="aAverage">Returns the calculated average values</param>
	/// <param name="aVariance">Returns the calculated variance values</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverageVarianceElementwise(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, TcVnVector3_LREAL& aAverage, TcVnVector3_LREAL& aVariance)
	{
		Internal::ContainerAverageVarianceElementwise3_Params params(ipSrcContainer, aAverage, aVariance, hrPrev);

		libraryInfo.functions[132 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContainerAverageVarianceElementwise4_Params
		{
			ITcVnContainer* ipSrcContainer;
			VN_TcVnVector4_LREAL& aAverage;
			VN_TcVnVector4_LREAL& aVariance;
			HRESULT hrPrev;
			HRESULT retVal;

			ContainerAverageVarianceElementwise4_Params(ITcVnContainer* ipSrcContainer, TcVnVector4_LREAL& aAverage, TcVnVector4_LREAL& aVariance, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), aAverage(aAverage), aVariance(aVariance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the elementwise average and variance of 4D elements in a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container with 4D vectors</param>
	/// <param name="aAverage">Returns the calculated average values</param>
	/// <param name="aVariance">Returns the calculated variance values</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContainerAverageVarianceElementwise(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, TcVnVector4_LREAL& aAverage, TcVnVector4_LREAL& aVariance)
	{
		Internal::ContainerAverageVarianceElementwise4_Params params(ipSrcContainer, aAverage, aVariance, hrPrev);

		libraryInfo.functions[133 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourArea_Params
		{
			ITcVnContainer* ipContour;
			double& fArea;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourArea_Params(ITcVnContainer* ipContour, double& fArea, HRESULT hrPrev) : ipContour(ipContour), fArea(fArea), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Estimate the contour area using Green's formula.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fArea">Returns the estimated contour area (The actual contour area may differ depending on the shape of the contour.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourArea(HRESULT hrPrev, ITcVnContainer* ipContour, double& fArea)
	{
		Internal::ContourArea_Params params(ipContour, fArea, hrPrev);

		libraryInfo.functions[134 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourCenterOfMass_Params
		{
			ITcVnContainer* ipContour;
			VN_TcVnPoint2_LREAL& aCenterOfMass;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourCenterOfMass_Params(ITcVnContainer* ipContour, TcVnPoint2_LREAL& aCenterOfMass, HRESULT hrPrev) : ipContour(ipContour), aCenterOfMass(aCenterOfMass), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the center of mass of a contour.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="aCenterOfMass">Returns the center of mass of the contour</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourCenterOfMass(HRESULT hrPrev, ITcVnContainer* ipContour, TcVnPoint2_LREAL& aCenterOfMass)
	{
		Internal::ContourCenterOfMass_Params params(ipContour, aCenterOfMass, hrPrev);

		libraryInfo.functions[135 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourCircularity_Params
		{
			ITcVnContainer* ipContour;
			double& fCircularity;
			ETcVnCircularityCalculationMethod eMethod;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourCircularity_Params(ITcVnContainer* ipContour, double& fCircularity, ETcVnCircularityCalculationMethod eMethod, HRESULT hrPrev) : ipContour(ipContour), fCircularity(fCircularity), eMethod(eMethod), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the circularity of a contour (1.0: ideal circle, 0.0: straight line). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fCircularity">Returns the circularity of the contour [0..1]</param>
	/// <param name="eMethod">Method used for computing the circularity</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourCircularity(HRESULT hrPrev, ITcVnContainer* ipContour, double& fCircularity, ETcVnCircularityCalculationMethod eMethod = CCM_DEFAULT)
	{
		Internal::ContourCircularity_Params params(ipContour, fCircularity, eMethod, hrPrev);

		libraryInfo.functions[136 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourConvexity_Params
		{
			ITcVnContainer* ipContour;
			double& fConvexity;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourConvexity_Params(ITcVnContainer* ipContour, double& fConvexity, HRESULT hrPrev) : ipContour(ipContour), fConvexity(fConvexity), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the convexity of a contour as the ratio between the contour's area and the area of the convex hull (1.0: convex shapes (i.e. rectangle, circle, ..., etc.), 0.0: zero area (i.e. a line or an empty contour)).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fConvexity">Returns the convexity of the contour [0..1]</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourConvexity(HRESULT hrPrev, ITcVnContainer* ipContour, double& fConvexity)
	{
		Internal::ContourConvexity_Params params(ipContour, fConvexity, hrPrev);

		libraryInfo.functions[137 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourEccentricity_Params
		{
			ITcVnContainer* ipContour;
			double& fEccentricity;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourEccentricity_Params(ITcVnContainer* ipContour, double& fEccentricity, HRESULT hrPrev) : ipContour(ipContour), fEccentricity(fEccentricity), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the eccentricity of a contour (0.0: circular, 1.0: linear).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fEccentricity">Returns the eccentricity of the contour [0..1]</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourEccentricity(HRESULT hrPrev, ITcVnContainer* ipContour, double& fEccentricity)
	{
		Internal::ContourEccentricity_Params params(ipContour, fEccentricity, hrPrev);

		libraryInfo.functions[138 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourElongation_Params
		{
			ITcVnContainer* ipContour;
			double& fElongation;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourElongation_Params(ITcVnContainer* ipContour, double& fElongation, HRESULT hrPrev) : ipContour(ipContour), fElongation(fElongation), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the elongation factor of a contour.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fElongation">Returns the elongation of the contour</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourElongation(HRESULT hrPrev, ITcVnContainer* ipContour, double& fElongation)
	{
		Internal::ContourElongation_Params params(ipContour, fElongation, hrPrev);

		libraryInfo.functions[139 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourExtremePoint_Params
		{
			ITcVnContainer* ipContour;
			ETcVnExtremePointDirection eDirection;
			VN_TcVnPoint2_LREAL& aExtremePoint;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourExtremePoint_Params(ITcVnContainer* ipContour, ETcVnExtremePointDirection eDirection, TcVnPoint2_LREAL& aExtremePoint, HRESULT hrPrev) : ipContour(ipContour), eDirection(eDirection), aExtremePoint(aExtremePoint), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Finds the contour extreme point.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Source container with 2D points (TcVnPoint2_DINT or TcVnPoint2_REAL or TcVnPoint2_LREAL)</param>
	/// <param name="eDirection">Selects the search direction for the extreme point</param>
	/// <param name="aExtremePoint">Returns the extreme point of the contour, according to eDirection</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourExtremePoint(HRESULT hrPrev, ITcVnContainer* ipContour, ETcVnExtremePointDirection eDirection, TcVnPoint2_LREAL& aExtremePoint)
	{
		Internal::ContourExtremePoint_Params params(ipContour, eDirection, aExtremePoint, hrPrev);

		libraryInfo.functions[140 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourInertiaRatio_Params
		{
			ITcVnContainer* ipContour;
			double& fInertiaRatio;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourInertiaRatio_Params(ITcVnContainer* ipContour, double& fInertiaRatio, HRESULT hrPrev) : ipContour(ipContour), fInertiaRatio(fInertiaRatio), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the inertia ratio of a contour which reflects how a contour/shape is elongated (i.e. circle: 1.0, line: 0.0).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fInertiaRatio">Returns the inertia raio of the contour [0..1]</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourInertiaRatio(HRESULT hrPrev, ITcVnContainer* ipContour, double& fInertiaRatio)
	{
		Internal::ContourInertiaRatio_Params params(ipContour, fInertiaRatio, hrPrev);

		libraryInfo.functions[141 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourMoments_Params
		{
			ITcVnContainer* ipContour;
			TcVnMoments& stMoments;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourMoments_Params(ITcVnContainer* ipContour, TcVnMoments& stMoments, HRESULT hrPrev) : ipContour(ipContour), stMoments(stMoments), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the spatial moments, the central moments, and the central normalized moments of a contour up to the third order.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="stMoments">Returns a struct containing the moments</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourMoments(HRESULT hrPrev, ITcVnContainer* ipContour, TcVnMoments& stMoments)
	{
		Internal::ContourMoments_Params params(ipContour, stMoments, hrPrev);

		libraryInfo.functions[142 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourOrientation_Params
		{
			ITcVnContainer* ipContour;
			TcVnRotatedRectangle& stOrientation;
			ETcVnOrientationMethod eMethod;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourOrientation_Params(ITcVnContainer* ipContour, TcVnRotatedRectangle& stOrientation, ETcVnOrientationMethod eMethod, HRESULT hrPrev) : ipContour(ipContour), stOrientation(stOrientation), eMethod(eMethod), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the orientation of a contour or a set of points. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Source point set (ContainerType_Vector_TcVnPoint2_DINT, ContainerType_Vector_TcVnPoint2_REAL, or ContainerType_Vector_TcVnPoint2_LREAL. The elements of this container are the individual points.)</param>
	/// <param name="stOrientation">Resulting rotated rectangle, containig center of mass, lenghts of axes, and rotation angle of the contour in clockwise direction.</param>
	/// <param name="eMethod">Method for calculating the orientation. </param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourOrientation(HRESULT hrPrev, ITcVnContainer* ipContour, TcVnRotatedRectangle& stOrientation, ETcVnOrientationMethod eMethod = OM_PCA)
	{
		Internal::ContourOrientation_Params params(ipContour, stOrientation, eMethod, hrPrev);

		libraryInfo.functions[143 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourPerimeter_Params
		{
			ITcVnContainer* ipContour;
			double& fPerimeter;
			bool bClosed;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourPerimeter_Params(ITcVnContainer* ipContour, double& fPerimeter, bool bClosed, HRESULT hrPrev) : ipContour(ipContour), fPerimeter(fPerimeter), bClosed(bClosed), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the perimeter of a contour (curve length if the contour is not closed).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fPerimeter">Returns the perimeter of the contour</param>
	/// <param name="bClosed">Specifys, if the contour is closed (first and last points connected) or not</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourPerimeter(HRESULT hrPrev, ITcVnContainer* ipContour, double& fPerimeter, bool bClosed)
	{
		Internal::ContourPerimeter_Params params(ipContour, fPerimeter, bClosed, hrPrev);

		libraryInfo.functions[144 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ContourRoundness_Params
		{
			ITcVnContainer* ipContour;
			double& fRoundness;
			HRESULT hrPrev;
			HRESULT retVal;

			ContourRoundness_Params(ITcVnContainer* ipContour, double& fRoundness, HRESULT hrPrev) : ipContour(ipContour), fRoundness(fRoundness), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the roundness of a contour (perimeter^2 / area).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Single contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour.)</param>
	/// <param name="fRoundness">Returns the roundness of the contour</param>
	/// <returns>HRESULT</returns>
	static HRESULT ContourRoundness(HRESULT hrPrev, ITcVnContainer* ipContour, double& fRoundness)
	{
		Internal::ContourRoundness_Params params(ipContour, fRoundness, hrPrev);

		libraryInfo.functions[145 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertCartesianToPolarAngleImage_Params
		{
			ITcVnImage* ipSrcImageX;
			ITcVnImage* ipSrcImageY;
			ITcVnImage*& ipDestImageAng;
			bool bAngleInDegrees;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertCartesianToPolarAngleImage_Params(ITcVnImage* ipSrcImageX, ITcVnImage* ipSrcImageY, ITcVnImage*& ipDestImageAng, bool bAngleInDegrees, HRESULT hrPrev) : ipSrcImageX(ipSrcImageX), ipSrcImageY(ipSrcImageY), ipDestImageAng(ipDestImageAng), bAngleInDegrees(bAngleInDegrees), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts cartesian coordinates (x, y) to polar angle. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImageX">Source image containing the x values (elements of type REAL or LREAL)</param>
	/// <param name="ipSrcImageY">Source image containing the y values (Same element type as ipSrcImageX)</param>
	/// <param name="ipDestImageAng">Destination image containing the angles (Same element type as source images. An appropriate destination image will be created if required.)</param>
	/// <param name="bAngleInDegrees">Specifys, if the angles should be in degrees or radians</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertCartesianToPolarAngleImage(HRESULT hrPrev, ITcVnImage* ipSrcImageX, ITcVnImage* ipSrcImageY, ITcVnImage*& ipDestImageAng, bool bAngleInDegrees = false)
	{
		Internal::ConvertCartesianToPolarAngleImage_Params params(ipSrcImageX, ipSrcImageY, ipDestImageAng, bAngleInDegrees, hrPrev);

		libraryInfo.functions[146 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertCartesianToPolarAngles_Params
		{
			ITcVnContainer* ipSrcPointsCart;
			ITcVnContainer*& ipDestAngles;
			bool bAngleInDegrees;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertCartesianToPolarAngles_Params(ITcVnContainer* ipSrcPointsCart, ITcVnContainer*& ipDestAngles, bool bAngleInDegrees, HRESULT hrPrev) : ipSrcPointsCart(ipSrcPointsCart), ipDestAngles(ipDestAngles), bAngleInDegrees(bAngleInDegrees), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts cartesian coordinates (x, y) to polar angle. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPointsCart">Container with cartesian points (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_LREAL)</param>
	/// <param name="ipDestAngles">Returns a container which is filled with the angles (ContainerType_Vector_REAL, if source points are of type TcVnPoint2_DINT or TcVnPoint2_REAL; else ContainerType_Vector_LREAL. Non-zero interface pointers are reused.)</param>
	/// <param name="bAngleInDegrees">Specify, if the angles should be in degrees or radians</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertCartesianToPolarAngles(HRESULT hrPrev, ITcVnContainer* ipSrcPointsCart, ITcVnContainer*& ipDestAngles, bool bAngleInDegrees = false)
	{
		Internal::ConvertCartesianToPolarAngles_Params params(ipSrcPointsCart, ipDestAngles, bAngleInDegrees, hrPrev);

		libraryInfo.functions[147 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertCartesianToPolarImages_Params
		{
			ITcVnImage* ipSrcImageX;
			ITcVnImage* ipSrcImageY;
			ITcVnImage*& ipDestImageMag;
			ITcVnImage*& ipDestImageAng;
			bool bAngleInDegrees;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertCartesianToPolarImages_Params(ITcVnImage* ipSrcImageX, ITcVnImage* ipSrcImageY, ITcVnImage*& ipDestImageMag, ITcVnImage*& ipDestImageAng, bool bAngleInDegrees, HRESULT hrPrev) : ipSrcImageX(ipSrcImageX), ipSrcImageY(ipSrcImageY), ipDestImageMag(ipDestImageMag), ipDestImageAng(ipDestImageAng), bAngleInDegrees(bAngleInDegrees), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts cartesian coordinates (x, y) to polar coordinates (magnitude, angle). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImageX">Source image containing the x values (elements of type REAL or LREAL)</param>
	/// <param name="ipSrcImageY">Source image containing the y values (Same element type as ipSrcImageX)</param>
	/// <param name="ipDestImageMag">Destination image containing the magnitudes (Same element type as source images. An appropriate destination image will be created if required.)</param>
	/// <param name="ipDestImageAng">Destination image containing the angles (Same element type as source images. An appropriate destination image will be created if required.)</param>
	/// <param name="bAngleInDegrees">Specifys, if the angles should be in degrees or radians</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertCartesianToPolarImages(HRESULT hrPrev, ITcVnImage* ipSrcImageX, ITcVnImage* ipSrcImageY, ITcVnImage*& ipDestImageMag, ITcVnImage*& ipDestImageAng, bool bAngleInDegrees = false)
	{
		Internal::ConvertCartesianToPolarImages_Params params(ipSrcImageX, ipSrcImageY, ipDestImageMag, ipDestImageAng, bAngleInDegrees, hrPrev);

		libraryInfo.functions[148 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertCartesianToPolarMagnitudeImage_Params
		{
			ITcVnImage* ipSrcImageX;
			ITcVnImage* ipSrcImageY;
			ITcVnImage*& ipDestImageMag;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertCartesianToPolarMagnitudeImage_Params(ITcVnImage* ipSrcImageX, ITcVnImage* ipSrcImageY, ITcVnImage*& ipDestImageMag, HRESULT hrPrev) : ipSrcImageX(ipSrcImageX), ipSrcImageY(ipSrcImageY), ipDestImageMag(ipDestImageMag), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts cartesian coordinates (x, y) to polar magnitude.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImageX">Source image containing the x values (elements of type REAL or LREAL)</param>
	/// <param name="ipSrcImageY">Source image containing the y values (Same element type as ipSrcImageX)</param>
	/// <param name="ipDestImageMag">Destination image containing the magnitudes (Same element type as source images. An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertCartesianToPolarMagnitudeImage(HRESULT hrPrev, ITcVnImage* ipSrcImageX, ITcVnImage* ipSrcImageY, ITcVnImage*& ipDestImageMag)
	{
		Internal::ConvertCartesianToPolarMagnitudeImage_Params params(ipSrcImageX, ipSrcImageY, ipDestImageMag, hrPrev);

		libraryInfo.functions[149 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertCartesianToPolarMagnitudes_Params
		{
			ITcVnContainer* ipSrcPointsCart;
			ITcVnContainer*& ipDestMags;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertCartesianToPolarMagnitudes_Params(ITcVnContainer* ipSrcPointsCart, ITcVnContainer*& ipDestMags, HRESULT hrPrev) : ipSrcPointsCart(ipSrcPointsCart), ipDestMags(ipDestMags), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts cartesian coordinates (x, y) to polar magnitude.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPointsCart">Container with cartesian points (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_LREAL)</param>
	/// <param name="ipDestMags">Returns a container which is filled with the magnitudes (ContainerType_Vector_REAL, if source points are of type TcVnPoint2_DINT or TcVnPoint2_REAL; else ContainerType_Vector_LREAL. Non-zero interface pointers are reused.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertCartesianToPolarMagnitudes(HRESULT hrPrev, ITcVnContainer* ipSrcPointsCart, ITcVnContainer*& ipDestMags)
	{
		Internal::ConvertCartesianToPolarMagnitudes_Params params(ipSrcPointsCart, ipDestMags, hrPrev);

		libraryInfo.functions[150 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertCartesianToPolarPoints_Params
		{
			ITcVnContainer* ipSrcPointsCart;
			ITcVnContainer*& ipDestPointsPolar;
			bool bAngleInDegrees;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertCartesianToPolarPoints_Params(ITcVnContainer* ipSrcPointsCart, ITcVnContainer*& ipDestPointsPolar, bool bAngleInDegrees, HRESULT hrPrev) : ipSrcPointsCart(ipSrcPointsCart), ipDestPointsPolar(ipDestPointsPolar), bAngleInDegrees(bAngleInDegrees), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts cartesian coordinates (x, y) to polar coordinates (magnitude, angle). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPointsCart">Container with cartesian points (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_LREAL)</param>
	/// <param name="ipDestPointsPolar">Returns a container which is filled with the converted points in polar coordinates (ContainerType_Vector_TcVnPoint2_REAL, if source points are of type TcVnPoint2_DINT or TcVnPoint2_REAL; else ContainerType_Vector_TcVnPoint2_LREAL. Non-zero interface pointers are reused.)</param>
	/// <param name="bAngleInDegrees">Specifys, if the angles should be in degrees or radians</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertCartesianToPolarPoints(HRESULT hrPrev, ITcVnContainer* ipSrcPointsCart, ITcVnContainer*& ipDestPointsPolar, bool bAngleInDegrees = false)
	{
		Internal::ConvertCartesianToPolarPoints_Params params(ipSrcPointsCart, ipDestPointsPolar, bAngleInDegrees, hrPrev);

		libraryInfo.functions[151 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertColorSpace_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnColorSpaceTransform eTransform;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertColorSpace_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnColorSpaceTransform eTransform, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eTransform(eTransform), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Convert image from one color space to another.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eTransform">Transforms to be applied</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertColorSpace(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnColorSpaceTransform eTransform)
	{
		Internal::ConvertColorSpace_Params params(ipSrcImage, ipDestImage, eTransform, hrPrev);

		libraryInfo.functions[152 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertContainerType_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			GUID nDestTypeGuid;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertContainerType_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, GUID nDestTypeGuid, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), nDestTypeGuid(nDestTypeGuid), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts a container to another type (Struct element types are not supported).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container</param>
	/// <param name="ipDestContainer">Returns the converted container</param>
	/// <param name="nDestTypeGuid">Specifies the destination container type for the conversion</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertContainerType(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, GUID nDestTypeGuid)
	{
		Internal::ConvertContainerType_Params params(ipSrcContainer, ipDestContainer, nDestTypeGuid, hrPrev);

		libraryInfo.functions[153 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertDataLayout_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ULONGLONG nSrcDataLayout;
			ULONGLONG nDestDataLayout;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertDataLayout_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONGLONG nSrcDataLayout, ULONGLONG nDestDataLayout, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nSrcDataLayout(nSrcDataLayout), nDestDataLayout(nDestDataLayout), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Convert a data layout (the arrangement of dimensions in the input data) to another data layout.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="nSrcDataLayout">Data layout of the source image (Commonly used data layouts are available in the enumeration ETcVnDataLayout. If nSrcDataLayout is set to 0 or TCVN_DL_DEFAULT, the DataLayout will be automatically determined based on the dimension of the ipSrcImage: 0x12 for 2D, 0x123 for 3D, 0x1234 for 4D, and so forth.)</param>
	/// <param name="nDestDataLayout">Required output data layout (Commonly used data layouts are available in the enumeration ETcVnDataLayout. nDestDataLayout must not equal 0 or TCVN_DL_DEFAULT.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertDataLayout(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONGLONG nSrcDataLayout, ULONGLONG nDestDataLayout)
	{
		Internal::ConvertDataLayout_Params params(ipSrcImage, ipDestImage, nSrcDataLayout, nDestDataLayout, hrPrev);

		libraryInfo.functions[154 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertElementType_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnElementType eElementType;
			double fScaleFactor;
			double fDelta;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertElementType_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eElementType, double fScaleFactor, double fDelta, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eElementType(eElementType), fScaleFactor(fScaleFactor), fDelta(fDelta), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts an image to another element type. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eElementType">Desired element type of the destination image</param>
	/// <param name="fScaleFactor">Scale factor for the pixel values</param>
	/// <param name="fDelta">Value that is added to the scaled pixel values</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertElementType(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eElementType, double fScaleFactor = 1, double fDelta = 0)
	{
		Internal::ConvertElementType_Params params(ipSrcImage, ipDestImage, eElementType, fScaleFactor, fDelta, hrPrev);

		libraryInfo.functions[155 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertITcUnknownToITcVnBitmapExport_Params
		{
			ITcUnknown*& ipSrc;
			ITcVnBitmapExport*& ipDest;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertITcUnknownToITcVnBitmapExport_Params(ITcUnknown*& ipSrc, ITcVnBitmapExport*& ipDest, HRESULT hrPrev) : ipSrc(ipSrc), ipDest(ipDest), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Convert an ITcUnknown interface pointer to an ITcVnBitmapExport interface pointer. The destination pointer will be released (if existing) and set to the source pointer. The source pointer will be set to 0.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrc">Source pointer</param>
	/// <param name="ipDest">Destination pointer</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertITcUnknownToITcVnBitmapExport(HRESULT hrPrev, ITcUnknown*& ipSrc, ITcVnBitmapExport*& ipDest)
	{
		Internal::ConvertITcUnknownToITcVnBitmapExport_Params params(ipSrc, ipDest, hrPrev);

		libraryInfo.functions[156 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertITcUnknownToITcVnContainer_Params
		{
			ITcUnknown*& ipSrc;
			ITcVnContainer*& ipDest;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertITcUnknownToITcVnContainer_Params(ITcUnknown*& ipSrc, ITcVnContainer*& ipDest, HRESULT hrPrev) : ipSrc(ipSrc), ipDest(ipDest), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Convert an ITcUnknown interface pointer to an ITcVnContainer interface pointer. The destination pointer will be released (if existing) and set to the source pointer. The source pointer will be set to 0.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrc">Source pointer</param>
	/// <param name="ipDest">Destination pointer</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertITcUnknownToITcVnContainer(HRESULT hrPrev, ITcUnknown*& ipSrc, ITcVnContainer*& ipDest)
	{
		Internal::ConvertITcUnknownToITcVnContainer_Params params(ipSrc, ipDest, hrPrev);

		libraryInfo.functions[157 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertITcUnknownToITcVnImage_Params
		{
			ITcUnknown*& ipSrc;
			ITcVnImage*& ipDest;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertITcUnknownToITcVnImage_Params(ITcUnknown*& ipSrc, ITcVnImage*& ipDest, HRESULT hrPrev) : ipSrc(ipSrc), ipDest(ipDest), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Convert an ITcUnknown interface pointer to an ITcVnImage interface pointer. The destination pointer will be released (if existing) and set to the source pointer. The source pointer will be set to 0.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrc">Source pointer</param>
	/// <param name="ipDest">Destination pointer</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertITcUnknownToITcVnImage(HRESULT hrPrev, ITcUnknown*& ipSrc, ITcVnImage*& ipDest)
	{
		Internal::ConvertITcUnknownToITcVnImage_Params params(ipSrc, ipDest, hrPrev);

		libraryInfo.functions[158 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertITcUnknownToITcVnMlModel_Params
		{
			ITcUnknown*& ipSrc;
			ITcVnMlModel*& ipDest;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertITcUnknownToITcVnMlModel_Params(ITcUnknown*& ipSrc, ITcVnMlModel*& ipDest, HRESULT hrPrev) : ipSrc(ipSrc), ipDest(ipDest), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Convert an ITcUnknown interface pointer to an ITcVnMlModel interface pointer. The destination pointer will be released (if existing) and set to the source pointer. The source pointer will be set to 0.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrc">Source pointer</param>
	/// <param name="ipDest">Destination pointer</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertITcUnknownToITcVnMlModel(HRESULT hrPrev, ITcUnknown*& ipSrc, ITcVnMlModel*& ipDest)
	{
		Internal::ConvertITcUnknownToITcVnMlModel_Params params(ipSrc, ipDest, hrPrev);

		libraryInfo.functions[159 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertPolarToCartesianImages_Params
		{
			ITcVnImage* ipSrcImageMag;
			ITcVnImage* ipSrcImageAng;
			ITcVnImage*& ipDestImageX;
			ITcVnImage*& ipDestImageY;
			bool bAngleInDegrees;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertPolarToCartesianImages_Params(ITcVnImage* ipSrcImageMag, ITcVnImage* ipSrcImageAng, ITcVnImage*& ipDestImageX, ITcVnImage*& ipDestImageY, bool bAngleInDegrees, HRESULT hrPrev) : ipSrcImageMag(ipSrcImageMag), ipSrcImageAng(ipSrcImageAng), ipDestImageX(ipDestImageX), ipDestImageY(ipDestImageY), bAngleInDegrees(bAngleInDegrees), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts polar coordinates (magnitude, angle) to cartesian coordinates (x, y). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImageMag">Source image containing the magnitudes (elements of type REAL or LREAL)</param>
	/// <param name="ipSrcImageAng">Source image containing the angles (Same element type as ipSrcImageMag)</param>
	/// <param name="ipDestImageX">Destination image containing the x values (Same element type as source images. An appropriate destination image will be created if required.)</param>
	/// <param name="ipDestImageY">Destination image containing the y values (Same element type as source images. An appropriate destination image will be created if required.)</param>
	/// <param name="bAngleInDegrees">Specifys, if the angles are in degrees or radians</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertPolarToCartesianImages(HRESULT hrPrev, ITcVnImage* ipSrcImageMag, ITcVnImage* ipSrcImageAng, ITcVnImage*& ipDestImageX, ITcVnImage*& ipDestImageY, bool bAngleInDegrees = false)
	{
		Internal::ConvertPolarToCartesianImages_Params params(ipSrcImageMag, ipSrcImageAng, ipDestImageX, ipDestImageY, bAngleInDegrees, hrPrev);

		libraryInfo.functions[160 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvertPolarToCartesianPoints_Params
		{
			ITcVnContainer* ipSrcPointsPolar;
			ITcVnContainer*& ipDestPointsCart;
			bool bAngleInDegrees;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvertPolarToCartesianPoints_Params(ITcVnContainer* ipSrcPointsPolar, ITcVnContainer*& ipDestPointsCart, bool bAngleInDegrees, HRESULT hrPrev) : ipSrcPointsPolar(ipSrcPointsPolar), ipDestPointsCart(ipDestPointsCart), bAngleInDegrees(bAngleInDegrees), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Converts polar coordinates (magnitude, angle) to cartesian coordinates (x, y). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPointsPolar">Container with polar coordinates (ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_LREAL)</param>
	/// <param name="ipDestPointsCart">Returns a container which is filled with the converted points in cartesian coordinates (same type ID as ipSrcPointsPolar. Non-zero interface pointers are reused.)</param>
	/// <param name="bAngleInDegrees">Specifys, if the angles are in degrees or radians</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvertPolarToCartesianPoints(HRESULT hrPrev, ITcVnContainer* ipSrcPointsPolar, ITcVnContainer*& ipDestPointsCart, bool bAngleInDegrees = false)
	{
		Internal::ConvertPolarToCartesianPoints_Params params(ipSrcPointsPolar, ipDestPointsCart, bAngleInDegrees, hrPrev);

		libraryInfo.functions[161 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvexHullPoints_Params
		{
			ITcVnContainer* ipPointSet;
			ITcVnContainer*& ipConvexHull;
			bool bClockwise;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvexHullPoints_Params(ITcVnContainer* ipPointSet, ITcVnContainer*& ipConvexHull, bool bClockwise, HRESULT hrPrev) : ipPointSet(ipPointSet), ipConvexHull(ipConvexHull), bClockwise(bClockwise), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Determines the convex hull of a point set. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the individual points.)</param>
	/// <param name="ipConvexHull">Returns a container which is filled with the sorted convex hull points (same type ID as ipPointSet; Non-zero interface pointers are reused.)</param>
	/// <param name="bClockwise">Selects the sorting direction of the hull points, assuming cartesian coordinates.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvexHullPoints(HRESULT hrPrev, ITcVnContainer* ipPointSet, ITcVnContainer*& ipConvexHull, bool bClockwise = false)
	{
		Internal::ConvexHullPoints_Params params(ipPointSet, ipConvexHull, bClockwise, hrPrev);

		libraryInfo.functions[162 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ConvexityDefects_Params
		{
			ITcVnContainer* ipContour;
			ITcVnContainer*& ipConvexityDefects;
			HRESULT hrPrev;
			HRESULT retVal;

			ConvexityDefects_Params(ITcVnContainer* ipContour, ITcVnContainer*& ipConvexityDefects, HRESULT hrPrev) : ipContour(ipContour), ipConvexityDefects(ipConvexityDefects), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Finds the convexity defects of a point set.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Source contour (ContainerType_Vector_TcVnPoint2_DINT; The elements of this container are the individual points.)</param>
	/// <param name="ipConvexityDefects">Returns a container which is filled with the convexity defects (ContainerType_Vector_TcVnVector4_DINT with [startIndex, endIndex, furthestPointIndex, fixedPointDistance (8 fraction bits, i.e. divide by 256 to get the distance in pixels)]; Non-zero interface pointers are reused.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ConvexityDefects(HRESULT hrPrev, ITcVnContainer* ipContour, ITcVnContainer*& ipConvexityDefects)
	{
		Internal::ConvexityDefects_Params params(ipContour, ipConvexityDefects, hrPrev);

		libraryInfo.functions[163 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CopyContainer_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			CopyContainer_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Copys a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container</param>
	/// <param name="ipDestContainer">Destination container (same type ID as ipSrcContainer; Non-zero interface pointers are reused.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CopyContainer(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer)
	{
		Internal::CopyContainer_Params params(ipSrcContainer, ipDestContainer, hrPrev);

		libraryInfo.functions[164 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CopyContainerElementsConditional_ITcVnContainer_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			ITcVnCustomElementCondition_ITcVnContainer* ipConditionFB;
			HRESULT hrPrev;
			HRESULT retVal;

			CopyContainerElementsConditional_ITcVnContainer_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ITcVnCustomElementCondition_ITcVnContainer* ipConditionFB, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), ipConditionFB(ipConditionFB), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Copys container elements to a new container, depending on a custom condition.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container</param>
	/// <param name="ipDestContainer">Returns a container with elements, that match the condition</param>
	/// <param name="ipConditionFB">Custom condition</param>
	/// <returns>HRESULT</returns>
	static HRESULT CopyContainerElementsConditional(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ITcVnCustomElementCondition_ITcVnContainer* ipConditionFB)
	{
		Internal::CopyContainerElementsConditional_ITcVnContainer_Params params(ipSrcContainer, ipDestContainer, ipConditionFB, hrPrev);

		libraryInfo.functions[165 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CopyContainerElementsConditional_ITcVnForwardIterator_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			ITcVnCustomElementCondition_ITcVnForwardIterator* ipConditionFB;
			HRESULT hrPrev;
			HRESULT retVal;

			CopyContainerElementsConditional_ITcVnForwardIterator_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ITcVnCustomElementCondition_ITcVnForwardIterator* ipConditionFB, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), ipConditionFB(ipConditionFB), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Copys container elements to a new container, depending on a custom condition.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container</param>
	/// <param name="ipDestContainer">Returns a container with elements, that match the condition</param>
	/// <param name="ipConditionFB">Custom condition</param>
	/// <returns>HRESULT</returns>
	static HRESULT CopyContainerElementsConditional(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ITcVnCustomElementCondition_ITcVnForwardIterator* ipConditionFB)
	{
		Internal::CopyContainerElementsConditional_ITcVnForwardIterator_Params params(ipSrcContainer, ipDestContainer, ipConditionFB, hrPrev);

		libraryInfo.functions[166 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CopyImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			CopyImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a deep copy of an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CopyImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::CopyImage_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[167 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CopyImageRegion_Params
		{
			ITcVnImage* ipSrcImage;
			ULONG nX;
			ULONG nY;
			ULONG nWidth;
			ULONG nHeight;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			CopyImageRegion_Params(ITcVnImage* ipSrcImage, ULONG nX, ULONG nY, ULONG nWidth, ULONG nHeight, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), nX(nX), nY(nY), nWidth(nWidth), nHeight(nHeight), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Deep copy the specified region of interest into a new image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="nX">Left boundary (inclusive 0-based index)</param>
	/// <param name="nY">Upper boundary (inclusive 0-based index)</param>
	/// <param name="nWidth">ROI width</param>
	/// <param name="nHeight">ROI height</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CopyImageRegion(HRESULT hrPrev, ITcVnImage* ipSrcImage, ULONG nX, ULONG nY, ULONG nWidth, ULONG nHeight, ITcVnImage*& ipDestImage)
	{
		Internal::CopyImageRegion_Params params(ipSrcImage, nX, nY, nWidth, nHeight, ipDestImage, hrPrev);

		libraryInfo.functions[168 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CopyImageRegionToRegion_Params
		{
			ITcVnImage* ipSrcImage;
			ULONG nXSrc;
			ULONG nYSrc;
			ULONG nWidth;
			ULONG nHeight;
			ITcVnImage* ipDestImage;
			ULONG nXDest;
			ULONG nYDest;
			HRESULT hrPrev;
			HRESULT retVal;

			CopyImageRegionToRegion_Params(ITcVnImage* ipSrcImage, ULONG nXSrc, ULONG nYSrc, ULONG nWidth, ULONG nHeight, ITcVnImage* ipDestImage, ULONG nXDest, ULONG nYDest, HRESULT hrPrev) : ipSrcImage(ipSrcImage), nXSrc(nXSrc), nYSrc(nYSrc), nWidth(nWidth), nHeight(nHeight), ipDestImage(ipDestImage), nXDest(nXDest), nYDest(nYDest), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Copy an image region into another image region.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="nXSrc">Left boundary in ipSrcImage (inclusive 0-based index)</param>
	/// <param name="nYSrc">Upper boundary in ipSrcImage (inclusive 0-based index)</param>
	/// <param name="nWidth">ROI width</param>
	/// <param name="nHeight">ROI height</param>
	/// <param name="ipDestImage">Destination image (same type as ipSrcImage)</param>
	/// <param name="nXDest">Left boundary in ipDestImage (inclusive 0-based index)</param>
	/// <param name="nYDest">Upper boundary in ipDestImage (inclusive 0-based index)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CopyImageRegionToRegion(HRESULT hrPrev, ITcVnImage* ipSrcImage, ULONG nXSrc, ULONG nYSrc, ULONG nWidth, ULONG nHeight, ITcVnImage* ipDestImage, ULONG nXDest, ULONG nYDest)
	{
		Internal::CopyImageRegionToRegion_Params params(ipSrcImage, nXSrc, nYSrc, nWidth, nHeight, ipDestImage, nXDest, nYDest, hrPrev);

		libraryInfo.functions[169 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CopyIntoDisplayableImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnDisplayableImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			CopyIntoDisplayableImage_Params(ITcVnImage* ipSrcImage, ITcVnDisplayableImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Copys an image into a displayable image. If you do not want to use ipSrcImage after this function call, you might want to use F_VN_TransformIntoDisplayableImage instead for better performance.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Returns the displayable image</param>
	/// <returns>HRESULT</returns>
	static HRESULT CopyIntoDisplayableImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnDisplayableImage*& ipDestImage)
	{
		Internal::CopyIntoDisplayableImage_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[170 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CountNonZeroPixels_Params
		{
			ITcVnImage* ipSrcImage;
			ULONGLONG& nNonZero;
			HRESULT hrPrev;
			HRESULT retVal;

			CountNonZeroPixels_Params(ITcVnImage* ipSrcImage, ULONGLONG& nNonZero, HRESULT hrPrev) : ipSrcImage(ipSrcImage), nNonZero(nNonZero), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Counts the non-zero pixels in a single-channel image (e.g. useful to analyze threshold results).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="nNonZero">Returns the number of non-zero pixels in ipSrcImage</param>
	/// <returns>HRESULT</returns>
	static HRESULT CountNonZeroPixels(HRESULT hrPrev, ITcVnImage* ipSrcImage, ULONGLONG& nNonZero)
	{
		Internal::CountNonZeroPixels_Params params(ipSrcImage, nNonZero, hrPrev);

		libraryInfo.functions[171 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateAssociatedImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateAssociatedImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a new image that shares its data with the source image. E.g. useful to work on different (disjoint) ROIs in parallel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Returns the created image (Non-zero interface pointers are reused.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateAssociatedImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::CreateAssociatedImage_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[172 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateBandpassButterworthFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			double fBandWidth;
			ULONG nOrder;
			double fScale;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateBandpassButterworthFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth, ULONG nOrder, double fScale, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), fBandWidth(fBandWidth), nOrder(nOrder), fScale(fScale), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a bandpass Butterworth filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Butterworth filter (&gt; 0).</param>
	/// <param name="fBandWidth">The band width of the Butterworth filter (&gt; 0).</param>
	/// <param name="nOrder">The order of the Butterworth filter (&gt; 0).</param>
	/// <param name="fScale">The scale factor of the Butterworth filter denominator term (&gt; 0, e.g. 0.414 or 1.0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateBandpassButterworthFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth, ULONG nOrder, double fScale)
	{
		Internal::CreateBandpassButterworthFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, fBandWidth, nOrder, fScale, hrPrev);

		libraryInfo.functions[173 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateBandpassGaussianFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			double fBandWidth;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateBandpassGaussianFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), fBandWidth(fBandWidth), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a bandpass Gaussian filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Gaussian filter (&gt; 0).</param>
	/// <param name="fBandWidth">The band width of the Gaussian filter (&gt; 0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateBandpassGaussianFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth)
	{
		Internal::CreateBandpassGaussianFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, fBandWidth, hrPrev);

		libraryInfo.functions[174 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateBandrejectButterworthFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			double fBandWidth;
			ULONG nOrder;
			double fScale;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateBandrejectButterworthFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth, ULONG nOrder, double fScale, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), fBandWidth(fBandWidth), nOrder(nOrder), fScale(fScale), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a bandreject Butterworth filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Butterworth filter (&gt; 0).</param>
	/// <param name="fBandWidth">The band width of the Butterworth filter (&gt; 0).</param>
	/// <param name="nOrder">The order of the Butterworth filter (&gt; 0).</param>
	/// <param name="fScale">The scale factor of the Butterworth filter denominator term (&gt; 0, e.g. 0.414 or 1.0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateBandrejectButterworthFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth, ULONG nOrder, double fScale)
	{
		Internal::CreateBandrejectButterworthFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, fBandWidth, nOrder, fScale, hrPrev);

		libraryInfo.functions[175 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateBandrejectGaussianFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			double fBandWidth;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateBandrejectGaussianFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), fBandWidth(fBandWidth), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a bandreject Gaussian filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Gaussian filter (&gt; 0).</param>
	/// <param name="fBandWidth">The band width of the Gaussian filter (&gt; 0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateBandrejectGaussianFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, double fBandWidth)
	{
		Internal::CreateBandrejectGaussianFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, fBandWidth, hrPrev);

		libraryInfo.functions[176 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateContainer_Params
		{
			ITcVnContainer*& ipContainer;
			GUID nTypeGuid;
			ULONGLONG nElementNum;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateContainer_Params(ITcVnContainer*& ipContainer, GUID nTypeGuid, ULONGLONG nElementNum, HRESULT hrPrev) : ipContainer(ipContainer), nTypeGuid(nTypeGuid), nElementNum(nElementNum), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a container with type GUID nTypeGuid and return its container interface.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Returns the created container</param>
	/// <param name="nTypeGuid">Type GUID of the container to be created</param>
	/// <param name="nElementNum">Number of elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateContainer(HRESULT hrPrev, ITcVnContainer*& ipContainer, GUID nTypeGuid, ULONGLONG nElementNum)
	{
		Internal::CreateContainer_Params params(ipContainer, nTypeGuid, nElementNum, hrPrev);

		libraryInfo.functions[177 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateContainerFromArray_Params
		{
			PVOID pData;
			ITcVnContainer*& ipContainer;
			GUID nTypeGuid;
			ULONGLONG nElementNum;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateContainerFromArray_Params(PVOID pData, ITcVnContainer*& ipContainer, GUID nTypeGuid, ULONGLONG nElementNum, HRESULT hrPrev) : pData(pData), ipContainer(ipContainer), nTypeGuid(nTypeGuid), nElementNum(nElementNum), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a container with type GUID nTypeGuid, initialize it with provided data and return its container interface. Only supported for basic container types, i.e. not for containers of containers.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="pData">Pointer to the data array. Make sure that the array contains at least nElementNum elements and that the array element type matches the container element type.</param>
	/// <param name="ipContainer">Returns the created container</param>
	/// <param name="nTypeGuid">Type GUID of the container to be created</param>
	/// <param name="nElementNum">Number of elements to copy from pData</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateContainerFromArray(HRESULT hrPrev, PVOID pData, ITcVnContainer*& ipContainer, GUID nTypeGuid, ULONGLONG nElementNum)
	{
		Internal::CreateContainerFromArray_Params params(pData, ipContainer, nTypeGuid, nElementNum, hrPrev);

		libraryInfo.functions[178 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateEmptyImage_Params
		{
			ITcVnImage*& ipImage;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateEmptyImage_Params(ITcVnImage*& ipImage, HRESULT hrPrev) : ipImage(ipImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates an empty image without allocating any data buffer. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Returns the created image</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateEmptyImage(HRESULT hrPrev, ITcVnImage*& ipImage)
	{
		Internal::CreateEmptyImage_Params params(ipImage, hrPrev);

		libraryInfo.functions[179 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateHighpassButterworthFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			ULONG nOrder;
			double fScale;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateHighpassButterworthFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, ULONG nOrder, double fScale, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), nOrder(nOrder), fScale(fScale), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a highpass Butterworth filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Butterworth filter (&gt; 0).</param>
	/// <param name="nOrder">The order of the Butterworth filter (&gt; 0).</param>
	/// <param name="fScale">The scale factor of the Butterworth filter denominator term (&gt; 0, e.g. 0.414 or 1.0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateHighpassButterworthFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, ULONG nOrder, double fScale)
	{
		Internal::CreateHighpassButterworthFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, nOrder, fScale, hrPrev);

		libraryInfo.functions[180 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateHighpassGaussianFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateHighpassGaussianFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a highpass Gaussian filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Gaussian filter (&gt; 0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateHighpassGaussianFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance)
	{
		Internal::CreateHighpassGaussianFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, hrPrev);

		libraryInfo.functions[181 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateImage_Params
		{
			ITcVnImage*& ipImage;
			ULONG nWidth;
			ULONG nHeight;
			ETcVnElementType ePixelType;
			ULONG nChannelNum;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateImage_Params(ITcVnImage*& ipImage, ULONG nWidth, ULONG nHeight, ETcVnElementType ePixelType, ULONG nChannelNum, HRESULT hrPrev) : ipImage(ipImage), nWidth(nWidth), nHeight(nHeight), ePixelType(ePixelType), nChannelNum(nChannelNum), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates an image and allocate an appropriate data buffer. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Returns the created image (Non-zero interface pointers are reused.)</param>
	/// <param name="nWidth">Image width</param>
	/// <param name="nHeight">Image height</param>
	/// <param name="ePixelType">Pixel type</param>
	/// <param name="nChannelNum">Number of channels (1 to 255)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateImage(HRESULT hrPrev, ITcVnImage*& ipImage, ULONG nWidth, ULONG nHeight, ETcVnElementType ePixelType, ULONG nChannelNum)
	{
		Internal::CreateImage_Params params(ipImage, nWidth, nHeight, ePixelType, nChannelNum, hrPrev);

		libraryInfo.functions[182 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateImageAndSetPixels_Params
		{
			ITcVnImage*& ipImage;
			ULONG nWidth;
			ULONG nHeight;
			ETcVnElementType ePixelType;
			ULONG nChannelNum;
			VN_TcVnVector4_LREAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateImageAndSetPixels_Params(ITcVnImage*& ipImage, ULONG nWidth, ULONG nHeight, ETcVnElementType ePixelType, ULONG nChannelNum, TcVnVector4_LREAL& aValue, HRESULT hrPrev) : ipImage(ipImage), nWidth(nWidth), nHeight(nHeight), ePixelType(ePixelType), nChannelNum(nChannelNum), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates an image, allocates an appropriate data buffer and sets all pixels to the specified value. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Returns the created image (Non-zero interface pointers are reused.)</param>
	/// <param name="nWidth">Image width</param>
	/// <param name="nHeight">Image height</param>
	/// <param name="ePixelType">Pixel type</param>
	/// <param name="nChannelNum">Number of channels (1 to 4)</param>
	/// <param name="aValue">Pixel value</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateImageAndSetPixels(HRESULT hrPrev, ITcVnImage*& ipImage, ULONG nWidth, ULONG nHeight, ETcVnElementType ePixelType, ULONG nChannelNum, TcVnVector4_LREAL& aValue)
	{
		Internal::CreateImageAndSetPixels_Params params(ipImage, nWidth, nHeight, ePixelType, nChannelNum, aValue, hrPrev);

		libraryInfo.functions[183 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateImageFromArray_Params
		{
			PVOID pData;
			ITcVnImage*& ipImage;
			ULONG nWidth;
			ULONG nHeight;
			ETcVnElementType ePixelType;
			ULONG nChannelNum;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateImageFromArray_Params(PVOID pData, ITcVnImage*& ipImage, ULONG nWidth, ULONG nHeight, ETcVnElementType ePixelType, ULONG nChannelNum, HRESULT hrPrev) : pData(pData), ipImage(ipImage), nWidth(nWidth), nHeight(nHeight), ePixelType(ePixelType), nChannelNum(nChannelNum), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates an image and initialize it with the provided data. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="pData">Pointer to the 1D data array. Make sure that the array contains at least nWidth * nHeight * nChannelNum elements and that the array element type matches ePixelType.</param>
	/// <param name="ipImage">Returns the created image (Non-zero interface pointers are reused.)</param>
	/// <param name="nWidth">Image width</param>
	/// <param name="nHeight">Image height</param>
	/// <param name="ePixelType">Pixel type</param>
	/// <param name="nChannelNum">Number of channels (1 to 255)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateImageFromArray(HRESULT hrPrev, PVOID pData, ITcVnImage*& ipImage, ULONG nWidth, ULONG nHeight, ETcVnElementType ePixelType, ULONG nChannelNum)
	{
		Internal::CreateImageFromArray_Params params(pData, ipImage, nWidth, nHeight, ePixelType, nChannelNum, hrPrev);

		libraryInfo.functions[184 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateLowpassButterworthFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			ULONG nOrder;
			double fScale;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateLowpassButterworthFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, ULONG nOrder, double fScale, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), nOrder(nOrder), fScale(fScale), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a lowpass Butterworth filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Butterworth filter (&gt; 0).</param>
	/// <param name="nOrder">The order of the Butterworth filter (&gt; 0).</param>
	/// <param name="fScale">The scale factor of the Butterworth filter denominator term (&gt; 0, e.g. 0.414 or 1.0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateLowpassButterworthFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, ULONG nOrder, double fScale)
	{
		Internal::CreateLowpassButterworthFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, nOrder, fScale, hrPrev);

		libraryInfo.functions[185 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateLowpassGaussianFilter_Params
		{
			ITcVnImage*& ipFilter;
			ULONG nWidth;
			ULONG nHeight;
			bool bDoublePrecision;
			bool bOriginAtCenter;
			double fCutoffDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateLowpassGaussianFilter_Params(ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance, HRESULT hrPrev) : ipFilter(ipFilter), nWidth(nWidth), nHeight(nHeight), bDoublePrecision(bDoublePrecision), bOriginAtCenter(bOriginAtCenter), fCutoffDistance(fCutoffDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a lowpass Gaussian filter, which can be applied to a frequency domain image by element-wise multiplication.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFilter">Returns the created filter (1 channel of type REAL or LREAL, depending on bDoublePrecision. Non-zero interface pointers are reused.).</param>
	/// <param name="nWidth">Filter width (even, &gt;= 2, must match the width of the image it is applied to)</param>
	/// <param name="nHeight">Filter height (even, &gt;= 2, must match the height of the image it is applied to)</param>
	/// <param name="bDoublePrecision">If true, the filter is generated with double precision (LREAL) instead of single precision (REAL).</param>
	/// <param name="bOriginAtCenter">If true, the filter origin is shifted to the image center.</param>
	/// <param name="fCutoffDistance">The cutoff distance of the Gaussian filter (&gt; 0).</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateLowpassGaussianFilter(HRESULT hrPrev, ITcVnImage*& ipFilter, ULONG nWidth, ULONG nHeight, bool bDoublePrecision, bool bOriginAtCenter, double fCutoffDistance)
	{
		Internal::CreateLowpassGaussianFilter_Params params(ipFilter, nWidth, nHeight, bDoublePrecision, bOriginAtCenter, fCutoffDistance, hrPrev);

		libraryInfo.functions[186 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateNDimensionalImage_Params
		{
			ITcVnImage*& ipImage;
			TcVnArray33_UDINT& aShape;
			ETcVnElementType ePixelType;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateNDimensionalImage_Params(ITcVnImage*& ipImage, TcVnArray33_UDINT& aShape, ETcVnElementType ePixelType, HRESULT hrPrev) : ipImage(ipImage), aShape(aShape), ePixelType(ePixelType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates an N-dimensional image and allocates an appropriate data buffer. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Returns the created image (Non-zero interface pointers are reused.)</param>
	/// <param name="aShape">Specifies the shape of ipDestImage. First entry is the number of dimensions of ipImage (max. 32), followed by the sizes of each dimension.</param>
	/// <param name="ePixelType">Pixel type</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateNDimensionalImage(HRESULT hrPrev, ITcVnImage*& ipImage, TcVnArray33_UDINT& aShape, ETcVnElementType ePixelType)
	{
		Internal::CreateNDimensionalImage_Params params(ipImage, aShape, ePixelType, hrPrev);

		libraryInfo.functions[187 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateNDimensionalImageAndSetPixels_Params
		{
			ITcVnImage*& ipImage;
			TcVnArray33_UDINT& aShape;
			ETcVnElementType ePixelType;
			double fValue;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateNDimensionalImageAndSetPixels_Params(ITcVnImage*& ipImage, TcVnArray33_UDINT& aShape, ETcVnElementType ePixelType, double fValue, HRESULT hrPrev) : ipImage(ipImage), aShape(aShape), ePixelType(ePixelType), fValue(fValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates an N-dimensional image, allocates an appropriate data buffer and sets all pixels to the specified value. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Returns the created image (Non-zero interface pointers are reused.)</param>
	/// <param name="aShape">Specifies the shape of ipDestImage. First entry is the number of dimensions of ipImage (max. 32), followed by the sizes of each dimension.</param>
	/// <param name="ePixelType">Pixel type</param>
	/// <param name="fValue">Pixel value</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateNDimensionalImageAndSetPixels(HRESULT hrPrev, ITcVnImage*& ipImage, TcVnArray33_UDINT& aShape, ETcVnElementType ePixelType, double fValue)
	{
		Internal::CreateNDimensionalImageAndSetPixels_Params params(ipImage, aShape, ePixelType, fValue, hrPrev);

		libraryInfo.functions[188 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateNDimensionalImageFromArray_Params
		{
			PVOID pData;
			ITcVnImage*& ipImage;
			TcVnArray33_UDINT& aShape;
			ETcVnElementType ePixelType;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateNDimensionalImageFromArray_Params(PVOID pData, ITcVnImage*& ipImage, TcVnArray33_UDINT& aShape, ETcVnElementType ePixelType, HRESULT hrPrev) : pData(pData), ipImage(ipImage), aShape(aShape), ePixelType(ePixelType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates an N-dimensional image and initialize it with the provided data. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="pData">Pointer to the 1D data array. Ensure that the array contains at least the number of elements equal to the product of all dimensions in aShape and that the array element type matches ePixelType.</param>
	/// <param name="ipImage">Returns the created image (Non-zero interface pointers are reused.)</param>
	/// <param name="aShape">Specifies the shape of ipDestImage. First entry is the number of dimensions of ipImage (max. 32), followed by the sizes of each dimension.</param>
	/// <param name="ePixelType">Pixel type</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateNDimensionalImageFromArray(HRESULT hrPrev, PVOID pData, ITcVnImage*& ipImage, TcVnArray33_UDINT& aShape, ETcVnElementType ePixelType)
	{
		Internal::CreateNDimensionalImageFromArray_Params params(pData, ipImage, aShape, ePixelType, hrPrev);

		libraryInfo.functions[189 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateStructuringElement_Params
		{
			ITcVnImage*& ipStructuringElement;
			ETcVnStructuringElementShape eShape;
			ULONG nWidth;
			ULONG nHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateStructuringElement_Params(ITcVnImage*& ipStructuringElement, ETcVnStructuringElementShape eShape, ULONG nWidth, ULONG nHeight, HRESULT hrPrev) : ipStructuringElement(ipStructuringElement), eShape(eShape), nWidth(nWidth), nHeight(nHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Creates a structuring element for the usage with morphological operators and allocate an appropriate data buffer. The initial reference count is set to one if a new image interface is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipStructuringElement">Returns the created structuring element (Non-zero interface pointers are reused.)</param>
	/// <param name="eShape">Shape of the structuring element (rectangle, cross, or ellipse)</param>
	/// <param name="nWidth">Width</param>
	/// <param name="nHeight">Height</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateStructuringElement(HRESULT hrPrev, ITcVnImage*& ipStructuringElement, ETcVnStructuringElementShape eShape, ULONG nWidth, ULONG nHeight)
	{
		Internal::CreateStructuringElement_Params params(ipStructuringElement, eShape, nWidth, nHeight, hrPrev);

		libraryInfo.functions[190 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CustomElementWiseContainerOperation_ITcVnContainer_Params
		{
			ITcVnContainer* ipContainer1;
			ITcVnContainer* ipContainer2;
			ITcVnContainer* ipContainer3;
			ITcVnCustomContainerOperation_ITcVnContainer* ipOperationFB;
			HRESULT hrPrev;
			HRESULT retVal;

			CustomElementWiseContainerOperation_ITcVnContainer_Params(ITcVnContainer* ipContainer1, ITcVnContainer* ipContainer2, ITcVnContainer* ipContainer3, ITcVnCustomContainerOperation_ITcVnContainer* ipOperationFB, HRESULT hrPrev) : ipContainer1(ipContainer1), ipContainer2(ipContainer2), ipContainer3(ipContainer3), ipOperationFB(ipOperationFB), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Performs a custom, element wise operation on a set of up to 3 containers.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer1">Container 1</param>
	/// <param name="ipContainer2">Container 2</param>
	/// <param name="ipContainer3">Container 3</param>
	/// <param name="ipOperationFB">Custom operation on the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT CustomElementWiseContainerOperation(HRESULT hrPrev, ITcVnContainer* ipContainer1, ITcVnContainer* ipContainer2, ITcVnContainer* ipContainer3, ITcVnCustomContainerOperation_ITcVnContainer* ipOperationFB)
	{
		Internal::CustomElementWiseContainerOperation_ITcVnContainer_Params params(ipContainer1, ipContainer2, ipContainer3, ipOperationFB, hrPrev);

		libraryInfo.functions[191 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CustomElementWiseContainerOperation_ITcVnForwardIterator_Params
		{
			ITcVnContainer* ipContainer1;
			ITcVnContainer* ipContainer2;
			ITcVnContainer* ipContainer3;
			ITcVnCustomContainerOperation_ITcVnForwardIterator* ipOperationFB;
			HRESULT hrPrev;
			HRESULT retVal;

			CustomElementWiseContainerOperation_ITcVnForwardIterator_Params(ITcVnContainer* ipContainer1, ITcVnContainer* ipContainer2, ITcVnContainer* ipContainer3, ITcVnCustomContainerOperation_ITcVnForwardIterator* ipOperationFB, HRESULT hrPrev) : ipContainer1(ipContainer1), ipContainer2(ipContainer2), ipContainer3(ipContainer3), ipOperationFB(ipOperationFB), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Performs a custom, element wise operation on a set of up to 3 containers.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer1">Container 1</param>
	/// <param name="ipContainer2">Container 2</param>
	/// <param name="ipContainer3">Container 3</param>
	/// <param name="ipOperationFB">Custom operation on the elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT CustomElementWiseContainerOperation(HRESULT hrPrev, ITcVnContainer* ipContainer1, ITcVnContainer* ipContainer2, ITcVnContainer* ipContainer3, ITcVnCustomContainerOperation_ITcVnForwardIterator* ipOperationFB)
	{
		Internal::CustomElementWiseContainerOperation_ITcVnForwardIterator_Params params(ipContainer1, ipContainer2, ipContainer3, ipOperationFB, hrPrev);

		libraryInfo.functions[192 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnPoint CustomFilter_aAnchorDefault = {-1, -1};

		struct CustomFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnElementType eDestDepth;
			TcVnMatrix& stKernel;
			VN_TcVnPoint& aAnchor;
			double fDelta;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			CustomFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, TcVnMatrix& stKernel, TcVnPoint& aAnchor, double fDelta, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eDestDepth(eDestDepth), stKernel(stKernel), aAnchor(aAnchor), fDelta(fDelta), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a custom filter to the image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eDestDepth">Destination image depth</param>
	/// <param name="stKernel">Custom filter kernel with values of type REAL or LREAL</param>
	/// <param name="aAnchor">Anchor point of the kernel</param>
	/// <param name="fDelta">Value added to each pixel after filtering</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT CustomFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, TcVnMatrix& stKernel, TcVnPoint& aAnchor = Internal::CustomFilter_aAnchorDefault, double fDelta = 0, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::CustomFilter_Params params(ipSrcImage, ipDestImage, eDestDepth, stKernel, aAnchor, fDelta, eBorderType, hrPrev);

		libraryInfo.functions[193 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DarkBorderObjects_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			DarkBorderObjects_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Find dark objects connected to the image border within a gray-scale single-channel image. (equivalent to filling holes)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, UINT, INT, REAL, or LREAL, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DarkBorderObjects(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::DarkBorderObjects_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[194 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector2_LREAL DecomposeAffineTransformation_aTranslationVectorDefault = {0, 0};
		static TcVnVector2_LREAL DecomposeAffineTransformation_aScaleVectorDefault = {0, 0};
		static TcVnVector2_LREAL DecomposeAffineTransformation_aSkewVectorDefault = {0, 0};

		struct DecomposeAffineTransformation_Params
		{
			TcVnMatrix2x3_LREAL& aAffineTransform;
			double& fRotationAngle;
			VN_TcVnVector2_LREAL& aTranslationVector;
			VN_TcVnVector2_LREAL& aScaleVector;
			VN_TcVnVector2_LREAL& aSkewVector;
			HRESULT hrPrev;
			HRESULT retVal;

			DecomposeAffineTransformation_Params(TcVnMatrix2x3_LREAL& aAffineTransform, double& fRotationAngle, TcVnVector2_LREAL& aTranslationVector, TcVnVector2_LREAL& aScaleVector, TcVnVector2_LREAL& aSkewVector, HRESULT hrPrev) : aAffineTransform(aAffineTransform), fRotationAngle(fRotationAngle), aTranslationVector(aTranslationVector), aScaleVector(aScaleVector), aSkewVector(aSkewVector), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Decompose an affine transformation matrix and return the rotation angle (clockwise) in radian, translation vector (pixels), scale, and skew vectors (angle in radian). The decomposition method assumes the following order of transformation: Translation, Rotation, Scale, and Skew.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aAffineTransform">Affine transformation matrix</param>
	/// <param name="fRotationAngle">Rotation angle (radian) in the clockwise direction. The rotation center is the origin point (0,0)</param>
	/// <param name="aTranslationVector">2D translation vector. The values are in pixels</param>
	/// <param name="aScaleVector">2D scale vector </param>
	/// <param name="aSkewVector">2D skew vector. The values are the skew angles in x and y directions in radian</param>
	/// <returns>HRESULT</returns>
	static HRESULT DecomposeAffineTransformation(HRESULT hrPrev, TcVnMatrix2x3_LREAL& aAffineTransform, double& fRotationAngle, TcVnVector2_LREAL& aTranslationVector = Internal::DecomposeAffineTransformation_aTranslationVectorDefault, TcVnVector2_LREAL& aScaleVector = Internal::DecomposeAffineTransformation_aScaleVectorDefault, TcVnVector2_LREAL& aSkewVector = Internal::DecomposeAffineTransformation_aSkewVectorDefault)
	{
		Internal::DecomposeAffineTransformation_Params params(aAffineTransform, fRotationAngle, aTranslationVector, aScaleVector, aSkewVector, hrPrev);

		libraryInfo.functions[195 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DecomposeHomography_Params
		{
			TcVnMatrix3x3_LREAL& aHomography;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnMatrix3x3_LREAL& aRotationMatrixA;
			VN_TcVnVector3_LREAL& aTranslationVectorA;
			VN_TcVnVector3_LREAL& aNormVectorA;
			TcVnMatrix3x3_LREAL& aRotationMatrixB;
			VN_TcVnVector3_LREAL& aTranslationVectorB;
			VN_TcVnVector3_LREAL& aNormVectorB;
			ITcVnContainer* ipPointsSrc;
			ITcVnContainer* ipPointsDes;
			ITcVnContainer* ipInlierMask;
			HRESULT hrPrev;
			HRESULT retVal;
			ULONG nSolutions;

			DecomposeHomography_Params(TcVnMatrix3x3_LREAL& aHomography, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnMatrix3x3_LREAL& aRotationMatrixA, TcVnVector3_LREAL& aTranslationVectorA, TcVnVector3_LREAL& aNormVectorA, TcVnMatrix3x3_LREAL& aRotationMatrixB, TcVnVector3_LREAL& aTranslationVectorB, TcVnVector3_LREAL& aNormVectorB, ITcVnContainer* ipPointsSrc, ITcVnContainer* ipPointsDes, ITcVnContainer* ipInlierMask, HRESULT hrPrev) : aHomography(aHomography), aCameraMatrix(aCameraMatrix), aRotationMatrixA(aRotationMatrixA), aTranslationVectorA(aTranslationVectorA), aNormVectorA(aNormVectorA), aRotationMatrixB(aRotationMatrixB), aTranslationVectorB(aTranslationVectorB), aNormVectorB(aNormVectorB), ipPointsSrc(ipPointsSrc), ipPointsDes(ipPointsDes), ipInlierMask(ipInlierMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Decompose a homography matrix and verify four solutions of rotation, translation, and plane normal. It uses visible reference points being in front of the camera to confirm which solution(s) of the four solutions (maximum two solutions) are consistent with all reference points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aHomography">Homography matrix (a perspective transformation between two planes)</param>
	/// <param name="aCameraMatrix">Camera matrix</param>
	/// <param name="aRotationMatrixA">Rotation matrix of the first solution (Ra)</param>
	/// <param name="aTranslationVectorA">Translation vector of the first solution (Ta)</param>
	/// <param name="aNormVectorA">Norm vector of the first solution (Na)</param>
	/// <param name="aRotationMatrixB">Rotation matrix of the second solution (Rb)</param>
	/// <param name="aTranslationVectorB">Translation vector of the second solution (Tb)</param>
	/// <param name="aNormVectorB">Norm vector of the second solution (Nb)</param>
	/// <param name="nSolutions">Return the number of true potential solutions [0,1, or 2]. 0: no true potential solutions for the given corresponding points are confirmed. 1: the solution (Ra, Ta, Na) is confirmed. 2: both solution (Ra, Ta, Na) and (Rb, Tb, Nb) are confirmed. In all cases the function returns two solutions (Ra, Ta, Nb) and (Rb, Tb, Nb). The third and the fourth solutions can be calculated as follows: (Ra, -Ta, -Na) and (Rb, -Tb, -Nb). </param>
	/// <param name="ipPointsSrc">Container with source points (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="ipPointsDes">Container with destination points (same number as ipPoints1, ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="ipInlierMask">A mask marking the inliers (optional, set to 0 if not available; ContainerType_Vector_SINT or ContainerType_Vector_USINT)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DecomposeHomography(HRESULT hrPrev, TcVnMatrix3x3_LREAL& aHomography, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnMatrix3x3_LREAL& aRotationMatrixA, TcVnVector3_LREAL& aTranslationVectorA, TcVnVector3_LREAL& aNormVectorA, TcVnMatrix3x3_LREAL& aRotationMatrixB, TcVnVector3_LREAL& aTranslationVectorB, TcVnVector3_LREAL& aNormVectorB, ULONG& nSolutions, ITcVnContainer* ipPointsSrc = nullptr, ITcVnContainer* ipPointsDes = nullptr, ITcVnContainer* ipInlierMask = nullptr)
	{
		Internal::DecomposeHomography_Params params(aHomography, aCameraMatrix, aRotationMatrixA, aTranslationVectorA, aNormVectorA, aRotationMatrixB, aTranslationVectorB, aNormVectorB, ipPointsSrc, ipPointsDes, ipInlierMask, hrPrev);

		libraryInfo.functions[196 - Lic0FuncsOffs].pFct(&params);

		AssignTo(nSolutions, params.nSolutions);

		return params.retVal;
	}

	/// <summary>
	/// Decompose a homography matrix and verify four solutions of rotation, translation, and plane normal. It uses visible reference points being in front of the camera to confirm which solution(s) of the four solutions (maximum two solutions) are consistent with all reference points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aHomography">Homography matrix (a perspective transformation between two planes)</param>
	/// <param name="aCameraMatrix">Camera matrix</param>
	/// <param name="aRotationMatrixA">Rotation matrix of the first solution (Ra)</param>
	/// <param name="aTranslationVectorA">Translation vector of the first solution (Ta)</param>
	/// <param name="aNormVectorA">Norm vector of the first solution (Na)</param>
	/// <param name="aRotationMatrixB">Rotation matrix of the second solution (Rb)</param>
	/// <param name="aTranslationVectorB">Translation vector of the second solution (Tb)</param>
	/// <param name="aNormVectorB">Norm vector of the second solution (Nb)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DecomposeHomography(HRESULT hrPrev, TcVnMatrix3x3_LREAL& aHomography, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnMatrix3x3_LREAL& aRotationMatrixA, TcVnVector3_LREAL& aTranslationVectorA, TcVnVector3_LREAL& aNormVectorA, TcVnMatrix3x3_LREAL& aRotationMatrixB, TcVnVector3_LREAL& aTranslationVectorB, TcVnVector3_LREAL& aNormVectorB)
	{
		Internal::DecomposeHomography_Params params(aHomography, aCameraMatrix, aRotationMatrixA, aTranslationVectorA, aNormVectorA, aRotationMatrixB, aTranslationVectorB, aNormVectorB, nullptr, nullptr, nullptr, hrPrev);

		libraryInfo.functions[196 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DeinitializeFunction_Params
		{
			ETcVnInitializableFunction eFunction;
			ULONGLONG nOptions;
			HRESULT hrPrev;
			HRESULT retVal;

			DeinitializeFunction_Params(ETcVnInitializableFunction eFunction, ULONGLONG nOptions, HRESULT hrPrev) : eFunction(eFunction), nOptions(nOptions), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Deinitialize the specified options for the function.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="eFunction">Initializable function</param>
	/// <param name="nOptions">Initialization options for the function</param>
	/// <returns>HRESULT</returns>
	static HRESULT DeinitializeFunction(HRESULT hrPrev, ETcVnInitializableFunction eFunction, ULONGLONG nOptions)
	{
		Internal::DeinitializeFunction_Params params(eFunction, nOptions, hrPrev);

		libraryInfo.functions[197 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnPoint DetectBlobs_aOffsetDefault = {0, 0};

		struct DetectBlobs_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipBlobContours;
			TcVnParamsBlobDetection& stParams;
			VN_TcVnPoint& aOffset;
			HRESULT hrPrev;
			HRESULT retVal;

			DetectBlobs_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipBlobContours, TcVnParamsBlobDetection& stParams, TcVnPoint& aOffset, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipBlobContours(ipBlobContours), stParams(stParams), aOffset(aOffset), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects blob-contours. Applies a threshold, a contour search and offers several options for filtering the found contours. Provides easy setup for multiple thresholds and combination of results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT or REAL, 1 channel or 3 channel (3 channel input is expected to be RGB and internally converted to Gray))</param>
	/// <param name="ipBlobContours">Returns a container which is filled with the found contours (ContainerType_Vector_Vector_TcVnPoint2_DINT; The elements of this container are single contours. Non-zero interface pointers are reused.)</param>
	/// <param name="stParams">Parameters to filter the detected contours.</param>
	/// <param name="aOffset">Offset by which every contour point is shifted</param>
	/// <returns>HRESULT</returns>
	static HRESULT DetectBlobs(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipBlobContours, TcVnParamsBlobDetection& stParams, TcVnPoint& aOffset = Internal::DetectBlobs_aOffsetDefault)
	{
		Internal::DetectBlobs_Params params(ipSrcImage, ipBlobContours, stParams, aOffset, hrPrev);

		libraryInfo.functions[198 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct Dft_Params
		{
			ITcVnImage* ipSpatialImage;
			ITcVnImage*& ipFrequencyImage;
			bool bPackedCCS;
			bool bAutoPadding;
			HRESULT hrPrev;
			HRESULT retVal;

			Dft_Params(ITcVnImage* ipSpatialImage, ITcVnImage*& ipFrequencyImage, bool bPackedCCS, bool bAutoPadding, HRESULT hrPrev) : ipSpatialImage(ipSpatialImage), ipFrequencyImage(ipFrequencyImage), bPackedCCS(bPackedCCS), bAutoPadding(bAutoPadding), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the DFT for a given image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSpatialImage">Source image (elements of type REAL or LREAL, 1 (Re) or 2 (Re + Im) channels)</param>
	/// <param name="ipFrequencyImage">Destination image (same type as ipSpatialImage, but number of channels and size can vary depending on bPackedCCS and bAutoPadding.</param>
	/// <param name="bPackedCCS">If true and ipSpatialImage has only 1 channel, the result image will have 1 channel with packed complex-conjugate-symmetrical format results. Otherwise, the result image will have 2 separate channels (Re + Im), containing the full spectrum.</param>
	/// <param name="bAutoPadding">If true, the input image is automatically padded (with 0s) to optimal size if required, to speed up dft (Creates a temporary copy so that ipSpatialImage content stays unchanged, which also requires some additional computation power. Therefore, it is recommended to compare execution times with and without padding.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT Dft(HRESULT hrPrev, ITcVnImage* ipSpatialImage, ITcVnImage*& ipFrequencyImage, bool bPackedCCS, bool bAutoPadding)
	{
		Internal::Dft_Params params(ipSpatialImage, ipFrequencyImage, bPackedCCS, bAutoPadding, hrPrev);

		libraryInfo.functions[199 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DistanceTransformation_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnDistanceType eDistanceType;
			ETcVnDistanceTransformationMask eMaskSize;
			ITcVnImage** pipDestLabels;
			ETcVnDistanceTransformationLabel eLabelType;
			HRESULT hrPrev;
			HRESULT retVal;

			DistanceTransformation_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnDistanceType eDistanceType, ETcVnDistanceTransformationMask eMaskSize, ITcVnImage** pipDestLabels, ETcVnDistanceTransformationLabel eLabelType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eDistanceType(eDistanceType), eMaskSize(eMaskSize), pipDestLabels(pipDestLabels), eLabelType(eLabelType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculates the distance transformation, which is the distance to the closest zero pixel in a binary image. Additionally, an image with component labels is created (discrete Voronoi diagram). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (REAL, 1 channel. An appropriate destination image will be created if required.)</param>
	/// <param name="eDistanceType">Distance computation method (supported: L1, L2, C)</param>
	/// <param name="eMaskSize">Size of the distance transformation mask (PRECISE not supported for label computation)</param>
	/// <param name="pipDestLabels">Returns the component labels (Discrete Voronoi diagram; DINT, 1 channel. An appropriate image will be created if required.)</param>
	/// <param name="eLabelType">Type of the labels</param>
	/// <returns>HRESULT</returns>
	static HRESULT DistanceTransformation(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnDistanceType eDistanceType, ETcVnDistanceTransformationMask eMaskSize, ITcVnImage** pipDestLabels = nullptr, ETcVnDistanceTransformationLabel eLabelType = DTL_CCOMP)
	{
		Internal::DistanceTransformation_Params params(ipSrcImage, ipDestImage, eDistanceType, eMaskSize, pipDestLabels, eLabelType, hrPrev);

		libraryInfo.functions[200 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DivideContainers_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			LONGLONG nIntDivideByZeroResult;
			HRESULT hrPrev;
			HRESULT retVal;

			DivideContainers_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, LONGLONG nIntDivideByZeroResult, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), nIntDivideByZeroResult(nIntDivideByZeroResult), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise division of two containers (same length and type). In case of integer division by zero, the resulting element is set to nIntDivideByZeroResult and S_DIVISION_BY_ZERO is returned instead of S_OK. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <param name="nIntDivideByZeroResult">Value set as result in case of integer division by zero</param>
	/// <returns>HRESULT</returns>
	static HRESULT DivideContainers(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, LONGLONG nIntDivideByZeroResult = 0)
	{
		Internal::DivideContainers_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, nIntDivideByZeroResult, hrPrev);

		libraryInfo.functions[201 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DivideImageByScalar_Params
		{
			ITcVnImage* ipSrcImage;
			double fScalar;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			DivideImageByScalar_Params(ITcVnImage* ipSrcImage, double fScalar, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), fScalar(fScalar), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Divide each image pixel by a scalar value using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DivideImageByScalar(HRESULT hrPrev, ITcVnImage* ipSrcImage, double fScalar, ITcVnImage*& ipDestImage)
	{
		Internal::DivideImageByScalar_Params params(ipSrcImage, fScalar, ipDestImage, hrPrev);

		libraryInfo.functions[202 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DivideImageByVector_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			DivideImageByVector_Params(ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aVector, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aVector(aVector), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Divides each image pixel by a vector (1 element for each image channel) using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DivideImageByVector(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aVector, ITcVnImage*& ipDestImage)
	{
		Internal::DivideImageByVector_Params params(ipSrcImage, aVector, ipDestImage, hrPrev);

		libraryInfo.functions[203 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DivideImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			DivideImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise division of two images using saturation arithmetics. (A division by zero equals zero.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image (dividend)</param>
	/// <param name="ipSrcImage2">Second source image (divisor)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DivideImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::DivideImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[204 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DivideScalarByImage_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			DivideScalarByImage_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Divides a scalar value by each image pixel using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DivideScalarByImage(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::DivideScalarByImage_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[205 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DivideVectorByImage_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			DivideVectorByImage_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Divides a vector (1 element for each image channel) by each image pixel using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DivideVectorByImage(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::DivideVectorByImage_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[206 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DoubleThreshold_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fLowThreshold;
			double fHighThreshold;
			double fMaxValue;
			HRESULT hrPrev;
			HRESULT retVal;

			DoubleThreshold_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fLowThreshold, double fHighThreshold, double fMaxValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fLowThreshold(fLowThreshold), fHighThreshold(fHighThreshold), fMaxValue(fMaxValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a double threshold (also called hysteresis threshold) using morphological reconstruction.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, UINT, INT, REAL, or LREAL, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fLowThreshold">Low threshold determinining the shape of found regions</param>
	/// <param name="fHighThreshold">High threshold selecting found regions (Each region must at least contain a single pixel if the high threshold is applied.)</param>
	/// <param name="fMaxValue">Maximum pixel value</param>
	/// <returns>HRESULT</returns>
	static HRESULT DoubleThreshold(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fLowThreshold, double fHighThreshold, double fMaxValue)
	{
		Internal::DoubleThreshold_Params params(ipSrcImage, ipDestImage, fLowThreshold, fHighThreshold, fMaxValue, hrPrev);

		libraryInfo.functions[207 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawArrow_Params
		{
			ULONG nX1;
			ULONG nY1;
			ULONG nX2;
			ULONG nY2;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			bool bDoubleHead;
			ETcVnLineType eLineType;
			ULONG nShift;
			double fTipLenght;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawArrow_Params(ULONG nX1, ULONG nY1, ULONG nX2, ULONG nY2, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, bool bDoubleHead, ETcVnLineType eLineType, ULONG nShift, double fTipLenght, HRESULT hrPrev) : nX1(nX1), nY1(nY1), nX2(nX2), nY2(nY2), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), bDoubleHead(bDoubleHead), eLineType(eLineType), nShift(nShift), fTipLenght(fTipLenght), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws an arrowed line. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nX1">x coordinate of the start point</param>
	/// <param name="nY1">y coordinate of the start point</param>
	/// <param name="nX2">x coordinate of the end point</param>
	/// <param name="nY2">y coordinate of the end point</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="bDoubleHead">To draw an arrow on each side of the line.</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="nShift">Fractional bits of the coordinates (bit shift)</param>
	/// <param name="fTipLenght">Lenght of the arrow's tip as a fraction of the line's lenght</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawArrow(HRESULT hrPrev, ULONG nX1, ULONG nY1, ULONG nX2, ULONG nY2, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, bool bDoubleHead, ETcVnLineType eLineType = LT_8_CONNECTED, ULONG nShift = 0, double fTipLenght = 0.1)
	{
		Internal::DrawArrow_Params params(nX1, nY1, nX2, nY2, ipDestImage, aColor, nThickness, bDoubleHead, eLineType, nShift, fTipLenght, hrPrev);

		libraryInfo.functions[208 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawArrow_TcVnVector4_DINT_Params
		{
			VN_TcVnVector4_DINT& aLine;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			bool bDoubleHead;
			ETcVnLineType eLineType;
			ULONG nShift;
			double fTipLenght;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawArrow_TcVnVector4_DINT_Params(TcVnVector4_DINT& aLine, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, bool bDoubleHead, ETcVnLineType eLineType, ULONG nShift, double fTipLenght, HRESULT hrPrev) : aLine(aLine), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), bDoubleHead(bDoubleHead), eLineType(eLineType), nShift(nShift), fTipLenght(fTipLenght), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws an arrowed line. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine">The start and end point of a line segment [x1, y1, x2, y2]</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="bDoubleHead">To draw an arrow on each side of the line.</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="nShift">Fractional bits of the coordinates (bit shift)</param>
	/// <param name="fTipLenght">Lenght of the arrow's tip as a fraction of the line's lenght</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawArrow(HRESULT hrPrev, TcVnVector4_DINT& aLine, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, bool bDoubleHead, ETcVnLineType eLineType = LT_8_CONNECTED, ULONG nShift = 0, double fTipLenght = 0.1)
	{
		Internal::DrawArrow_TcVnVector4_DINT_Params params(aLine, ipDestImage, aColor, nThickness, bDoubleHead, eLineType, nShift, fTipLenght, hrPrev);

		libraryInfo.functions[209 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawCircle_Params
		{
			ULONG nCenterX;
			ULONG nCenterY;
			ULONG nRadius;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawCircle_Params(ULONG nCenterX, ULONG nCenterY, ULONG nRadius, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, HRESULT hrPrev) : nCenterX(nCenterX), nCenterY(nCenterY), nRadius(nRadius), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws a circle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nCenterX">x coordinate of the center</param>
	/// <param name="nCenterY">y coordinate of the center</param>
	/// <param name="nRadius">Radius</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the circle is filled)</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawCircle(HRESULT hrPrev, ULONG nCenterX, ULONG nCenterY, ULONG nRadius, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED)
	{
		Internal::DrawCircle_Params params(nCenterX, nCenterY, nRadius, ipDestImage, aColor, nThickness, eLineType, hrPrev);

		libraryInfo.functions[210 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawCircles_Params
		{
			ITcVnContainer* ipCircles;
			LONG nCircleIndex;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawCircles_Params(ITcVnContainer* ipCircles, LONG nCircleIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, HRESULT hrPrev) : ipCircles(ipCircles), nCircleIndex(nCircleIndex), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws circles. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipCircles">Container with circles (ContainerType_Vector_TcVnVector3_REAL; Each container element contains the x coordinate of the circle center [0], the y coordinate of the circle center [1], and the radius [2].)</param>
	/// <param name="nCircleIndex">Index of a specific circle to be drawn (if negative, all circles within the container are drawn)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the circle is filled)</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawCircles(HRESULT hrPrev, ITcVnContainer* ipCircles, LONG nCircleIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED)
	{
		Internal::DrawCircles_Params params(ipCircles, nCircleIndex, ipDestImage, aColor, nThickness, eLineType, hrPrev);

		libraryInfo.functions[211 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawCircularArc_Params
		{
			TcVnCircularArc& stCircularArc;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawCircularArc_Params(TcVnCircularArc& stCircularArc, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, HRESULT hrPrev) : stCircularArc(stCircularArc), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws a circular arc. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stCircularArc">Circular arc definition</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the arc is filled)</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawCircularArc(HRESULT hrPrev, TcVnCircularArc& stCircularArc, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED)
	{
		Internal::DrawCircularArc_Params params(stCircularArc, ipDestImage, aColor, nThickness, eLineType, hrPrev);

		libraryInfo.functions[212 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL DrawComponents_aColorDefault = {-1, -1, -1, -1};

		struct DrawComponents_Params
		{
			ITcVnImage* ipLabelImage;
			LONG nLabelID;
			ITcVnImage*& ipDestImage;
			bool bShowLabelID;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			double fFontScale;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawComponents_Params(ITcVnImage* ipLabelImage, LONG nLabelID, ITcVnImage*& ipDestImage, bool bShowLabelID, TcVnVector4_LREAL& aColor, LONG nThickness, double fFontScale, HRESULT hrPrev) : ipLabelImage(ipLabelImage), nLabelID(nLabelID), ipDestImage(ipDestImage), bShowLabelID(bShowLabelID), aColor(aColor), nThickness(nThickness), fFontScale(fFontScale), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw the results of connected component function. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipLabelImage">Image contains labels for each pixel (1 channel DINT or UINT).</param>
	/// <param name="nLabelID">Value of a specific label to be drawn (if negative, all components within the image are drawn)</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required. The output image is 1 or 3 channels USINT).</param>
	/// <param name="bShowLabelID">Show lable ID in the center of the component on the destination image</param>
	/// <param name="aColor">Color to draw the components (for {-1, -1, -1, -1}, a random color is chosen for each component)</param>
	/// <param name="nThickness">Text line thickness</param>
	/// <param name="fFontScale">Scaling factor for the text</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawComponents(HRESULT hrPrev, ITcVnImage* ipLabelImage, LONG nLabelID, ITcVnImage*& ipDestImage, bool bShowLabelID, TcVnVector4_LREAL& aColor = Internal::DrawComponents_aColorDefault, LONG nThickness = 1, double fFontScale = 1)
	{
		Internal::DrawComponents_Params params(ipLabelImage, nLabelID, ipDestImage, bShowLabelID, aColor, nThickness, fFontScale, hrPrev);

		libraryInfo.functions[213 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnPoint DrawContours_aOffsetDefault = {0, 0};

		struct DrawContours_Params
		{
			ITcVnContainer* ipContours;
			LONG nContourIndex;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			ITcVnContainer* ipHierarchy;
			LONG nMaxLevel;
			VN_TcVnPoint& aOffset;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawContours_Params(ITcVnContainer* ipContours, LONG nContourIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, ITcVnContainer* ipHierarchy, LONG nMaxLevel, TcVnPoint& aOffset, HRESULT hrPrev) : ipContours(ipContours), nContourIndex(nContourIndex), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), ipHierarchy(ipHierarchy), nMaxLevel(nMaxLevel), aOffset(aOffset), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws a single point set or multiple point sets that are interpreted as contours. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContours">Single contour (ContainerType_Vector_TcVnPoint2_DINT) or multiple contours (ContainerType_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="nContourIndex">Index of a specific contour to be drawn (if negative, all contours within the container are drawn)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the contours are filled)</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="ipHierarchy">Contour hierarchy (ContainerType_Vector_TcVnVector4_DINT)</param>
	/// <param name="nMaxLevel">Maximum level of contours to be drawn</param>
	/// <param name="aOffset">Offset by which every contour point is shifted</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawContours(HRESULT hrPrev, ITcVnContainer* ipContours, LONG nContourIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED, ITcVnContainer* ipHierarchy = nullptr, LONG nMaxLevel = 2147483647, TcVnPoint& aOffset = Internal::DrawContours_aOffsetDefault)
	{
		Internal::DrawContours_Params params(ipContours, nContourIndex, ipDestImage, aColor, nThickness, eLineType, ipHierarchy, nMaxLevel, aOffset, hrPrev);

		libraryInfo.functions[214 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawEllipse_Params
		{
			TcVnRotatedRectangle& stEllipse;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawEllipse_Params(TcVnRotatedRectangle& stEllipse, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, HRESULT hrPrev) : stEllipse(stEllipse), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws an ellipse. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stEllipse">Ellipse to be drawn (rotation angle in degrees)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the ellipse is filled)</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawEllipse(HRESULT hrPrev, TcVnRotatedRectangle& stEllipse, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED)
	{
		Internal::DrawEllipse_Params params(stEllipse, ipDestImage, aColor, nThickness, eLineType, hrPrev);

		libraryInfo.functions[215 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawLine_Params
		{
			ULONG nX1;
			ULONG nY1;
			ULONG nX2;
			ULONG nY2;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			ULONG nShift;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawLine_Params(ULONG nX1, ULONG nY1, ULONG nX2, ULONG nY2, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, ULONG nShift, HRESULT hrPrev) : nX1(nX1), nY1(nY1), nX2(nX2), nY2(nY2), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), nShift(nShift), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws a line. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nX1">x coordinate of the start point</param>
	/// <param name="nY1">y coordinate of the start point</param>
	/// <param name="nX2">x coordinate of the end point</param>
	/// <param name="nY2">y coordinate of the end point</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="nShift">Fractional bits of the coordinates (bit shift)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawLine(HRESULT hrPrev, ULONG nX1, ULONG nY1, ULONG nX2, ULONG nY2, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED, ULONG nShift = 0)
	{
		Internal::DrawLine_Params params(nX1, nY1, nX2, nY2, ipDestImage, aColor, nThickness, eLineType, nShift, hrPrev);

		libraryInfo.functions[216 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawLine_TcVnVector4_DINT_Params
		{
			VN_TcVnVector4_DINT& aLine;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			ULONG nShift;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawLine_TcVnVector4_DINT_Params(TcVnVector4_DINT& aLine, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, ULONG nShift, HRESULT hrPrev) : aLine(aLine), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), nShift(nShift), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws a line. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine">The start and end point of a line segment [x1, y1, x2, y2]</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="nShift">Fractional bits of the coordinates (bit shift)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawLine(HRESULT hrPrev, TcVnVector4_DINT& aLine, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED, ULONG nShift = 0)
	{
		Internal::DrawLine_TcVnVector4_DINT_Params params(aLine, ipDestImage, aColor, nThickness, eLineType, nShift, hrPrev);

		libraryInfo.functions[217 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawLine_TcVnVector4_LREAL_Params
		{
			VN_TcVnVector4_LREAL& aLine;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			ULONG nShift;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawLine_TcVnVector4_LREAL_Params(TcVnVector4_LREAL& aLine, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, ULONG nShift, HRESULT hrPrev) : aLine(aLine), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), nShift(nShift), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws a line. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine">The first and second element describe the x and y component of the direction vector. The third and fourth element describe the x and y component of the position vector.</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="nShift">Fractional bits of the coordinates (bit shift)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawLine(HRESULT hrPrev, TcVnVector4_LREAL& aLine, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED, ULONG nShift = 0)
	{
		Internal::DrawLine_TcVnVector4_LREAL_Params params(aLine, ipDestImage, aColor, nThickness, eLineType, nShift, hrPrev);

		libraryInfo.functions[218 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawLines_Params
		{
			ITcVnContainer* ipLines;
			LONG nLineIndex;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			ULONG nShift;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawLines_Params(ITcVnContainer* ipLines, LONG nLineIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, ULONG nShift, HRESULT hrPrev) : ipLines(ipLines), nLineIndex(nLineIndex), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), nShift(nShift), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws lines. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipLines">Container with line descriptions (ContainerType_Vector_TcVnVector2_REAL: the distance from the origin [0] in pixels and the rotation angle [1] in radians. ContainerType_Vector_TcVnVector4_LREAL: the first and second element describe the x and y component of a vector collinear to the line. The third and fourth element describe the x and y component of a point on the line. ContainerType_Vector_TcVnVector4_DINT: start and end point [x1, y1, x2, y2])</param>
	/// <param name="nLineIndex">Index of a specific line to be drawn (if negative, all lines within the container are drawn)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="nShift">Fractional bits of the coordinates (bit shift)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawLines(HRESULT hrPrev, ITcVnContainer* ipLines, LONG nLineIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED, ULONG nShift = 0)
	{
		Internal::DrawLines_Params params(ipLines, nLineIndex, ipDestImage, aColor, nThickness, eLineType, nShift, hrPrev);

		libraryInfo.functions[219 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawOrientation_Params
		{
			TcVnRotatedRectangle& stOrientation;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColorMainAxis;
			LONG nThickness;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawOrientation_Params(TcVnRotatedRectangle& stOrientation, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColorMainAxis, LONG nThickness, HRESULT hrPrev) : stOrientation(stOrientation), ipDestImage(ipDestImage), aColorMainAxis(aColorMainAxis), nThickness(nThickness), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw the main axis of a set of points/contour based on a rotated rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stOrientation">Rotated rectangle, containig center of mass, lenghts of axes, and rotation angle in clockwise direction</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColorMainAxis">Color of the major axis</param>
	/// <param name="nThickness">Line thickness</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawOrientation(HRESULT hrPrev, TcVnRotatedRectangle& stOrientation, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColorMainAxis, LONG nThickness)
	{
		Internal::DrawOrientation_Params params(stOrientation, ipDestImage, aColorMainAxis, nThickness, hrPrev);

		libraryInfo.functions[220 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawOrientationExp_Params
		{
			TcVnRotatedRectangle& stOrientation;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColorMainAxis;
			LONG nThickness;
			VN_TcVnVector4_LREAL& aColorHorizontalAxis;
			double fFontScale;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawOrientationExp_Params(TcVnRotatedRectangle& stOrientation, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColorMainAxis, LONG nThickness, TcVnVector4_LREAL& aColorHorizontalAxis, double fFontScale, HRESULT hrPrev) : stOrientation(stOrientation), ipDestImage(ipDestImage), aColorMainAxis(aColorMainAxis), nThickness(nThickness), aColorHorizontalAxis(aColorHorizontalAxis), fFontScale(fFontScale), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw the main axis, the horizontal axis and the angle of a set of points/contour based on a rotated rectangle. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stOrientation">Rotated rectangle, containig center of mass, lenghts of axes, and rotation angle in clockwise direction</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColorMainAxis">Color of the major axis</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="aColorHorizontalAxis">Color of the horizontal axis</param>
	/// <param name="fFontScale">Scaling factor for the text</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawOrientation(HRESULT hrPrev, TcVnRotatedRectangle& stOrientation, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColorMainAxis, LONG nThickness, TcVnVector4_LREAL& aColorHorizontalAxis, double fFontScale)
	{
		Internal::DrawOrientationExp_Params params(stOrientation, ipDestImage, aColorMainAxis, nThickness, aColorHorizontalAxis, fFontScale, hrPrev);

		libraryInfo.functions[221 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawPoint_Params
		{
			ULONG nX;
			ULONG nY;
			ITcVnImage* ipDestImage;
			ETcVnDrawShape eShape;
			VN_TcVnVector4_LREAL& aColor;
			ULONG nSize;
			LONG nThickness;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawPoint_Params(ULONG nX, ULONG nY, ITcVnImage* ipDestImage, ETcVnDrawShape eShape, TcVnVector4_LREAL& aColor, ULONG nSize, LONG nThickness, ETcVnLineType eLineType, HRESULT hrPrev) : nX(nX), nY(nY), ipDestImage(ipDestImage), eShape(eShape), aColor(aColor), nSize(nSize), nThickness(nThickness), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw a point. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nX">x coordinate of the point</param>
	/// <param name="nY">y coordinate of the point</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="eShape">Point shape</param>
	/// <param name="aColor">Color (for {-1, -1, -1, -1}, a random color is chosen)</param>
	/// <param name="nSize">Size of the shape (half width)</param>
	/// <param name="nThickness">Line thickness (if negative, the shape is filled if it is closed)</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawPoint(HRESULT hrPrev, ULONG nX, ULONG nY, ITcVnImage* ipDestImage, ETcVnDrawShape eShape, TcVnVector4_LREAL& aColor, ULONG nSize = 3, LONG nThickness = 1, ETcVnLineType eLineType = LT_8_CONNECTED)
	{
		Internal::DrawPoint_Params params(nX, nY, ipDestImage, eShape, aColor, nSize, nThickness, eLineType, hrPrev);

		libraryInfo.functions[222 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawPoints_Params
		{
			ITcVnContainer* ipPoints;
			ITcVnImage* ipDestImage;
			ETcVnDrawShape eShape;
			VN_TcVnVector4_LREAL& aColor;
			ULONG nSize;
			LONG nThickness;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawPoints_Params(ITcVnContainer* ipPoints, ITcVnImage* ipDestImage, ETcVnDrawShape eShape, TcVnVector4_LREAL& aColor, ULONG nSize, LONG nThickness, ETcVnLineType eLineType, HRESULT hrPrev) : ipPoints(ipPoints), ipDestImage(ipDestImage), eShape(eShape), aColor(aColor), nSize(nSize), nThickness(nThickness), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw a collection of points. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPoints">Container with TcVnPoint2_DINT or TcVnPoint2_REAL elements</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="eShape">Point shape</param>
	/// <param name="aColor">Color (for {-1, -1, -1, -1}, a random color is chosen for each point)</param>
	/// <param name="nSize">Size of the shape (half width)</param>
	/// <param name="nThickness">Line thickness (if negative, the shape is filled if it is closed)</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawPoints(HRESULT hrPrev, ITcVnContainer* ipPoints, ITcVnImage* ipDestImage, ETcVnDrawShape eShape, TcVnVector4_LREAL& aColor, ULONG nSize = 3, LONG nThickness = 1, ETcVnLineType eLineType = LT_8_CONNECTED)
	{
		Internal::DrawPoints_Params params(ipPoints, ipDestImage, eShape, aColor, nSize, nThickness, eLineType, hrPrev);

		libraryInfo.functions[223 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawPolygon_Params
		{
			ITcVnContainer* ipPoints;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			bool bIsClosed;
			ETcVnLineType eLineType;
			ULONG nShift;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawPolygon_Params(ITcVnContainer* ipPoints, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, bool bIsClosed, ETcVnLineType eLineType, ULONG nShift, HRESULT hrPrev) : ipPoints(ipPoints), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), bIsClosed(bIsClosed), eLineType(eLineType), nShift(nShift), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw a pologon using collection of points. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPoints">Container with TcVnPoint2_DINT, TcVnPoint2_REAL, or TcVnPoint2_LREAL elements</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the shape is filled)</param>
	/// <param name="bIsClosed">If it is true, the function draws a line from the last point to the first point to close the polygon.</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="nShift">Fractional bits of the coordinates (bit shift)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawPolygon(HRESULT hrPrev, ITcVnContainer* ipPoints, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, bool bIsClosed = true, ETcVnLineType eLineType = LT_8_CONNECTED, ULONG nShift = 0)
	{
		Internal::DrawPolygon_Params params(ipPoints, ipDestImage, aColor, nThickness, bIsClosed, eLineType, nShift, hrPrev);

		libraryInfo.functions[224 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawRectangle_Params
		{
			ULONG nTopLeftX;
			ULONG nTopLeftY;
			ULONG nBottomRightX;
			ULONG nBottomRightY;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawRectangle_Params(ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, HRESULT hrPrev) : nTopLeftX(nTopLeftX), nTopLeftY(nTopLeftY), nBottomRightX(nBottomRightX), nBottomRightY(nBottomRightY), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw a rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nTopLeftX">x coordinate of the top left corner</param>
	/// <param name="nTopLeftY">y coordinate of the top left corner</param>
	/// <param name="nBottomRightX">x coordinate of the bottom right corner</param>
	/// <param name="nBottomRightY">y coordinate of the bottom right corner</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the rectangle is filled)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawRectangle(HRESULT hrPrev, ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness)
	{
		Internal::DrawRectangle_Params params(nTopLeftX, nTopLeftY, nBottomRightX, nBottomRightY, ipDestImage, aColor, nThickness, hrPrev);

		libraryInfo.functions[225 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawRectangle_TcVnRectangle_DINT_Params
		{
			TcVnRectangle_DINT& stRectangle;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawRectangle_TcVnRectangle_DINT_Params(TcVnRectangle_DINT& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, HRESULT hrPrev) : stRectangle(stRectangle), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw a rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRectangle">Rectangle to be drawn</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the rectangle is filled)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawRectangle(HRESULT hrPrev, TcVnRectangle_DINT& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness)
	{
		Internal::DrawRectangle_TcVnRectangle_DINT_Params params(stRectangle, ipDestImage, aColor, nThickness, hrPrev);

		libraryInfo.functions[226 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawRectangle_TcVnRectangle_UDINT_Params
		{
			TcVnRectangle_UDINT& stRectangle;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawRectangle_TcVnRectangle_UDINT_Params(TcVnRectangle_UDINT& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, HRESULT hrPrev) : stRectangle(stRectangle), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw a rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRectangle">Rectangle to be drawn</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the rectangle is filled)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawRectangle(HRESULT hrPrev, TcVnRectangle_UDINT& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness)
	{
		Internal::DrawRectangle_TcVnRectangle_UDINT_Params params(stRectangle, ipDestImage, aColor, nThickness, hrPrev);

		libraryInfo.functions[227 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DrawRotatedRectangle_Params
		{
			TcVnRotatedRectangle& stRectangle;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawRotatedRectangle_Params(TcVnRotatedRectangle& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, HRESULT hrPrev) : stRectangle(stRectangle), ipDestImage(ipDestImage), aColor(aColor), nThickness(nThickness), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draw a rectangle. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRectangle">Rectangle to be drawn (rotation angle in degrees)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <param name="nThickness">Line thickness (if negative, the rectangle is filled)</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawRotatedRectangle(HRESULT hrPrev, TcVnRotatedRectangle& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType = LT_8_CONNECTED)
	{
		Internal::DrawRotatedRectangle_Params params(stRectangle, ipDestImage, aColor, nThickness, eLineType, hrPrev);

		libraryInfo.functions[228 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ElementwiseExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			ElementwiseExp_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the natural exponent of each pixel value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (REAL or LREAL)</param>
	/// <param name="ipDestImage">Destination image (Same type and size as ipSrcImage, an appropriate image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ElementwiseExp(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::ElementwiseExp_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[229 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ElementwiseLog_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			ElementwiseLog_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the natural logarithm of each pixel value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (REAL or LREAL)</param>
	/// <param name="ipDestImage">Destination image (Same type and size as ipSrcImage, an appropriate image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ElementwiseLog(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::ElementwiseLog_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[230 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct EnclosingCircle_Params
		{
			ITcVnContainer* ipPointSet;
			VN_TcVnPoint2_REAL& aCenter;
			float& fRadius;
			HRESULT hrPrev;
			HRESULT retVal;

			EnclosingCircle_Params(ITcVnContainer* ipPointSet, TcVnPoint2_REAL& aCenter, float& fRadius, HRESULT hrPrev) : ipPointSet(ipPointSet), aCenter(aCenter), fRadius(fRadius), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Searchs for a minimum area circle enclosing a set of points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the individual points.)</param>
	/// <param name="aCenter">Returns the center of the circle</param>
	/// <param name="fRadius">Returns the radius of the circle</param>
	/// <returns>HRESULT</returns>
	static HRESULT EnclosingCircle(HRESULT hrPrev, ITcVnContainer* ipPointSet, TcVnPoint2_REAL& aCenter, float& fRadius)
	{
		Internal::EnclosingCircle_Params params(ipPointSet, aCenter, fRadius, hrPrev);

		libraryInfo.functions[231 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct EnclosingRectangle_Params
		{
			ITcVnContainer* ipPointSet;
			TcVnRotatedRectangle& stRectangle;
			HRESULT hrPrev;
			HRESULT retVal;

			EnclosingRectangle_Params(ITcVnContainer* ipPointSet, TcVnRotatedRectangle& stRectangle, HRESULT hrPrev) : ipPointSet(ipPointSet), stRectangle(stRectangle), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Searches for a minimum area rectangle enclosing a set of points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the individual points.)</param>
	/// <param name="stRectangle">Returns the determined rectangle</param>
	/// <returns>HRESULT</returns>
	static HRESULT EnclosingRectangle(HRESULT hrPrev, ITcVnContainer* ipPointSet, TcVnRotatedRectangle& stRectangle)
	{
		Internal::EnclosingRectangle_Params params(ipPointSet, stRectangle, hrPrev);

		libraryInfo.functions[232 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct EnclosingTriangle_Params
		{
			ITcVnContainer* ipPointSet;
			TcVnArray3_Point2_REAL& aTriangleVertices;
			HRESULT hrPrev;
			HRESULT retVal;
			double fArea;

			EnclosingTriangle_Params(ITcVnContainer* ipPointSet, TcVnArray3_Point2_REAL& aTriangleVertices, HRESULT hrPrev) : ipPointSet(ipPointSet), aTriangleVertices(aTriangleVertices), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Searches for a minimum area triangle enclosing a set of points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the individual points.)</param>
	/// <param name="aTriangleVertices">Returns the 3 triangle vertices</param>
	/// <param name="fArea">Returns the triangle area</param>
	/// <returns>HRESULT</returns>
	static HRESULT EnclosingTriangle(HRESULT hrPrev, ITcVnContainer* ipPointSet, TcVnArray3_Point2_REAL& aTriangleVertices, double& fArea)
	{
		Internal::EnclosingTriangle_Params params(ipPointSet, aTriangleVertices, hrPrev);

		libraryInfo.functions[233 - Lic0FuncsOffs].pFct(&params);

		AssignTo(fArea, params.fArea);

		return params.retVal;
	}

	/// <summary>
	/// Searches for a minimum area triangle enclosing a set of points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the individual points.)</param>
	/// <param name="aTriangleVertices">Returns the 3 triangle vertices</param>
	/// <returns>HRESULT</returns>
	static HRESULT EnclosingTriangle(HRESULT hrPrev, ITcVnContainer* ipPointSet, TcVnArray3_Point2_REAL& aTriangleVertices)
	{
		Internal::EnclosingTriangle_Params params(ipPointSet, aTriangleVertices, hrPrev);

		libraryInfo.functions[233 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct EraseFromContainer_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			EraseFromContainer_Params(ITcVnContainer* ipContainer, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Erase elements from a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container from which to erase elements</param>
	/// <param name="nStartIdx">Index of the first element to erase</param>
	/// <param name="nCount">Number of elements to erase</param>
	/// <returns>HRESULT</returns>
	static HRESULT EraseFromContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::EraseFromContainer_Params params(ipContainer, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[234 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportContainer_Params
		{
			ITcVnContainer* ipContainer;
			PVOID pBuffer;
			ULONGLONG nBufferSize;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportContainer_Params(ITcVnContainer* ipContainer, PVOID pBuffer, ULONGLONG nBufferSize, HRESULT hrPrev) : ipContainer(ipContainer), pBuffer(pBuffer), nBufferSize(nBufferSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Export the container elements into a buffer (e.g. an array). Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="pBuffer">Buffer to store the container elements (Make sure to allocate enough memory! The required size in bytes can be determined using the function F_VN_ExportContainerSize)</param>
	/// <param name="nBufferSize">Size of the buffer memory in bytes</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, PVOID pBuffer, ULONGLONG nBufferSize)
	{
		Internal::ExportContainer_Params params(ipContainer, pBuffer, nBufferSize, hrPrev);

		libraryInfo.functions[235 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportContainer_String_Params
		{
			ITcVnContainer* ipContainer;
			PCHAR sText;
			ULONGLONG nMaxLength;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportContainer_String_Params(ITcVnContainer* ipContainer, PCHAR sText, ULONGLONG nMaxLength, HRESULT hrPrev) : ipContainer(ipContainer), sText(sText), nMaxLength(nMaxLength), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Export the container elements into a string. Only possible for containers of type ContainerType_String_SINT.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container of type ContainerType_String_SINT</param>
	/// <param name="sText">Make sure to choose a sufficient STRING size! The required size can be determined using the function VnExportContainerSize.</param>
	/// <param name="nMaxLength">Maximum string length to export (including 0 termination). If the container content is longer, the string is cut off at nMaxLength - 1 and 0 termination is appended. In this case, S_FALSE is returned.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportContainer_String(HRESULT hrPrev, ITcVnContainer* ipContainer, PCHAR sText, ULONGLONG nMaxLength)
	{
		Internal::ExportContainer_String_Params params(ipContainer, sText, nMaxLength, hrPrev);

		libraryInfo.functions[236 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportContainerSize_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG& nBufferSize;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportContainerSize_Params(ITcVnContainer* ipContainer, ULONGLONG& nBufferSize, HRESULT hrPrev) : ipContainer(ipContainer), nBufferSize(nBufferSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Determine the required buffer size in bytes to store all container elements (number_of_Elements * size_per_Element). Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nBufferSize">Output parameter containing the required buffer size</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportContainerSize(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG& nBufferSize)
	{
		Internal::ExportContainerSize_Params params(ipContainer, nBufferSize, hrPrev);

		libraryInfo.functions[237 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportImage_Params
		{
			ITcVnImage* ipImage;
			PVOID pBuffer;
			ULONGLONG nBufferSize;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportImage_Params(ITcVnImage* ipImage, PVOID pBuffer, ULONGLONG nBufferSize, HRESULT hrPrev) : ipImage(ipImage), pBuffer(pBuffer), nBufferSize(nBufferSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Exports the image data into a given buffer (e.g. an array). F_VN_ExportImageSize should be called before to get the required buffer size.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="pBuffer">Pointer to a buffer to store the image data (Make sure to allocate enough memory! The required size in bytes can be determined using the function F_VN_ExportImageSize)</param>
	/// <param name="nBufferSize">Size of the buffer memory in bytes</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportImage(HRESULT hrPrev, ITcVnImage* ipImage, PVOID pBuffer, ULONGLONG nBufferSize)
	{
		Internal::ExportImage_Params params(ipImage, pBuffer, nBufferSize, hrPrev);

		libraryInfo.functions[238 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportImageAsBmp_Params
		{
			ITcVnImage* ipImage;
			PVOID pBuffer;
			ULONGLONG nBufferSize;
			ULONG nWidth;
			ULONG nHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportImageAsBmp_Params(ITcVnImage* ipImage, PVOID pBuffer, ULONGLONG nBufferSize, ULONG nWidth, ULONG nHeight, HRESULT hrPrev) : ipImage(ipImage), pBuffer(pBuffer), nBufferSize(nBufferSize), nWidth(nWidth), nHeight(nHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Exports the image as bitmap into a given buffer (e.g. an array). F_VN_ExportImageAsBmpSizeExp should be called before to get the required buffer size. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="pBuffer">Pointer to a buffer to store the bitmap image (Make sure to allocate enough memory! The required size in bytes can be determined using the function F_VN_ExportImageAsBmpSizeExp)</param>
	/// <param name="nBufferSize">Size of the buffer memory in bytes</param>
	/// <param name="nWidth">Desired width (or 0 to keep the original width)</param>
	/// <param name="nHeight">Desired height (or 0 to keep the original height)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportImageAsBmp(HRESULT hrPrev, ITcVnImage* ipImage, PVOID pBuffer, ULONGLONG nBufferSize, ULONG nWidth = 0, ULONG nHeight = 0)
	{
		Internal::ExportImageAsBmp_Params params(ipImage, pBuffer, nBufferSize, nWidth, nHeight, hrPrev);

		libraryInfo.functions[239 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportImageAsBmpSize_Params
		{
			ITcVnImage* ipImage;
			ULONGLONG& nBufferSize;
			ULONG nWidth;
			ULONG nHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportImageAsBmpSize_Params(ITcVnImage* ipImage, ULONGLONG& nBufferSize, ULONG nWidth, ULONG nHeight, HRESULT hrPrev) : ipImage(ipImage), nBufferSize(nBufferSize), nWidth(nWidth), nHeight(nHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the required buffer size (in bytes) to store the image as bitmap. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="nBufferSize">Returns the required buffer size in bytes</param>
	/// <param name="nWidth">Desired width (or 0 to keep the original width)</param>
	/// <param name="nHeight">Desired height (or 0 to keep the original height)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportImageAsBmpSize(HRESULT hrPrev, ITcVnImage* ipImage, ULONGLONG& nBufferSize, ULONG nWidth = 0, ULONG nHeight = 0)
	{
		Internal::ExportImageAsBmpSize_Params params(ipImage, nBufferSize, nWidth, nHeight, hrPrev);

		libraryInfo.functions[240 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportImageSize_Params
		{
			ITcVnImage* ipImage;
			ULONGLONG& nBufferSize;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportImageSize_Params(ITcVnImage* ipImage, ULONGLONG& nBufferSize, HRESULT hrPrev) : ipImage(ipImage), nBufferSize(nBufferSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the required buffer size (in bytes) to store the image data.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="nBufferSize">Returns the required buffer size in bytes</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportImageSize(HRESULT hrPrev, ITcVnImage* ipImage, ULONGLONG& nBufferSize)
	{
		Internal::ExportImageSize_Params params(ipImage, nBufferSize, hrPrev);

		libraryInfo.functions[241 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportSubContainer_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			PVOID pBuffer;
			ULONGLONG nBufferSize;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportSubContainer_Params(ITcVnContainer* ipContainer, ULONGLONG nIndex, PVOID pBuffer, ULONGLONG nBufferSize, HRESULT hrPrev) : ipContainer(ipContainer), nIndex(nIndex), pBuffer(pBuffer), nBufferSize(nBufferSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Export the container elements of a sub-container into a buffer (e.g. an array). Only possible for 2-dimensional containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <param name="pBuffer">Buffer to store the container elements (Make sure to allocate enough memory! The required size in bytes can be determined using the function F_VN_ExportSubContainerSize)</param>
	/// <param name="nBufferSize">Size of the buffer memory in bytes</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportSubContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG nIndex, PVOID pBuffer, ULONGLONG nBufferSize)
	{
		Internal::ExportSubContainer_Params params(ipContainer, nIndex, pBuffer, nBufferSize, hrPrev);

		libraryInfo.functions[242 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportSubContainer_String_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			PCHAR sText;
			ULONGLONG nMaxLength;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportSubContainer_String_Params(ITcVnContainer* ipContainer, ULONGLONG nIndex, PCHAR sText, ULONGLONG nMaxLength, HRESULT hrPrev) : ipContainer(ipContainer), nIndex(nIndex), sText(sText), nMaxLength(nMaxLength), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Export the container elements of a sub-container into a string. Only possible for 2-dimensional containers of type ContainerType_Vector_String_SINT.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container of type ContainerType_Vector_String_SINT</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <param name="sText">Make sure to choose a sufficient STRING size! The required size can be determined using the function VnExportSubContainerSize.</param>
	/// <param name="nMaxLength">Maximum string length to export (including 0 termination). If the container content is longer, the string is cut off at nMaxLength - 1 and 0 termination is appended. In this case, S_FALSE is returned.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportSubContainer_String(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG nIndex, PCHAR sText, ULONGLONG nMaxLength)
	{
		Internal::ExportSubContainer_String_Params params(ipContainer, nIndex, sText, nMaxLength, hrPrev);

		libraryInfo.functions[243 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExportSubContainerSize_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			ULONGLONG& nBufferSize;
			HRESULT hrPrev;
			HRESULT retVal;

			ExportSubContainerSize_Params(ITcVnContainer* ipContainer, ULONGLONG nIndex, ULONGLONG& nBufferSize, HRESULT hrPrev) : ipContainer(ipContainer), nIndex(nIndex), nBufferSize(nBufferSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Determine the required buffer size in bytes to store all container elements of a sub-container (number_of_Elements * size_per_Element). Only possible for 2-dimensional containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <param name="nBufferSize">Output parameter containing the required buffer size</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExportSubContainerSize(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG nIndex, ULONGLONG& nBufferSize)
	{
		Internal::ExportSubContainerSize_Params params(ipContainer, nIndex, nBufferSize, hrPrev);

		libraryInfo.functions[244 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExtractContainerRange_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			ULONGLONG nFirstIdx;
			ULONGLONG nLastIdx;
			HRESULT hrPrev;
			HRESULT retVal;

			ExtractContainerRange_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ULONGLONG nFirstIdx, ULONGLONG nLastIdx, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), nFirstIdx(nFirstIdx), nLastIdx(nLastIdx), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Copy the specified range of the source container into the destination container. (If the destination container already contains elements, they will be removed.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container</param>
	/// <param name="ipDestContainer">Destination container</param>
	/// <param name="nFirstIdx">Index of the first element to copy</param>
	/// <param name="nLastIdx">Index of the last element to copy</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExtractContainerRange(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ULONGLONG nFirstIdx, ULONGLONG nLastIdx)
	{
		Internal::ExtractContainerRange_Params params(ipSrcContainer, ipDestContainer, nFirstIdx, nLastIdx, hrPrev);

		libraryInfo.functions[245 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillCircle_Params
		{
			ULONG nCenterX;
			ULONG nCenterY;
			ULONG nRadius;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			HRESULT hrPrev;
			HRESULT retVal;

			FillCircle_Params(ULONG nCenterX, ULONG nCenterY, ULONG nRadius, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, HRESULT hrPrev) : nCenterX(nCenterX), nCenterY(nCenterY), nRadius(nRadius), ipDestImage(ipDestImage), aColor(aColor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Paint a filled circle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nCenterX">x coordinate of the center</param>
	/// <param name="nCenterY">y coordinate of the center</param>
	/// <param name="nRadius">Radius</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillCircle(HRESULT hrPrev, ULONG nCenterX, ULONG nCenterY, ULONG nRadius, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor)
	{
		Internal::FillCircle_Params params(nCenterX, nCenterY, nRadius, ipDestImage, aColor, hrPrev);

		libraryInfo.functions[246 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_DINT_Params
		{
			ITcVnContainer* ipContainer;
			LONG nValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_DINT_Params(ITcVnContainer* ipContainer, LONG nValue, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, LONG nValue)
	{
		Internal::FillContainer_DINT_Params params(ipContainer, nValue, hrPrev);

		libraryInfo.functions[247 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_INT_Params
		{
			ITcVnContainer* ipContainer;
			SHORT nValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_INT_Params(ITcVnContainer* ipContainer, SHORT nValue, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, SHORT nValue)
	{
		Internal::FillContainer_INT_Params params(ipContainer, nValue, hrPrev);

		libraryInfo.functions[248 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_ITcVnImage_Params
		{
			ITcVnContainer* ipContainer;
			ITcVnImage* ipValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_ITcVnImage_Params(ITcVnContainer* ipContainer, ITcVnImage* ipValue, HRESULT hrPrev) : ipContainer(ipContainer), ipValue(ipValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="ipValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ITcVnImage* ipValue)
	{
		Internal::FillContainer_ITcVnImage_Params params(ipContainer, ipValue, hrPrev);

		libraryInfo.functions[249 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			double fValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_LREAL_Params(ITcVnContainer* ipContainer, double fValue, HRESULT hrPrev) : ipContainer(ipContainer), fValue(fValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="fValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, double fValue)
	{
		Internal::FillContainer_LREAL_Params params(ipContainer, fValue, hrPrev);

		libraryInfo.functions[250 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_REAL_Params
		{
			ITcVnContainer* ipContainer;
			float fValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_REAL_Params(ITcVnContainer* ipContainer, float fValue, HRESULT hrPrev) : ipContainer(ipContainer), fValue(fValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="fValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, float fValue)
	{
		Internal::FillContainer_REAL_Params params(ipContainer, fValue, hrPrev);

		libraryInfo.functions[251 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_SINT_Params
		{
			ITcVnContainer* ipContainer;
			char nValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_SINT_Params(ITcVnContainer* ipContainer, char nValue, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, char nValue)
	{
		Internal::FillContainer_SINT_Params params(ipContainer, nValue, hrPrev);

		libraryInfo.functions[252 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnDMatch_Params
		{
			ITcVnContainer* ipContainer;
			TcVnDMatch& stValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnDMatch_Params(ITcVnContainer* ipContainer, TcVnDMatch& stValue, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnDMatch& stValue)
	{
		Internal::FillContainer_TcVnDMatch_Params params(ipContainer, stValue, hrPrev);

		libraryInfo.functions[253 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnKeyPoint_Params
		{
			ITcVnContainer* ipContainer;
			TcVnKeyPoint& stValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnKeyPoint_Params(ITcVnContainer* ipContainer, TcVnKeyPoint& stValue, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnKeyPoint& stValue)
	{
		Internal::FillContainer_TcVnKeyPoint_Params params(ipContainer, stValue, hrPrev);

		libraryInfo.functions[254 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnPoint2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_DINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnPoint2_DINT_Params(ITcVnContainer* ipContainer, TcVnPoint2_DINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_DINT& aValue)
	{
		Internal::FillContainer_TcVnPoint2_DINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[255 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnPoint2_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_LREAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnPoint2_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aValue)
	{
		Internal::FillContainer_TcVnPoint2_LREAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[256 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnPoint2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_REAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnPoint2_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_REAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_REAL& aValue)
	{
		Internal::FillContainer_TcVnPoint2_REAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[257 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnPoint3_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_LREAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnPoint3_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aValue)
	{
		Internal::FillContainer_TcVnPoint3_LREAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[258 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnPoint3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_REAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnPoint3_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_REAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_REAL& aValue)
	{
		Internal::FillContainer_TcVnPoint3_REAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[259 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnRectangle_DINT_Params
		{
			ITcVnContainer* ipContainer;
			TcVnRectangle_DINT& stValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnRectangle_DINT_Params(ITcVnContainer* ipContainer, TcVnRectangle_DINT& stValue, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnRectangle_DINT& stValue)
	{
		Internal::FillContainer_TcVnRectangle_DINT_Params params(ipContainer, stValue, hrPrev);

		libraryInfo.functions[260 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnRotatedRectangle_Params
		{
			ITcVnContainer* ipContainer;
			TcVnRotatedRectangle& stValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnRotatedRectangle_Params(ITcVnContainer* ipContainer, TcVnRotatedRectangle& stValue, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnRotatedRectangle& stValue)
	{
		Internal::FillContainer_TcVnRotatedRectangle_Params params(ipContainer, stValue, hrPrev);

		libraryInfo.functions[261 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_DINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector2_DINT_Params(ITcVnContainer* ipContainer, TcVnVector2_DINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_DINT& aValue)
	{
		Internal::FillContainer_TcVnVector2_DINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[262 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector2_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_INT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector2_INT_Params(ITcVnContainer* ipContainer, TcVnVector2_INT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_INT& aValue)
	{
		Internal::FillContainer_TcVnVector2_INT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[263 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_REAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector2_REAL_Params(ITcVnContainer* ipContainer, TcVnVector2_REAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_REAL& aValue)
	{
		Internal::FillContainer_TcVnVector2_REAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[264 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector2_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_SINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector2_SINT_Params(ITcVnContainer* ipContainer, TcVnVector2_SINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_SINT& aValue)
	{
		Internal::FillContainer_TcVnVector2_SINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[265 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector2_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_UINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector2_UINT_Params(ITcVnContainer* ipContainer, TcVnVector2_UINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_UINT& aValue)
	{
		Internal::FillContainer_TcVnVector2_UINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[266 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector2_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_USINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector2_USINT_Params(ITcVnContainer* ipContainer, TcVnVector2_USINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_USINT& aValue)
	{
		Internal::FillContainer_TcVnVector2_USINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[267 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector3_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_INT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector3_INT_Params(ITcVnContainer* ipContainer, TcVnVector3_INT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_INT& aValue)
	{
		Internal::FillContainer_TcVnVector3_INT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[268 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_REAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector3_REAL_Params(ITcVnContainer* ipContainer, TcVnVector3_REAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_REAL& aValue)
	{
		Internal::FillContainer_TcVnVector3_REAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[269 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector3_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_SINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector3_SINT_Params(ITcVnContainer* ipContainer, TcVnVector3_SINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_SINT& aValue)
	{
		Internal::FillContainer_TcVnVector3_SINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[270 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector3_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_UINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector3_UINT_Params(ITcVnContainer* ipContainer, TcVnVector3_UINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_UINT& aValue)
	{
		Internal::FillContainer_TcVnVector3_UINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[271 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector3_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_USINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector3_USINT_Params(ITcVnContainer* ipContainer, TcVnVector3_USINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_USINT& aValue)
	{
		Internal::FillContainer_TcVnVector3_USINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[272 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector4_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_DINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector4_DINT_Params(ITcVnContainer* ipContainer, TcVnVector4_DINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_DINT& aValue)
	{
		Internal::FillContainer_TcVnVector4_DINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[273 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector4_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_INT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector4_INT_Params(ITcVnContainer* ipContainer, TcVnVector4_INT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_INT& aValue)
	{
		Internal::FillContainer_TcVnVector4_INT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[274 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector4_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_LREAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector4_LREAL_Params(ITcVnContainer* ipContainer, TcVnVector4_LREAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_LREAL& aValue)
	{
		Internal::FillContainer_TcVnVector4_LREAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[275 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector4_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_REAL& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector4_REAL_Params(ITcVnContainer* ipContainer, TcVnVector4_REAL& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_REAL& aValue)
	{
		Internal::FillContainer_TcVnVector4_REAL_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[276 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector4_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_SINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector4_SINT_Params(ITcVnContainer* ipContainer, TcVnVector4_SINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_SINT& aValue)
	{
		Internal::FillContainer_TcVnVector4_SINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[277 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector4_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_UINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector4_UINT_Params(ITcVnContainer* ipContainer, TcVnVector4_UINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_UINT& aValue)
	{
		Internal::FillContainer_TcVnVector4_UINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[278 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_TcVnVector4_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_USINT& aValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_TcVnVector4_USINT_Params(ITcVnContainer* ipContainer, TcVnVector4_USINT& aValue, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_USINT& aValue)
	{
		Internal::FillContainer_TcVnVector4_USINT_Params params(ipContainer, aValue, hrPrev);

		libraryInfo.functions[279 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_UDINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONG nValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_UDINT_Params(ITcVnContainer* ipContainer, ULONG nValue, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONG nValue)
	{
		Internal::FillContainer_UDINT_Params params(ipContainer, nValue, hrPrev);

		libraryInfo.functions[280 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_UINT_Params
		{
			ITcVnContainer* ipContainer;
			USHORT nValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_UINT_Params(ITcVnContainer* ipContainer, USHORT nValue, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, USHORT nValue)
	{
		Internal::FillContainer_UINT_Params params(ipContainer, nValue, hrPrev);

		libraryInfo.functions[281 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_ULINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG nValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_ULINT_Params(ITcVnContainer* ipContainer, ULONGLONG nValue, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG nValue)
	{
		Internal::FillContainer_ULINT_Params params(ipContainer, nValue, hrPrev);

		libraryInfo.functions[282 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainer_USINT_Params
		{
			ITcVnContainer* ipContainer;
			unsigned char nValue;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainer_USINT_Params(ITcVnContainer* ipContainer, unsigned char nValue, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill the container with the specified value. Only possible for containers with basic elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, unsigned char nValue)
	{
		Internal::FillContainer_USINT_Params params(ipContainer, nValue, hrPrev);

		libraryInfo.functions[283 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_DINT_Params
		{
			ITcVnContainer* ipContainer;
			LONG nValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_DINT_Params(ITcVnContainer* ipContainer, LONG nValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, LONG nValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_DINT_Params params(ipContainer, nValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[284 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_INT_Params
		{
			ITcVnContainer* ipContainer;
			SHORT nValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_INT_Params(ITcVnContainer* ipContainer, SHORT nValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, SHORT nValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_INT_Params params(ipContainer, nValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[285 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_ITcVnImage_Params
		{
			ITcVnContainer* ipContainer;
			ITcVnImage* ipValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_ITcVnImage_Params(ITcVnContainer* ipContainer, ITcVnImage* ipValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), ipValue(ipValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="ipValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ITcVnImage* ipValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_ITcVnImage_Params params(ipContainer, ipValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[286 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			double fValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_LREAL_Params(ITcVnContainer* ipContainer, double fValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), fValue(fValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="fValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, double fValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_LREAL_Params params(ipContainer, fValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[287 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_REAL_Params
		{
			ITcVnContainer* ipContainer;
			float fValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_REAL_Params(ITcVnContainer* ipContainer, float fValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), fValue(fValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="fValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, float fValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_REAL_Params params(ipContainer, fValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[288 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_SINT_Params
		{
			ITcVnContainer* ipContainer;
			char nValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_SINT_Params(ITcVnContainer* ipContainer, char nValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, char nValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_SINT_Params params(ipContainer, nValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[289 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnDMatch_Params
		{
			ITcVnContainer* ipContainer;
			TcVnDMatch& stValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnDMatch_Params(ITcVnContainer* ipContainer, TcVnDMatch& stValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnDMatch& stValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnDMatch_Params params(ipContainer, stValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[290 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnKeyPoint_Params
		{
			ITcVnContainer* ipContainer;
			TcVnKeyPoint& stValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnKeyPoint_Params(ITcVnContainer* ipContainer, TcVnKeyPoint& stValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnKeyPoint& stValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnKeyPoint_Params params(ipContainer, stValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[291 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnPoint2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_DINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnPoint2_DINT_Params(ITcVnContainer* ipContainer, TcVnPoint2_DINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_DINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnPoint2_DINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[292 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnPoint2_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_LREAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnPoint2_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnPoint2_LREAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[293 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnPoint2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_REAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnPoint2_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnPoint2_REAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[294 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnPoint3_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_LREAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnPoint3_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnPoint3_LREAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[295 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnPoint3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_REAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnPoint3_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnPoint3_REAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[296 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnRectangle_DINT_Params
		{
			ITcVnContainer* ipContainer;
			TcVnRectangle_DINT& stValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnRectangle_DINT_Params(ITcVnContainer* ipContainer, TcVnRectangle_DINT& stValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnRectangle_DINT& stValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnRectangle_DINT_Params params(ipContainer, stValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[297 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnRotatedRectangle_Params
		{
			ITcVnContainer* ipContainer;
			TcVnRotatedRectangle& stValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnRotatedRectangle_Params(ITcVnContainer* ipContainer, TcVnRotatedRectangle& stValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), stValue(stValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="stValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnRotatedRectangle& stValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnRotatedRectangle_Params params(ipContainer, stValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[298 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_DINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector2_DINT_Params(ITcVnContainer* ipContainer, TcVnVector2_DINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_DINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector2_DINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[299 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector2_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_INT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector2_INT_Params(ITcVnContainer* ipContainer, TcVnVector2_INT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_INT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector2_INT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[300 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_REAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector2_REAL_Params(ITcVnContainer* ipContainer, TcVnVector2_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector2_REAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[301 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector2_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_SINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector2_SINT_Params(ITcVnContainer* ipContainer, TcVnVector2_SINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_SINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector2_SINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[302 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector2_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_UINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector2_UINT_Params(ITcVnContainer* ipContainer, TcVnVector2_UINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_UINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector2_UINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[303 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector2_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_USINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector2_USINT_Params(ITcVnContainer* ipContainer, TcVnVector2_USINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_USINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector2_USINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[304 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector3_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_INT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector3_INT_Params(ITcVnContainer* ipContainer, TcVnVector3_INT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_INT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector3_INT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[305 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_REAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector3_REAL_Params(ITcVnContainer* ipContainer, TcVnVector3_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector3_REAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[306 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector3_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_SINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector3_SINT_Params(ITcVnContainer* ipContainer, TcVnVector3_SINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_SINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector3_SINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[307 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector3_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_UINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector3_UINT_Params(ITcVnContainer* ipContainer, TcVnVector3_UINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_UINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector3_UINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[308 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector3_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_USINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector3_USINT_Params(ITcVnContainer* ipContainer, TcVnVector3_USINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_USINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector3_USINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[309 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector4_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_DINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector4_DINT_Params(ITcVnContainer* ipContainer, TcVnVector4_DINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_DINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector4_DINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[310 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector4_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_INT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector4_INT_Params(ITcVnContainer* ipContainer, TcVnVector4_INT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_INT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector4_INT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[311 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector4_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_LREAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector4_LREAL_Params(ITcVnContainer* ipContainer, TcVnVector4_LREAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_LREAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector4_LREAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[312 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector4_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_REAL& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector4_REAL_Params(ITcVnContainer* ipContainer, TcVnVector4_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_REAL& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector4_REAL_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[313 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector4_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_SINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector4_SINT_Params(ITcVnContainer* ipContainer, TcVnVector4_SINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_SINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector4_SINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[314 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector4_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_UINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector4_UINT_Params(ITcVnContainer* ipContainer, TcVnVector4_UINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_UINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector4_UINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[315 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_TcVnVector4_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_USINT& aValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_TcVnVector4_USINT_Params(ITcVnContainer* ipContainer, TcVnVector4_USINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), aValue(aValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="aValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_USINT& aValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_TcVnVector4_USINT_Params params(ipContainer, aValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[316 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_UDINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONG nValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_UDINT_Params(ITcVnContainer* ipContainer, ULONG nValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONG nValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_UDINT_Params params(ipContainer, nValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[317 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_UINT_Params
		{
			ITcVnContainer* ipContainer;
			USHORT nValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_UINT_Params(ITcVnContainer* ipContainer, USHORT nValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, USHORT nValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_UINT_Params params(ipContainer, nValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[318 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_ULINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG nValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_ULINT_Params(ITcVnContainer* ipContainer, ULONGLONG nValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG nValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_ULINT_Params params(ipContainer, nValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[319 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContainerExp_USINT_Params
		{
			ITcVnContainer* ipContainer;
			unsigned char nValue;
			ULONGLONG nStartIdx;
			ULONGLONG nCount;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContainerExp_USINT_Params(ITcVnContainer* ipContainer, unsigned char nValue, ULONGLONG nStartIdx, ULONGLONG nCount, HRESULT hrPrev) : ipContainer(ipContainer), nValue(nValue), nStartIdx(nStartIdx), nCount(nCount), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Partially fill the container with the specified value. Only possible for containers with basic elements. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with basic elements</param>
	/// <param name="nValue">Value to set the container elements</param>
	/// <param name="nStartIdx">Start index</param>
	/// <param name="nCount">Number of elements to set</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContainer(HRESULT hrPrev, ITcVnContainer* ipContainer, unsigned char nValue, ULONGLONG nStartIdx, ULONGLONG nCount)
	{
		Internal::FillContainerExp_USINT_Params params(ipContainer, nValue, nStartIdx, nCount, hrPrev);

		libraryInfo.functions[320 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillContours_Params
		{
			ITcVnContainer* ipContours;
			LONG nContourIndex;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			HRESULT hrPrev;
			HRESULT retVal;

			FillContours_Params(ITcVnContainer* ipContours, LONG nContourIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, HRESULT hrPrev) : ipContours(ipContours), nContourIndex(nContourIndex), ipDestImage(ipDestImage), aColor(aColor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Paint a single point set or multiple point sets that are interpreted as contours.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContours">Single contour (ContainerType_Vector_TcVnPoint2_DINT) or multiple contours (ContainerType_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="nContourIndex">Index of a specific contour to be drawn (if negative, all contours within the container are drawn)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillContours(HRESULT hrPrev, ITcVnContainer* ipContours, LONG nContourIndex, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor)
	{
		Internal::FillContours_Params params(ipContours, nContourIndex, ipDestImage, aColor, hrPrev);

		libraryInfo.functions[321 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillEllipse_Params
		{
			TcVnRotatedRectangle& stEllipse;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			HRESULT hrPrev;
			HRESULT retVal;

			FillEllipse_Params(TcVnRotatedRectangle& stEllipse, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, HRESULT hrPrev) : stEllipse(stEllipse), ipDestImage(ipDestImage), aColor(aColor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Paint a filled ellipse.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stEllipse">Ellipse to be painted (rotation angle in degrees)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillEllipse(HRESULT hrPrev, TcVnRotatedRectangle& stEllipse, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor)
	{
		Internal::FillEllipse_Params params(stEllipse, ipDestImage, aColor, hrPrev);

		libraryInfo.functions[322 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillHoles_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			FillHoles_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fill holes within a gray-scale single-channel image. (equivalent to finding dark border objects)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, UINT, INT, REAL, or LREAL, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillHoles(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::FillHoles_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[323 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillPolygon_Params
		{
			ITcVnContainer* ipPoints;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			HRESULT hrPrev;
			HRESULT retVal;

			FillPolygon_Params(ITcVnContainer* ipPoints, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, HRESULT hrPrev) : ipPoints(ipPoints), ipDestImage(ipDestImage), aColor(aColor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Paint a filled pologon using a set of points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPoints">Container with TcVnPoint2_DINT, TcVnPoint2_REAL, or TcVnPoint2_LREAL elements</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillPolygon(HRESULT hrPrev, ITcVnContainer* ipPoints, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor)
	{
		Internal::FillPolygon_Params params(ipPoints, ipDestImage, aColor, hrPrev);

		libraryInfo.functions[324 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillRectangle_Params
		{
			ULONG nTopLeftX;
			ULONG nTopLeftY;
			ULONG nBottomRightX;
			ULONG nBottomRightY;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			HRESULT hrPrev;
			HRESULT retVal;

			FillRectangle_Params(ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, HRESULT hrPrev) : nTopLeftX(nTopLeftX), nTopLeftY(nTopLeftY), nBottomRightX(nBottomRightX), nBottomRightY(nBottomRightY), ipDestImage(ipDestImage), aColor(aColor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Paint a filled rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nTopLeftX">x coordinate of the top left corner</param>
	/// <param name="nTopLeftY">y coordinate of the top left corner</param>
	/// <param name="nBottomRightX">x coordinate of the bottom right corner</param>
	/// <param name="nBottomRightY">y coordinate of the bottom right corner</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillRectangle(HRESULT hrPrev, ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor)
	{
		Internal::FillRectangle_Params params(nTopLeftX, nTopLeftY, nBottomRightX, nBottomRightY, ipDestImage, aColor, hrPrev);

		libraryInfo.functions[325 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FillRotatedRectangle_Params
		{
			TcVnRotatedRectangle& stRectangle;
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			HRESULT hrPrev;
			HRESULT retVal;

			FillRotatedRectangle_Params(TcVnRotatedRectangle& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor, HRESULT hrPrev) : stRectangle(stRectangle), ipDestImage(ipDestImage), aColor(aColor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Paint a filled rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRectangle">Rectangle to be painted (rotation angle in degrees)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aColor">Color</param>
	/// <returns>HRESULT</returns>
	static HRESULT FillRotatedRectangle(HRESULT hrPrev, TcVnRotatedRectangle& stRectangle, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aColor)
	{
		Internal::FillRotatedRectangle_Params params(stRectangle, ipDestImage, aColor, hrPrev);

		libraryInfo.functions[326 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FindContourHierarchyExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipContours;
			ITcVnContainer*& ipHierarchy;
			ETcVnContourRetrievalMode eRetrievalMode;
			ETcVnContourApproximationMethod eApproximationMethod;
			VN_TcVnPoint& aOffset;
			HRESULT hrPrev;
			HRESULT retVal;

			FindContourHierarchyExp_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipContours, ITcVnContainer*& ipHierarchy, ETcVnContourRetrievalMode eRetrievalMode, ETcVnContourApproximationMethod eApproximationMethod, TcVnPoint& aOffset, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipContours(ipContours), ipHierarchy(ipHierarchy), eRetrievalMode(eRetrievalMode), eApproximationMethod(eApproximationMethod), aOffset(aOffset), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Search for object contours in a binary image and determine their hierarchical relationship. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel, binary)</param>
	/// <param name="ipContours">Returns a container which is filled with the found contours (ContainerType_Vector_Vector_TcVnPoint2_DINT; The elements of this container are single contours. Non-zero interface pointers are reused.)</param>
	/// <param name="ipHierarchy">Returns a container which is filled with information on the found contours' hierarchy (ContainerType_Vector_TcVnVector4_DINT; The elements of this container are four-dimensional vectors containing the 0-based indices of the next [0] and the previous contour [1] at the same level, the first child [2], and the parent [3]. Non-zero interface pointers are reused.)</param>
	/// <param name="eRetrievalMode">Specifies which contours are retrieved and how their relationship is encoded</param>
	/// <param name="eApproximationMethod">Contour encoding</param>
	/// <param name="aOffset">Offset by which every contour point is shifted</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindContourHierarchy(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipContours, ITcVnContainer*& ipHierarchy, ETcVnContourRetrievalMode eRetrievalMode, ETcVnContourApproximationMethod eApproximationMethod, TcVnPoint& aOffset)
	{
		Internal::FindContourHierarchyExp_Params params(ipSrcImage, ipContours, ipHierarchy, eRetrievalMode, eApproximationMethod, aOffset, hrPrev);

		libraryInfo.functions[327 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnPoint FindContours_aOffsetDefault = {0, 0};

		struct FindContours_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipContours;
			ETcVnContourRetrievalMode eRetrievalMode;
			ETcVnContourApproximationMethod eApproximationMethod;
			VN_TcVnPoint& aOffset;
			HRESULT hrPrev;
			HRESULT retVal;

			FindContours_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipContours, ETcVnContourRetrievalMode eRetrievalMode, ETcVnContourApproximationMethod eApproximationMethod, TcVnPoint& aOffset, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipContours(ipContours), eRetrievalMode(eRetrievalMode), eApproximationMethod(eApproximationMethod), aOffset(aOffset), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Search for object contours in a binary image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel, binary)</param>
	/// <param name="ipContours">Returns a container which is filled with the found contours (ContainerType_Vector_Vector_TcVnPoint2_DINT; The elements of this container are single contours. Non-zero interface pointers are reused.)</param>
	/// <param name="eRetrievalMode">Specifies which contours are retrieved and how their relationship is encoded</param>
	/// <param name="eApproximationMethod">Contour encoding</param>
	/// <param name="aOffset">Offset by which every contour point is shifted</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindContours(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipContours, ETcVnContourRetrievalMode eRetrievalMode = CRM_EXTERNAL, ETcVnContourApproximationMethod eApproximationMethod = CAM_SIMPLE, TcVnPoint& aOffset = Internal::FindContours_aOffsetDefault)
	{
		Internal::FindContours_Params params(ipSrcImage, ipContours, eRetrievalMode, eApproximationMethod, aOffset, hrPrev);

		libraryInfo.functions[328 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FitEllipse_Params
		{
			ITcVnContainer* ipPointSet;
			TcVnRotatedRectangle& stEllipse;
			HRESULT hrPrev;
			HRESULT retVal;

			FitEllipse_Params(ITcVnContainer* ipPointSet, TcVnRotatedRectangle& stEllipse, HRESULT hrPrev) : ipPointSet(ipPointSet), stEllipse(stEllipse), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fit an ellipse in a point set.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; At least 5 reasonable points are required! The elements of this container are the individual points.)</param>
	/// <param name="stEllipse">Resulting ellipse, described by a rotated rectangle.</param>
	/// <returns>HRESULT</returns>
	static HRESULT FitEllipse(HRESULT hrPrev, ITcVnContainer* ipPointSet, TcVnRotatedRectangle& stEllipse)
	{
		Internal::FitEllipse_Params params(ipPointSet, stEllipse, hrPrev);

		libraryInfo.functions[329 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FitLine_Params
		{
			ITcVnContainer* ipPointSet;
			VN_TcVnVector4_LREAL& aFitLine;
			ETcVnDistanceType eDistanceType;
			double fParam;
			double fEpsRadius;
			double fEpsAngle;
			HRESULT hrPrev;
			HRESULT retVal;

			FitLine_Params(ITcVnContainer* ipPointSet, TcVnVector4_LREAL& aFitLine, ETcVnDistanceType eDistanceType, double fParam, double fEpsRadius, double fEpsAngle, HRESULT hrPrev) : ipPointSet(ipPointSet), aFitLine(aFitLine), eDistanceType(eDistanceType), fParam(fParam), fEpsRadius(fEpsRadius), fEpsAngle(fEpsAngle), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fit a line into a point set. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the individual points.)</param>
	/// <param name="aFitLine">Resulting line. The first and second element describe the x and y component of a vector collinear to the line. The third and fourth element describe the x and y component of a point on the line.</param>
	/// <param name="eDistanceType">Distance computation method (supported: L1, L2, L12, FAIR, WELSCH, HUBER)</param>
	/// <param name="fParam">Numerical parameter (c) for some eDistanceType (should be &gt;= 0). If 0, an optimal value is chosen internally.</param>
	/// <param name="fEpsRadius">Accuracy of the radius (distance of the line from the coordinate origin, should be &gt; 0). A smaller value means higher accuracy.</param>
	/// <param name="fEpsAngle">Accuracy of the angle (should be &gt; 0). A smaller value means higher accuracy.</param>
	/// <returns>HRESULT</returns>
	static HRESULT FitLine(HRESULT hrPrev, ITcVnContainer* ipPointSet, TcVnVector4_LREAL& aFitLine, ETcVnDistanceType eDistanceType = DT_L2, double fParam = 0, double fEpsRadius = 0.001, double fEpsAngle = 0.001)
	{
		Internal::FitLine_Params params(ipPointSet, aFitLine, eDistanceType, fParam, fEpsRadius, fEpsAngle, hrPrev);

		libraryInfo.functions[330 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FlipImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnFlipAxis eFlipAxis;
			HRESULT hrPrev;
			HRESULT retVal;

			FlipImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnFlipAxis eFlipAxis, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eFlipAxis(eFlipAxis), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Flip an image (mirror and shift back to prior coordinates).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eFlipAxis">Selects the axis around which to flip the image</param>
	/// <returns>HRESULT</returns>
	static HRESULT FlipImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnFlipAxis eFlipAxis)
	{
		Internal::FlipImage_Params params(ipSrcImage, ipDestImage, eFlipAxis, hrPrev);

		libraryInfo.functions[331 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FourierDescriptors_Params
		{
			ITcVnContainer* ipContour;
			ITcVnContainer*& ipDescriptors;
			LONG nDescriptors;
			HRESULT hrPrev;
			HRESULT retVal;

			FourierDescriptors_Params(ITcVnContainer* ipContour, ITcVnContainer*& ipDescriptors, LONG nDescriptors, HRESULT hrPrev) : ipContour(ipContour), ipDescriptors(ipDescriptors), nDescriptors(nDescriptors), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the fourier descriptors for a closed contour.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour">Closed contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_LREAL. Providing the full contour is strongly recommended, i.e. use TCVN_CAM_NONE for contour detection algorithms.)</param>
	/// <param name="ipDescriptors">Returns the fourier descriptors for ipContour (Re0, Im0, Re1, Im1, ...; ContainerType_Vector_LREAL if ipContour is of type ContainerType_Vector_TcVnPoint2_LREAL, else ContainerType_Vector_REAL.)</param>
	/// <param name="nDescriptors">Specifies how many descriptors should be returned (set to -1 to return all computed descriptors, i.e. at least as many as the number of contour points)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FourierDescriptors(HRESULT hrPrev, ITcVnContainer* ipContour, ITcVnContainer*& ipDescriptors, LONG nDescriptors)
	{
		Internal::FourierDescriptors_Params params(ipContour, ipDescriptors, nDescriptors, hrPrev);

		libraryInfo.functions[332 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FuseImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			ULONG nFirstLine;
			ULONG nNumLines;
			HRESULT hrPrev;
			HRESULT retVal;

			FuseImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ULONG nFirstLine, ULONG nNumLines, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), nFirstLine(nFirstLine), nNumLines(nNumLines), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fuse 2 images vertically (intended for line scan cameras).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">Source image 1</param>
	/// <param name="ipSrcImage2">Source image 2</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="nFirstLine">Line index in ipSrcImage1, which is the first line in ipDestImage</param>
	/// <param name="nNumLines">The number of lines that should be copied to ipDestImage, starting with nFirstLine in ipSrcImage1. Once the last line of ipSrcImage1 was copied, the remaining lines are copied from ipSrcImage2, starting at line index 0.</param>
	/// <returns>HRESULT</returns>
	static HRESULT FuseImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ULONG nFirstLine, ULONG nNumLines)
	{
		Internal::FuseImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, nFirstLine, nNumLines, hrPrev);

		libraryInfo.functions[333 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FuseImagesArray_Params
		{
			TcVnArray10_ITcVnImage& aSrcImageArray;
			ULONG nValidImages;
			ITcVnImage*& ipDestImage;
			ULONG nFirstLine;
			ULONG nNumLines;
			HRESULT hrPrev;
			HRESULT retVal;

			FuseImagesArray_Params(TcVnArray10_ITcVnImage& aSrcImageArray, ULONG nValidImages, ITcVnImage*& ipDestImage, ULONG nFirstLine, ULONG nNumLines, HRESULT hrPrev) : aSrcImageArray(aSrcImageArray), nValidImages(nValidImages), ipDestImage(ipDestImage), nFirstLine(nFirstLine), nNumLines(nNumLines), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Fuse up to 10 images vertically (intended for line scan cameras).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcImageArray">Ten-element source image array (not all elements need to be filled, nValidImages specifies the actual amount of images)</param>
	/// <param name="nValidImages">Number of valid images in aSrcImageArray</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="nFirstLine">Line index in ipSrcImage1, which is the first line in ipDestImage</param>
	/// <param name="nNumLines">The number of lines that should be copied to ipDestImage, starting with nFirstLine in aSrcImageArray[0]. Once the last line of aSrcImageArray[0] was copied, the remaining lines are copied from aSrcImageArray[1] (starting at line index 0) and so on.</param>
	/// <returns>HRESULT</returns>
	static HRESULT FuseImagesArray(HRESULT hrPrev, TcVnArray10_ITcVnImage& aSrcImageArray, ULONG nValidImages, ITcVnImage*& ipDestImage, ULONG nFirstLine, ULONG nNumLines)
	{
		Internal::FuseImagesArray_Params params(aSrcImageArray, nValidImages, ipDestImage, nFirstLine, nNumLines, hrPrev);

		libraryInfo.functions[334 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GaussianFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ULONG nFilterWidth;
			ULONG nFilterHeight;
			double fSigmaX;
			double fSigmaY;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			GaussianFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nFilterWidth, ULONG nFilterHeight, double fSigmaX, double fSigmaY, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nFilterWidth(nFilterWidth), nFilterHeight(nFilterHeight), fSigmaX(fSigmaX), fSigmaY(fSigmaY), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a Gaussian filter to smooth the image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="nFilterWidth">Filter width in pixels (1, 3, 5, 7, ...)</param>
	/// <param name="nFilterHeight">Filter height in pixels (1, 3, 5, 7, ...)</param>
	/// <param name="fSigmaX">Gaussian kernel standard deviation in X direction (&gt;= 0, automatically chosen if 0)</param>
	/// <param name="fSigmaY">Gaussian kernel standard deviation in Y direction (&gt;= 0, automatically chosen if 0)</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT GaussianFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nFilterWidth, ULONG nFilterHeight, double fSigmaX = 0, double fSigmaY = 0, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::GaussianFilter_Params params(ipSrcImage, ipDestImage, nFilterWidth, nFilterHeight, fSigmaX, fSigmaY, eBorderType, hrPrev);

		libraryInfo.functions[335 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GenerateAffineTransformationUnitMatrix2D_Params
		{
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			GenerateAffineTransformationUnitMatrix2D_Params(TcVnMatrix2x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Generate an affine transformation 2D unit matrix.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aTransformationMatrix">Resulting affine transformation unit matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT GenerateAffineTransformationUnitMatrix2D(HRESULT hrPrev, TcVnMatrix2x3_LREAL& aTransformationMatrix)
	{
		Internal::GenerateAffineTransformationUnitMatrix2D_Params params(aTransformationMatrix, hrPrev);

		libraryInfo.functions[336 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GenerateColorMap_Params
		{
			ITcVnContainer*& ipColorMap;
			ETcVnColorMap eColorMap;
			ETcVnColorMapSize eColorMapSize;
			HRESULT hrPrev;
			HRESULT retVal;

			GenerateColorMap_Params(ITcVnContainer*& ipColorMap, ETcVnColorMap eColorMap, ETcVnColorMapSize eColorMapSize, HRESULT hrPrev) : ipColorMap(ipColorMap), eColorMap(eColorMap), eColorMapSize(eColorMapSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Generates a pre-defined color map.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipColorMap">Returns the color map (ContainerType_Vector_TcVnVector3_REAL with 256 or 65536 elements)</param>
	/// <param name="eColorMap">Selects a color map (similar to GNU Octave/MATLAB types)</param>
	/// <param name="eColorMapSize">Defines how many elements the generated color map should have</param>
	/// <returns>HRESULT</returns>
	static HRESULT GenerateColorMap(HRESULT hrPrev, ITcVnContainer*& ipColorMap, ETcVnColorMap eColorMap, ETcVnColorMapSize eColorMapSize)
	{
		Internal::GenerateColorMap_Params params(ipColorMap, eColorMap, eColorMapSize, hrPrev);

		libraryInfo.functions[337 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GenerateCustomColorMap_Params
		{
			ITcVnContainer*& ipColorMap;
			ITcVnContainer* ipInitialColors;
			ETcVnColorMapSize eColorMapSize;
			HRESULT hrPrev;
			HRESULT retVal;

			GenerateCustomColorMap_Params(ITcVnContainer*& ipColorMap, ITcVnContainer* ipInitialColors, ETcVnColorMapSize eColorMapSize, HRESULT hrPrev) : ipColorMap(ipColorMap), ipInitialColors(ipInitialColors), eColorMapSize(eColorMapSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Generate a custom color map by interpolating between user defined colors (equally distributed, linear for each channel).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipColorMap">Returns the color map (ContainerType_Vector_TcVnVector3_REAL with 256 or 65536 elements)</param>
	/// <param name="ipInitialColors">User defined colors (ContainerType_Vector_TcVnVector3_REAL, at least 2 elements)</param>
	/// <param name="eColorMapSize">Defines how many elements the generated color map should have</param>
	/// <returns>HRESULT</returns>
	static HRESULT GenerateCustomColorMap(HRESULT hrPrev, ITcVnContainer*& ipColorMap, ITcVnContainer* ipInitialColors, ETcVnColorMapSize eColorMapSize)
	{
		Internal::GenerateCustomColorMap_Params params(ipColorMap, ipInitialColors, eColorMapSize, hrPrev);

		libraryInfo.functions[338 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAffineTransformation_Params
		{
			TcVnArray3_Point2_REAL& aSrcPoints;
			TcVnArray3_Point2_REAL& aDestPoints;
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAffineTransformation_Params(TcVnArray3_Point2_REAL& aSrcPoints, TcVnArray3_Point2_REAL& aDestPoints, TcVnMatrix2x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : aSrcPoints(aSrcPoints), aDestPoints(aDestPoints), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the affine transformation between three corresponding point pairs. The points mark the corners of the corresponding triangles.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcPoints">Source points</param>
	/// <param name="aDestPoints">Destination points</param>
	/// <param name="aTransformationMatrix">Resulting transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAffineTransformation(HRESULT hrPrev, TcVnArray3_Point2_REAL& aSrcPoints, TcVnArray3_Point2_REAL& aDestPoints, TcVnMatrix2x3_LREAL& aTransformationMatrix)
	{
		Internal::GetAffineTransformation_Params params(aSrcPoints, aDestPoints, aTransformationMatrix, hrPrev);

		libraryInfo.functions[339 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAffineTransformation2D_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer* ipDestPoints;
			TcVnMatrix2x3_LREAL& aAffineTransform;
			ETcVnEstimationAlgorithm eAlgorithm;
			double fReprojThreshold;
			ITcVnContainer** pipInlierMask;
			ULONG nMaxIterations;
			double fConfidence;
			ULONG nRefineIters;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAffineTransformation2D_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer* ipDestPoints, TcVnMatrix2x3_LREAL& aAffineTransform, ETcVnEstimationAlgorithm eAlgorithm, double fReprojThreshold, ITcVnContainer** pipInlierMask, ULONG nMaxIterations, double fConfidence, ULONG nRefineIters, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aAffineTransform(aAffineTransform), eAlgorithm(eAlgorithm), fReprojThreshold(fReprojThreshold), pipInlierMask(pipInlierMask), nMaxIterations(nMaxIterations), fConfidence(fConfidence), nRefineIters(nRefineIters), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Estimate the affine transformation between two planar point sets. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Container with at least 3 source points (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="ipDestPoints">Container with destination points (same number as ipSrcPoints, ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aAffineTransform">Returns the affine transformation matrix, which transforms the source points to the destination points</param>
	/// <param name="eAlgorithm">Estimation algorithm (only RANSAC and LMEDS are supported)</param>
	/// <param name="fReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier</param>
	/// <param name="pipInlierMask">Returns a mask marking the inliers (optional, set to 0 if not required; ContainerType_Vector_USINT)</param>
	/// <param name="nMaxIterations">Maximum number of iterations</param>
	/// <param name="fConfidence">Confidence (0..1)</param>
	/// <param name="nRefineIters">Maximum number of iterations of Levenberg-Marquardt algorithm to refine further the affine transform (using only inliers). Set to 0 to disable refining.</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAffineTransformation2D(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer* ipDestPoints, TcVnMatrix2x3_LREAL& aAffineTransform, ETcVnEstimationAlgorithm eAlgorithm = EA_RANSAC, double fReprojThreshold = 3, ITcVnContainer** pipInlierMask = nullptr, ULONG nMaxIterations = 2000, double fConfidence = 0.995, ULONG nRefineIters = 10)
	{
		Internal::GetAffineTransformation2D_Params params(ipSrcPoints, ipDestPoints, aAffineTransform, eAlgorithm, fReprojThreshold, pipInlierMask, nMaxIterations, fConfidence, nRefineIters, hrPrev);

		libraryInfo.functions[340 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_DINT_Params
		{
			ITcVnContainer* ipContainer;
			LONG& nElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_DINT_Params(ITcVnContainer* ipContainer, LONG& nElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), nElement(nElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the DINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with DINT elements</param>
	/// <param name="nElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, LONG& nElement, ULONGLONG nIndex)
	{
		Internal::GetAt_DINT_Params params(ipContainer, nElement, nIndex, hrPrev);

		libraryInfo.functions[341 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_INT_Params
		{
			ITcVnContainer* ipContainer;
			SHORT& nElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_INT_Params(ITcVnContainer* ipContainer, SHORT& nElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), nElement(nElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the INT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with INT elements</param>
	/// <param name="nElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, SHORT& nElement, ULONGLONG nIndex)
	{
		Internal::GetAt_INT_Params params(ipContainer, nElement, nIndex, hrPrev);

		libraryInfo.functions[342 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_ITcVnContainer_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_ITcVnContainer_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ULONGLONG nIndex, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the ITcVnContainer element at the specified index of the source container. (Alternatively use interface method .GetAt.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Container with ITcVnContainer elements</param>
	/// <param name="ipDestContainer">Returns the container at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, ULONGLONG nIndex)
	{
		Internal::GetAt_ITcVnContainer_Params params(ipSrcContainer, ipDestContainer, nIndex, hrPrev);

		libraryInfo.functions[343 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_ITcVnImage_Params
		{
			ITcVnContainer* ipContainer;
			ITcVnImage*& ipElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_ITcVnImage_Params(ITcVnContainer* ipContainer, ITcVnImage*& ipElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), ipElement(ipElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the ITcVnImage element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with ITcVnImage elements</param>
	/// <param name="ipElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, ITcVnImage*& ipElement, ULONGLONG nIndex)
	{
		Internal::GetAt_ITcVnImage_Params params(ipContainer, ipElement, nIndex, hrPrev);

		libraryInfo.functions[344 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			double& fElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_LREAL_Params(ITcVnContainer* ipContainer, double& fElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), fElement(fElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the LREAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with LREAL elements</param>
	/// <param name="fElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, double& fElement, ULONGLONG nIndex)
	{
		Internal::GetAt_LREAL_Params params(ipContainer, fElement, nIndex, hrPrev);

		libraryInfo.functions[345 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_REAL_Params
		{
			ITcVnContainer* ipContainer;
			float& fElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_REAL_Params(ITcVnContainer* ipContainer, float& fElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), fElement(fElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the REAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with REAL elements</param>
	/// <param name="fElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, float& fElement, ULONGLONG nIndex)
	{
		Internal::GetAt_REAL_Params params(ipContainer, fElement, nIndex, hrPrev);

		libraryInfo.functions[346 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_SINT_Params
		{
			ITcVnContainer* ipContainer;
			char& nElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_SINT_Params(ITcVnContainer* ipContainer, char& nElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), nElement(nElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the SINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with SINT elements</param>
	/// <param name="nElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, char& nElement, ULONGLONG nIndex)
	{
		Internal::GetAt_SINT_Params params(ipContainer, nElement, nIndex, hrPrev);

		libraryInfo.functions[347 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnDMatch_Params
		{
			ITcVnContainer* ipContainer;
			TcVnDMatch& stElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnDMatch_Params(ITcVnContainer* ipContainer, TcVnDMatch& stElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), stElement(stElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnDMatch element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnDMatch elements</param>
	/// <param name="stElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnDMatch& stElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnDMatch_Params params(ipContainer, stElement, nIndex, hrPrev);

		libraryInfo.functions[348 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnKeyPoint_Params
		{
			ITcVnContainer* ipContainer;
			TcVnKeyPoint& stElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnKeyPoint_Params(ITcVnContainer* ipContainer, TcVnKeyPoint& stElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), stElement(stElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnKeyPoint element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnKeyPoint elements</param>
	/// <param name="stElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnKeyPoint& stElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnKeyPoint_Params params(ipContainer, stElement, nIndex, hrPrev);

		libraryInfo.functions[349 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnPoint2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_DINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnPoint2_DINT_Params(ITcVnContainer* ipContainer, TcVnPoint2_DINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnPoint2_DINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnPoint2_DINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_DINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnPoint2_DINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[350 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnPoint2_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_LREAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnPoint2_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnPoint2_LREAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnPoint2_LREAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnPoint2_LREAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[351 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnPoint2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_REAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnPoint2_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_REAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnPoint2_REAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnPoint2_REAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_REAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnPoint2_REAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[352 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnPoint3_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_LREAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnPoint3_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnPoint3_LREAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnPoint3_LREAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnPoint3_LREAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[353 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnPoint3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_REAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnPoint3_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_REAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnPoint3_REAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnPoint3_REAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_REAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnPoint3_REAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[354 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnRectangle_DINT_Params
		{
			ITcVnContainer* ipContainer;
			TcVnRectangle_DINT& stElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnRectangle_DINT_Params(ITcVnContainer* ipContainer, TcVnRectangle_DINT& stElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), stElement(stElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnRectangle_DINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnRectangle_DINT elements</param>
	/// <param name="stElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnRectangle_DINT& stElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnRectangle_DINT_Params params(ipContainer, stElement, nIndex, hrPrev);

		libraryInfo.functions[355 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnRotatedRectangle_Params
		{
			ITcVnContainer* ipContainer;
			TcVnRotatedRectangle& stElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnRotatedRectangle_Params(ITcVnContainer* ipContainer, TcVnRotatedRectangle& stElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), stElement(stElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnRotatedRectangle element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnRotatedRectangle elements</param>
	/// <param name="stElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnRotatedRectangle& stElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnRotatedRectangle_Params params(ipContainer, stElement, nIndex, hrPrev);

		libraryInfo.functions[356 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_DINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector2_DINT_Params(ITcVnContainer* ipContainer, TcVnVector2_DINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector2_DINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector2_DINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_DINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector2_DINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[357 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector2_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_INT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector2_INT_Params(ITcVnContainer* ipContainer, TcVnVector2_INT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector2_INT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector2_INT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_INT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector2_INT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[358 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_REAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector2_REAL_Params(ITcVnContainer* ipContainer, TcVnVector2_REAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector2_REAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector2_REAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_REAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector2_REAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[359 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector2_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_SINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector2_SINT_Params(ITcVnContainer* ipContainer, TcVnVector2_SINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector2_SINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector2_SINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_SINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector2_SINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[360 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector2_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_UINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector2_UINT_Params(ITcVnContainer* ipContainer, TcVnVector2_UINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector2_UINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector2_UINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_UINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector2_UINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[361 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector2_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_USINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector2_USINT_Params(ITcVnContainer* ipContainer, TcVnVector2_USINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector2_USINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector2_USINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_USINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector2_USINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[362 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector3_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_INT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector3_INT_Params(ITcVnContainer* ipContainer, TcVnVector3_INT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector3_INT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector3_INT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_INT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector3_INT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[363 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_REAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector3_REAL_Params(ITcVnContainer* ipContainer, TcVnVector3_REAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector3_REAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector3_REAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_REAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector3_REAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[364 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector3_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_SINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector3_SINT_Params(ITcVnContainer* ipContainer, TcVnVector3_SINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector3_SINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector3_SINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_SINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector3_SINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[365 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector3_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_UINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector3_UINT_Params(ITcVnContainer* ipContainer, TcVnVector3_UINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector3_UINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector3_UINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_UINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector3_UINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[366 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector3_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_USINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector3_USINT_Params(ITcVnContainer* ipContainer, TcVnVector3_USINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector3_USINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector3_USINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_USINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector3_USINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[367 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector4_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_DINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector4_DINT_Params(ITcVnContainer* ipContainer, TcVnVector4_DINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector4_DINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector4_DINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_DINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector4_DINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[368 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector4_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_INT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector4_INT_Params(ITcVnContainer* ipContainer, TcVnVector4_INT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector4_INT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector4_INT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_INT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector4_INT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[369 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector4_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_LREAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector4_LREAL_Params(ITcVnContainer* ipContainer, TcVnVector4_LREAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector4_LREAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector4_LREAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_LREAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector4_LREAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[370 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector4_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_REAL& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector4_REAL_Params(ITcVnContainer* ipContainer, TcVnVector4_REAL& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector4_REAL element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector4_REAL elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_REAL& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector4_REAL_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[371 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector4_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_SINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector4_SINT_Params(ITcVnContainer* ipContainer, TcVnVector4_SINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector4_SINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector4_SINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_SINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector4_SINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[372 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector4_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_UINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector4_UINT_Params(ITcVnContainer* ipContainer, TcVnVector4_UINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector4_UINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector4_UINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_UINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector4_UINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[373 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_TcVnVector4_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_USINT& aElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_TcVnVector4_USINT_Params(ITcVnContainer* ipContainer, TcVnVector4_USINT& aElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), aElement(aElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the TcVnVector4_USINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with TcVnVector4_USINT elements</param>
	/// <param name="aElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_USINT& aElement, ULONGLONG nIndex)
	{
		Internal::GetAt_TcVnVector4_USINT_Params params(ipContainer, aElement, nIndex, hrPrev);

		libraryInfo.functions[374 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_UDINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONG& nElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_UDINT_Params(ITcVnContainer* ipContainer, ULONG& nElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), nElement(nElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the UDINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with UDINT elements</param>
	/// <param name="nElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONG& nElement, ULONGLONG nIndex)
	{
		Internal::GetAt_UDINT_Params params(ipContainer, nElement, nIndex, hrPrev);

		libraryInfo.functions[375 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_UINT_Params
		{
			ITcVnContainer* ipContainer;
			USHORT& nElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_UINT_Params(ITcVnContainer* ipContainer, USHORT& nElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), nElement(nElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the UINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with UINT elements</param>
	/// <param name="nElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, USHORT& nElement, ULONGLONG nIndex)
	{
		Internal::GetAt_UINT_Params params(ipContainer, nElement, nIndex, hrPrev);

		libraryInfo.functions[376 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_ULINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG& nElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_ULINT_Params(ITcVnContainer* ipContainer, ULONGLONG& nElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), nElement(nElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the ULINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with ULINT elements</param>
	/// <param name="nElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG& nElement, ULONGLONG nIndex)
	{
		Internal::GetAt_ULINT_Params params(ipContainer, nElement, nIndex, hrPrev);

		libraryInfo.functions[377 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetAt_USINT_Params
		{
			ITcVnContainer* ipContainer;
			unsigned char& nElement;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetAt_USINT_Params(ITcVnContainer* ipContainer, unsigned char& nElement, ULONGLONG nIndex, HRESULT hrPrev) : ipContainer(ipContainer), nElement(nElement), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the USINT element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container with USINT elements</param>
	/// <param name="nElement">Returns the element at the specified index</param>
	/// <param name="nIndex">Index of the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetAt(HRESULT hrPrev, ITcVnContainer* ipContainer, unsigned char& nElement, ULONGLONG nIndex)
	{
		Internal::GetAt_USINT_Params params(ipContainer, nElement, nIndex, hrPrev);

		libraryInfo.functions[378 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetConnectedComponent_Params
		{
			ITcVnImage* ipLabelImage;
			LONG nLabelID;
			ITcVnImage*& ipMaskImage;
			ITcVnContainer** pipContourPoints;
			HRESULT hrPrev;
			HRESULT retVal;

			GetConnectedComponent_Params(ITcVnImage* ipLabelImage, LONG nLabelID, ITcVnImage*& ipMaskImage, ITcVnContainer** pipContourPoints, HRESULT hrPrev) : ipLabelImage(ipLabelImage), nLabelID(nLabelID), ipMaskImage(ipMaskImage), pipContourPoints(pipContourPoints), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the mask image (and optionally the outer contour) of a connected component from a label image based on the label ID. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipLabelImage">Image containing labels for each pixel (1 channel DINT or UINT).</param>
	/// <param name="nLabelID">Value of the requested label</param>
	/// <param name="ipMaskImage">Returns a mask image marking the pixels that belong to the component (1 channel USINT. Mask is optional, set to 0 if not required.)</param>
	/// <param name="pipContourPoints">Returns the outer contour of the component(ContainerType_Vector_TcVnPoint2_DINT. Contour is optional, set to 0 if not required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetConnectedComponent(HRESULT hrPrev, ITcVnImage* ipLabelImage, LONG nLabelID, ITcVnImage*& ipMaskImage, ITcVnContainer** pipContourPoints = nullptr)
	{
		Internal::GetConnectedComponent_Params params(ipLabelImage, nLabelID, ipMaskImage, pipContourPoints, hrPrev);

		libraryInfo.functions[379 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetContainer_Params
		{
			ITcVnForwardIterator* ipIterator;
			ITcVnContainer*& ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			GetContainer_Params(ITcVnForwardIterator* ipIterator, ITcVnContainer*& ipContainer, HRESULT hrPrev) : ipIterator(ipIterator), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets a pointer to the current element converted into an ITcVnContainer interface and increment its reference counter (only possible for container types). (Alternatively use interface method .GetContainer.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIterator">Iterator</param>
	/// <param name="ipContainer">Returns the container interface</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetContainer(HRESULT hrPrev, ITcVnForwardIterator* ipIterator, ITcVnContainer*& ipContainer)
	{
		Internal::GetContainer_Params params(ipIterator, ipContainer, hrPrev);

		libraryInfo.functions[380 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetContainerExp_Params
		{
			ITcVnForwardIterator* ipIterator;
			ITcVnContainer*& ipContainer;
			LONG nOffset;
			HRESULT hrPrev;
			HRESULT retVal;

			GetContainerExp_Params(ITcVnForwardIterator* ipIterator, ITcVnContainer*& ipContainer, LONG nOffset, HRESULT hrPrev) : ipIterator(ipIterator), ipContainer(ipContainer), nOffset(nOffset), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets a pointer to the current element converted into an ITcVnContainer interface and increment its reference counter (only possible for container types). Additionally, an offset to increment or decrement the iterator afterwards can be provided. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIterator">Iterator</param>
	/// <param name="ipContainer">Returns the container interface</param>
	/// <param name="nOffset">Offset to increment (&gt;0) or decrement (&lt;0) the iterator afterwards</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetContainer(HRESULT hrPrev, ITcVnForwardIterator* ipIterator, ITcVnContainer*& ipContainer, LONG nOffset)
	{
		Internal::GetContainerExp_Params params(ipIterator, ipContainer, nOffset, hrPrev);

		libraryInfo.functions[381 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetForwardIterator_Params
		{
			ITcVnContainer* ipContainer;
			ITcVnForwardIterator*& ipIterator;
			HRESULT hrPrev;
			HRESULT retVal;

			GetForwardIterator_Params(ITcVnContainer* ipContainer, ITcVnForwardIterator*& ipIterator, HRESULT hrPrev) : ipContainer(ipContainer), ipIterator(ipIterator), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets a forward iterator for the container. (Alternatively use interface method .GetForwardIterator.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container</param>
	/// <param name="ipIterator">Returns the iterator interface</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetForwardIterator(HRESULT hrPrev, ITcVnContainer* ipContainer, ITcVnForwardIterator*& ipIterator)
	{
		Internal::GetForwardIterator_Params params(ipContainer, ipIterator, hrPrev);

		libraryInfo.functions[382 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetImageChannel_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			USHORT nChannelIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			GetImageChannel_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, USHORT nChannelIndex, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nChannelIndex(nChannelIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Return the specified source image channel as a single-channel image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="nChannelIndex">Index of the requested source image channel</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetImageChannel(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, USHORT nChannelIndex)
	{
		Internal::GetImageChannel_Params params(ipSrcImage, ipDestImage, nChannelIndex, hrPrev);

		libraryInfo.functions[383 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetImageHeight_Params
		{
			ITcVnImage* ipImage;
			ULONG& nHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			GetImageHeight_Params(ITcVnImage* ipImage, ULONG& nHeight, HRESULT hrPrev) : ipImage(ipImage), nHeight(nHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Return the height of an image. (Alternatively use interface method .GetHeight.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="nHeight">Return the height of ipImage</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetImageHeight(HRESULT hrPrev, ITcVnImage* ipImage, ULONG& nHeight)
	{
		Internal::GetImageHeight_Params params(ipImage, nHeight, hrPrev);

		libraryInfo.functions[384 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetImageInfo_Params
		{
			ITcVnImage* ipImage;
			TcVnImageInfo& stImageInfo;
			HRESULT hrPrev;
			HRESULT retVal;

			GetImageInfo_Params(ITcVnImage* ipImage, TcVnImageInfo& stImageInfo, HRESULT hrPrev) : ipImage(ipImage), stImageInfo(stImageInfo), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets a struct containing all common meta infos of the image. (Alternatively use interface method .GetImageInfo.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="stImageInfo">Returns a struct describing the image</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetImageInfo(HRESULT hrPrev, ITcVnImage* ipImage, TcVnImageInfo& stImageInfo)
	{
		Internal::GetImageInfo_Params params(ipImage, stImageInfo, hrPrev);

		libraryInfo.functions[385 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetImageWidth_Params
		{
			ITcVnImage* ipImage;
			ULONG& nWidth;
			HRESULT hrPrev;
			HRESULT retVal;

			GetImageWidth_Params(ITcVnImage* ipImage, ULONG& nWidth, HRESULT hrPrev) : ipImage(ipImage), nWidth(nWidth), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Return the width of an image. (Alternatively use interface method .GetWidth.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="nWidth">Return the width of ipImage</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetImageWidth(HRESULT hrPrev, ITcVnImage* ipImage, ULONG& nWidth)
	{
		Internal::GetImageWidth_Params params(ipImage, nWidth, hrPrev);

		libraryInfo.functions[386 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetLayoutInfo_Params
		{
			ITcVnImage* ipImage;
			TcVnArray33_UDINT& aLayoutInfo;
			HRESULT hrPrev;
			HRESULT retVal;

			GetLayoutInfo_Params(ITcVnImage* ipImage, TcVnArray33_UDINT& aLayoutInfo, HRESULT hrPrev) : ipImage(ipImage), aLayoutInfo(aLayoutInfo), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Return the layout information of an image
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image</param>
	/// <param name="aLayoutInfo">Contains layout information of ipImage. First entry of the aLayoutInfo is the number of dimensions of ipImage (max. 32), followed by the sizes of each dimension.</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetLayoutInfo(HRESULT hrPrev, ITcVnImage* ipImage, TcVnArray33_UDINT& aLayoutInfo)
	{
		Internal::GetLayoutInfo_Params params(ipImage, aLayoutInfo, hrPrev);

		libraryInfo.functions[387 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetNumberOfElements_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG& nNumberOfElements;
			HRESULT hrPrev;
			HRESULT retVal;

			GetNumberOfElements_Params(ITcVnContainer* ipContainer, ULONGLONG& nNumberOfElements, HRESULT hrPrev) : ipContainer(ipContainer), nNumberOfElements(nNumberOfElements), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the number of elements in the container. (Alternatively use interface method .getElementNum.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container</param>
	/// <param name="nNumberOfElements">Returns the number of elements in ipContainer</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetNumberOfElements(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG& nNumberOfElements)
	{
		Internal::GetNumberOfElements_Params params(ipContainer, nNumberOfElements, hrPrev);

		libraryInfo.functions[388 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetPerspectiveTransformation_Params
		{
			TcVnArray4_Point2_REAL& aSrcPoints;
			TcVnArray4_Point2_REAL& aDestPoints;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			GetPerspectiveTransformation_Params(TcVnArray4_Point2_REAL& aSrcPoints, TcVnArray4_Point2_REAL& aDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : aSrcPoints(aSrcPoints), aDestPoints(aDestPoints), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the perspective transformation between four corresponding point pairs. The points mark the corners of the corresponding rectangles.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcPoints">Source points</param>
	/// <param name="aDestPoints">Destination points</param>
	/// <param name="aTransformationMatrix">Resulting transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetPerspectiveTransformation(HRESULT hrPrev, TcVnArray4_Point2_REAL& aSrcPoints, TcVnArray4_Point2_REAL& aDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix)
	{
		Internal::GetPerspectiveTransformation_Params params(aSrcPoints, aDestPoints, aTransformationMatrix, hrPrev);

		libraryInfo.functions[389 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetPixel_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnVector4_LREAL& aValue;
			ULONG nX;
			ULONG nY;
			HRESULT hrPrev;
			HRESULT retVal;

			GetPixel_Params(ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aValue, ULONG nX, ULONG nY, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aValue(aValue), nX(nX), nY(nY), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets a specific pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="aValue">Returns the pixel value (Unused channels are set to 0.)</param>
	/// <param name="nX">x coordinate of the pixel</param>
	/// <param name="nY">y coordinate of the pixel</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetPixel(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aValue, ULONG nX, ULONG nY)
	{
		Internal::GetPixel_Params params(ipSrcImage, aValue, nX, nY, hrPrev);

		libraryInfo.functions[390 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetPixelFormat_Params
		{
			ITcVnImage* ipImage;
			TcVnPixelFormat& stPixelFormat;
			HRESULT hrPrev;
			HRESULT retVal;

			GetPixelFormat_Params(ITcVnImage* ipImage, TcVnPixelFormat& stPixelFormat, HRESULT hrPrev) : ipImage(ipImage), stPixelFormat(stPixelFormat), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the pixel format of an image. (Alternatively use interface method .GetPixelFormat.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <param name="stPixelFormat">Returns a struct describing the pixel format</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetPixelFormat(HRESULT hrPrev, ITcVnImage* ipImage, TcVnPixelFormat& stPixelFormat)
	{
		Internal::GetPixelFormat_Params params(ipImage, stPixelFormat, hrPrev);

		libraryInfo.functions[391 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetRandomAccessIterator_Params
		{
			ITcVnContainer* ipContainer;
			ITcVnRandomAccessIterator*& ipIterator;
			HRESULT hrPrev;
			HRESULT retVal;

			GetRandomAccessIterator_Params(ITcVnContainer* ipContainer, ITcVnRandomAccessIterator*& ipIterator, HRESULT hrPrev) : ipContainer(ipContainer), ipIterator(ipIterator), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets a random access iterator for the container. (Alternatively use interface method .GetRandomAccessIterator.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container</param>
	/// <param name="ipIterator">Returns the iterator interface</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetRandomAccessIterator(HRESULT hrPrev, ITcVnContainer* ipContainer, ITcVnRandomAccessIterator*& ipIterator)
	{
		Internal::GetRandomAccessIterator_Params params(ipContainer, ipIterator, hrPrev);

		libraryInfo.functions[392 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetRoi_Params
		{
			ITcVnImage* ipSrcImage;
			TcVnRectangle_UDINT& stRoi;
			HRESULT hrPrev;
			HRESULT retVal;

			GetRoi_Params(ITcVnImage* ipSrcImage, TcVnRectangle_UDINT& stRoi, HRESULT hrPrev) : ipSrcImage(ipSrcImage), stRoi(stRoi), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the coordinates of the region of interest (ROI) within the image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="stRoi">Returns the coordinates of the region of interest</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetRoi(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnRectangle_UDINT& stRoi)
	{
		Internal::GetRoi_Params params(ipSrcImage, stRoi, hrPrev);

		libraryInfo.functions[393 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetTimestamp_Params
		{
			ITcUnknown* ipUnknown;
			LONGLONG& nTimestamp;
			HRESULT hrPrev;
			HRESULT retVal;

			GetTimestamp_Params(ITcUnknown* ipUnknown, LONGLONG& nTimestamp, HRESULT hrPrev) : ipUnknown(ipUnknown), nTimestamp(nTimestamp), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the timestamp (actual DC time) from the last change of an object (e.g. ITcVnImage or ITcVnContainer)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipUnknown">An object implementing ITcUnknown and ITcVnTimestamp (e.g. ITcVnImage or ITcVnContainer)</param>
	/// <param name="nTimestamp">Returns the timestamp</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetTimestamp(HRESULT hrPrev, ITcUnknown* ipUnknown, LONGLONG& nTimestamp)
	{
		Internal::GetTimestamp_Params params(ipUnknown, nTimestamp, hrPrev);

		libraryInfo.functions[394 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static ULONG Histogram_nBinsDefault = 0;
		static double Histogram_fLowerBoundDefault = 0;
		static double Histogram_fUpperBoundDefault = 0;

		struct Histogram_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDestHistogram;
			ULONG& nBins;
			double& fLowerBound;
			double& fUpperBound;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			Histogram_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDestHistogram, ULONG& nBins, double& fLowerBound, double& fUpperBound, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestHistogram(ipDestHistogram), nBins(nBins), fLowerBound(fLowerBound), fUpperBound(fUpperBound), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the (multi-channel) histogram of an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestHistogram">Returns a container with a multi-channel histogram, where every channel is represented as a vector of UDINT (ContainerType_Vector_Vector_UDINT. Non-zero interface pointers are reused.)</param>
	/// <param name="nBins">Desired number of bins or 0 to keep the default for the corresponding image format (in) and default number of bins (out)</param>
	/// <param name="fLowerBound">Lower (inclusive) boundary of the 0-th histogram bin (in), or receive the default if fLowerBound AND fUpperBound are set to 0 (out)</param>
	/// <param name="fUpperBound">Upper (exclusive) boundary of the last histogram bin nBins-1 (in), or receive the default if fLowerBound AND fUpperBound are set to 0 (out)</param>
	/// <param name="ipMask">Source image mask (TCVN_ET_USINT, 1 channel. Mask is optional, set to 0 if not required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT Histogram(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDestHistogram, ULONG& nBins = Internal::Histogram_nBinsDefault, double& fLowerBound = Internal::Histogram_fLowerBoundDefault, double& fUpperBound = Internal::Histogram_fUpperBoundDefault, ITcVnImage* ipMask = nullptr)
	{
		Internal::Histogram_Params params(ipSrcImage, ipDestHistogram, nBins, fLowerBound, fUpperBound, ipMask, hrPrev);

		libraryInfo.functions[395 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct HistogramEqualization_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			SHORT nChannelIdx;
			HRESULT hrPrev;
			HRESULT retVal;

			HistogramEqualization_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, SHORT nChannelIdx, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nChannelIdx(nChannelIdx), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Equalize the histogram of a grayscale or color image, which normalizes the brightness and improves the contrast. The channel index that should be equalized has to be specified (-1 expects a RGB image, converts it to YCbCr, equalizes the Y channel and converts the image back to RGB). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="nChannelIdx">Index of the image channel that should be equalized (-1 expects a RGB image, converts it to YCbCr, equalizes the Y channel and converts the image back to RGB)</param>
	/// <returns>HRESULT</returns>
	static HRESULT HistogramEqualization(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, SHORT nChannelIdx = -1)
	{
		Internal::HistogramEqualization_Params params(ipSrcImage, ipDestImage, nChannelIdx, hrPrev);

		libraryInfo.functions[396 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct Homography_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer* ipDestPoints;
			TcVnMatrix3x3_LREAL& aPerspectiveTransform;
			ETcVnEstimationAlgorithm eAlgorithm;
			double fReprojThreshold;
			ITcVnContainer** pipInlierMask;
			ULONG nMaxIterations;
			double fConfidence;
			HRESULT hrPrev;
			HRESULT retVal;

			Homography_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer* ipDestPoints, TcVnMatrix3x3_LREAL& aPerspectiveTransform, ETcVnEstimationAlgorithm eAlgorithm, double fReprojThreshold, ITcVnContainer** pipInlierMask, ULONG nMaxIterations, double fConfidence, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aPerspectiveTransform(aPerspectiveTransform), eAlgorithm(eAlgorithm), fReprojThreshold(fReprojThreshold), pipInlierMask(pipInlierMask), nMaxIterations(nMaxIterations), fConfidence(fConfidence), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Find the homography (perspective transformation) between two planar point sets. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Container with at least 4 source points (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="ipDestPoints">Container with destination points (same number as ipSrcPoints, ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aPerspectiveTransform">Returns the perspective transformation matrix, which transforms the source points to the destination points</param>
	/// <param name="eAlgorithm">Estimation algorithm</param>
	/// <param name="fReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (only for RANSAC, RHO)</param>
	/// <param name="pipInlierMask">Returns a mask marking the inliers (optional, set to 0 if not required; ContainerType_Vector_SINT; only for RANSAC, LMEDS)</param>
	/// <param name="nMaxIterations">Maximum number of RANSAC iterations</param>
	/// <param name="fConfidence">Confidence (0..1)</param>
	/// <returns>HRESULT</returns>
	static HRESULT Homography(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer* ipDestPoints, TcVnMatrix3x3_LREAL& aPerspectiveTransform, ETcVnEstimationAlgorithm eAlgorithm = EA_DEFAULT, double fReprojThreshold = 3, ITcVnContainer** pipInlierMask = nullptr, ULONG nMaxIterations = 2000, double fConfidence = 0.995)
	{
		Internal::Homography_Params params(ipSrcPoints, ipDestPoints, aPerspectiveTransform, eAlgorithm, fReprojThreshold, pipInlierMask, nMaxIterations, fConfidence, hrPrev);

		libraryInfo.functions[397 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct HoughCircles_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipCircles;
			double fInvAccuRatio;
			double fMinDist;
			ETcVnHoughMethod eHoughMethod;
			double fParam1;
			double fParam2;
			ULONG nMinRadius;
			ULONG nMaxRadius;
			HRESULT hrPrev;
			HRESULT retVal;

			HoughCircles_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipCircles, double fInvAccuRatio, double fMinDist, ETcVnHoughMethod eHoughMethod, double fParam1, double fParam2, ULONG nMinRadius, ULONG nMaxRadius, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipCircles(ipCircles), fInvAccuRatio(fInvAccuRatio), fMinDist(fMinDist), eHoughMethod(eHoughMethod), fParam1(fParam1), fParam2(fParam2), nMinRadius(nMinRadius), nMaxRadius(nMaxRadius), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Search for circles using the Hough transform. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, gray-level)</param>
	/// <param name="ipCircles">Returns a container which is filled with the found circles (ContainerType_Vector_TcVnVector3_REAL; Each container element contains the x coordinate of the circle center [0], the y coordinate of the circle center [1], and the radius [2], respectively. Non-zero interface pointers are reused.)</param>
	/// <param name="fInvAccuRatio">Inverted ratio of the accumulator size in relation to the source image's size (must be &gt; 0. A value of 2 means that the size is halved in both directions.)</param>
	/// <param name="fMinDist">Smallest allowed distance of two circles (must be &gt; 0)</param>
	/// <param name="eHoughMethod">Hough method to use (GRADIENT or GRADIENT_ALT)</param>
	/// <param name="fParam1">First method specific parameter (GRADIENT, GRADIENT_ALT: upper threshold for canny edge detection, which must be &gt; 0)</param>
	/// <param name="fParam2">Second method specific parameter (GRADIENT: accumulator threshold for detecting circle centers, which must be &gt; 0. GRADIENT_ALT: required circle perfectness, which must be &gt; 0 and &lt; 1, 1 would be a perfect circle)</param>
	/// <param name="nMinRadius">Minimum circle radius allowed</param>
	/// <param name="nMaxRadius">Maximum circle radius allowed (if 0, the value is internally set to max(image rows, image columns))</param>
	/// <returns>HRESULT</returns>
	static HRESULT HoughCircles(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipCircles, double fInvAccuRatio, double fMinDist, ETcVnHoughMethod eHoughMethod = HM_GRADIENT, double fParam1 = 100, double fParam2 = 100, ULONG nMinRadius = 0, ULONG nMaxRadius = 0)
	{
		Internal::HoughCircles_Params params(ipSrcImage, ipCircles, fInvAccuRatio, fMinDist, eHoughMethod, fParam1, fParam2, nMinRadius, nMaxRadius, hrPrev);

		libraryInfo.functions[398 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct HoughLines_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipLines;
			double fDistRes;
			double fAngleRes;
			ULONG nAccuThreshold;
			double fDistResDiv;
			double fAngleResDiv;
			HRESULT hrPrev;
			HRESULT retVal;

			HoughLines_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipLines, double fDistRes, double fAngleRes, ULONG nAccuThreshold, double fDistResDiv, double fAngleResDiv, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipLines(ipLines), fDistRes(fDistRes), fAngleRes(fAngleRes), nAccuThreshold(nAccuThreshold), fDistResDiv(fDistResDiv), fAngleResDiv(fAngleResDiv), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Search for lines using the standard Hough transform. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, binary, may be modified by the function)</param>
	/// <param name="ipLines">Returns a container which is filled with the found lines (ContainerType_Vector_TcVnVector2_REAL; Each container element contains the distance from the origin [0] in pixels and the rotation angle [1] in radians, respectively. Non-zero interface pointers are reused.)</param>
	/// <param name="fDistRes">Distance resolution of the accumulator (in pixels, must be &gt; 0)</param>
	/// <param name="fAngleRes">Angle resolution of the accumulator (in radians, must be &gt; 0)</param>
	/// <param name="nAccuThreshold">Accumulator threshold</param>
	/// <param name="fDistResDiv">Divisor of the distance resolution for the multi-scale Hough transform (&gt;= 0, must be &gt; 0 if fAngleResDiv is &gt; 0)</param>
	/// <param name="fAngleResDiv">Divisor of the angle resolution for the multi-scale Hough transform (&gt;= 0, must be &gt; 0 if fDistResDiv is &gt; 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT HoughLines(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipLines, double fDistRes, double fAngleRes, ULONG nAccuThreshold, double fDistResDiv = 0, double fAngleResDiv = 0)
	{
		Internal::HoughLines_Params params(ipSrcImage, ipLines, fDistRes, fAngleRes, nAccuThreshold, fDistResDiv, fAngleResDiv, hrPrev);

		libraryInfo.functions[399 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct HoughLinesP_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipLines;
			double fDistRes;
			double fAngleRes;
			ULONG nAccuThreshold;
			double fMinLineLength;
			double fMaxLineGap;
			HRESULT hrPrev;
			HRESULT retVal;

			HoughLinesP_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipLines, double fDistRes, double fAngleRes, ULONG nAccuThreshold, double fMinLineLength, double fMaxLineGap, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipLines(ipLines), fDistRes(fDistRes), fAngleRes(fAngleRes), nAccuThreshold(nAccuThreshold), fMinLineLength(fMinLineLength), fMaxLineGap(fMaxLineGap), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Search for line segments using the probabilistic Hough transform. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, binary, may be modified by the function)</param>
	/// <param name="ipLines">Returns a container which is filled with the found line segments (ContainerType_Vector_TcVnVector4_DINT; Each container element contains the two ending points. Non-zero interface pointers are reused.)</param>
	/// <param name="fDistRes">Distance resolution of the accumulator (in pixels, must be &gt; 0)</param>
	/// <param name="fAngleRes">Angle resolution of the accumulator (in radians, must be &gt; 0)</param>
	/// <param name="nAccuThreshold">Accumulator threshold</param>
	/// <param name="fMinLineLength">Minimum line length to search for</param>
	/// <param name="fMaxLineGap">Maximum gap between points on the same line</param>
	/// <returns>HRESULT</returns>
	static HRESULT HoughLinesP(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipLines, double fDistRes, double fAngleRes, ULONG nAccuThreshold, double fMinLineLength = 0, double fMaxLineGap = 0)
	{
		Internal::HoughLinesP_Params params(ipSrcImage, ipLines, fDistRes, fAngleRes, nAccuThreshold, fMinLineLength, fMaxLineGap, hrPrev);

		libraryInfo.functions[400 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct HuMomentInvariants_Params
		{
			TcVnMoments& stMoments;
			TcVnArray7_LREAL& aHuInvariants;
			HRESULT hrPrev;
			HRESULT retVal;

			HuMomentInvariants_Params(TcVnMoments& stMoments, TcVnArray7_LREAL& aHuInvariants, HRESULT hrPrev) : stMoments(stMoments), aHuInvariants(aHuInvariants), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the Hu moment invariants.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stMoments">Moments from which to compute the Hu invariants</param>
	/// <param name="aHuInvariants">Returns the Hu moment invariants</param>
	/// <returns>HRESULT</returns>
	static HRESULT HuMomentInvariants(HRESULT hrPrev, TcVnMoments& stMoments, TcVnArray7_LREAL& aHuInvariants)
	{
		Internal::HuMomentInvariants_Params params(stMoments, aHuInvariants, hrPrev);

		libraryInfo.functions[401 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ImageAbsoluteAverage_Params
		{
			ITcVnImage* ipSrcImage;
			double& fAverage;
			HRESULT hrPrev;
			HRESULT retVal;

			ImageAbsoluteAverage_Params(ITcVnImage* ipSrcImage, double& fAverage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), fAverage(fAverage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the average absolute pixel value of an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="fAverage">Returns the average absolute pixel value</param>
	/// <returns>HRESULT</returns>
	static HRESULT ImageAbsoluteAverage(HRESULT hrPrev, ITcVnImage* ipSrcImage, double& fAverage)
	{
		Internal::ImageAbsoluteAverage_Params params(ipSrcImage, fAverage, hrPrev);

		libraryInfo.functions[402 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ImageAverage_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnVector4_LREAL& aAverage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			ImageAverage_Params(ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aAverage, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aAverage(aAverage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the (channel-wise) average pixel value of an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 - 4 channels)</param>
	/// <param name="aAverage">Returns the (channel-wise) average pixel value of ipSrcImage</param>
	/// <param name="ipMask">Mask of type USINT (1 channel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ImageAverage(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aAverage, ITcVnImage* ipMask = nullptr)
	{
		Internal::ImageAverage_Params params(ipSrcImage, aAverage, ipMask, hrPrev);

		libraryInfo.functions[403 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ImageAverageStdDev_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnVector4_LREAL& aAverage;
			VN_TcVnVector4_LREAL& aStdDev;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			ImageAverageStdDev_Params(ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aAverage, TcVnVector4_LREAL& aStdDev, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aAverage(aAverage), aStdDev(aStdDev), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the (channel-wise) average pixel value and the corresponding standard deviation of an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 - 4 channels)</param>
	/// <param name="aAverage">Returns the (channel-wise) average pixel value of ipSrcImage</param>
	/// <param name="aStdDev">Returns the (channel-wise) pixel value standard deviation of ipSrcImage</param>
	/// <param name="ipMask">Mask of type USINT (1 channel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ImageAverageStdDev(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aAverage, TcVnVector4_LREAL& aStdDev, ITcVnImage* ipMask = nullptr)
	{
		Internal::ImageAverageStdDev_Params params(ipSrcImage, aAverage, aStdDev, ipMask, hrPrev);

		libraryInfo.functions[404 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ImageCenterOfMass_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnPoint2_LREAL& aCenterOfMass;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			ImageCenterOfMass_Params(ITcVnImage* ipSrcImage, TcVnPoint2_LREAL& aCenterOfMass, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aCenterOfMass(aCenterOfMass), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the center of mass of an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="aCenterOfMass">Returns the center of mass of the image</param>
	/// <param name="ipMask">Optional mask (1 channel of type USINT, same width and height as ipSrcImage)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ImageCenterOfMass(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnPoint2_LREAL& aCenterOfMass, ITcVnImage* ipMask = nullptr)
	{
		Internal::ImageCenterOfMass_Params params(ipSrcImage, aCenterOfMass, ipMask, hrPrev);

		libraryInfo.functions[405 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ImageMedian_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnVector4_LREAL& aMedian;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			ImageMedian_Params(ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aMedian, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aMedian(aMedian), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the (approximated, channel-wise) median pixel value of an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 - 4 channels)</param>
	/// <param name="aMedian">Returns the (approximated, channel-wise) median pixel value of ipSrcImage</param>
	/// <param name="ipMask">Mask of type USINT (1 channel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ImageMedian(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aMedian, ITcVnImage* ipMask = nullptr)
	{
		Internal::ImageMedian_Params params(ipSrcImage, aMedian, ipMask, hrPrev);

		libraryInfo.functions[406 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ImageMoments_Params
		{
			ITcVnImage* ipImage;
			TcVnMoments& stMoments;
			bool bBinaryImage;
			HRESULT hrPrev;
			HRESULT retVal;

			ImageMoments_Params(ITcVnImage* ipImage, TcVnMoments& stMoments, bool bBinaryImage, HRESULT hrPrev) : ipImage(ipImage), stMoments(stMoments), bBinaryImage(bBinaryImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the spatial moments, the central moments, and the central normalized moments of an image up to the third order.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image (1 channel, elements of type USINT or REAL)</param>
	/// <param name="stMoments">Returns a struct containing the moments</param>
	/// <param name="bBinaryImage">If true, all non-zero pixels are treated as ones</param>
	/// <returns>HRESULT</returns>
	static HRESULT ImageMoments(HRESULT hrPrev, ITcVnImage* ipImage, TcVnMoments& stMoments, bool bBinaryImage)
	{
		Internal::ImageMoments_Params params(ipImage, stMoments, bBinaryImage, hrPrev);

		libraryInfo.functions[407 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct IncrementIterator_Params
		{
			ITcVnForwardIterator* ipIterator;
			HRESULT hrPrev;
			HRESULT retVal;

			IncrementIterator_Params(ITcVnForwardIterator* ipIterator, HRESULT hrPrev) : ipIterator(ipIterator), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Increment the iterator. (Alternatively use interface method .Increment.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIterator">Iterator</param>
	/// <returns>HRESULT</returns>
	static HRESULT IncrementIterator(HRESULT hrPrev, ITcVnForwardIterator* ipIterator)
	{
		Internal::IncrementIterator_Params params(ipIterator, hrPrev);

		libraryInfo.functions[408 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InitMatrixStruct_Params
		{
			PVOID pSrcBuffer;
			TcVnMatrix& stDestMatrix;
			ULONG nRows;
			ULONG nCols;
			ETcVnElementType eElementType;
			HRESULT hrPrev;
			HRESULT retVal;

			InitMatrixStruct_Params(PVOID pSrcBuffer, TcVnMatrix& stDestMatrix, ULONG nRows, ULONG nCols, ETcVnElementType eElementType, HRESULT hrPrev) : pSrcBuffer(pSrcBuffer), stDestMatrix(stDestMatrix), nRows(nRows), nCols(nCols), eElementType(eElementType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Initialize a struct of the type TcVnMatrix extending a buffer with metainformation so that it can be used as a matrix.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="pSrcBuffer">Source buffer</param>
	/// <param name="stDestMatrix">Returns completed matrix struct</param>
	/// <param name="nRows">Matrix rows</param>
	/// <param name="nCols">Matrix columns</param>
	/// <param name="eElementType">Type of the matrix elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT InitMatrixStruct(HRESULT hrPrev, PVOID pSrcBuffer, TcVnMatrix& stDestMatrix, ULONG nRows, ULONG nCols, ETcVnElementType eElementType)
	{
		Internal::InitMatrixStruct_Params params(pSrcBuffer, stDestMatrix, nRows, nCols, eElementType, hrPrev);

		libraryInfo.functions[409 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_DINT_Params
		{
			LONG nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_DINT_Params(LONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type DINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, LONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_DINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[410 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_INT_Params
		{
			SHORT nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_INT_Params(SHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type INT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, SHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_INT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[411 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_ITcVnContainer_Params
		{
			ITcVnContainer* ipElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_ITcVnContainer_Params(ITcVnContainer* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element (or a range of elements) into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Single element to insert into ipContainer or container with several elements</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, ITcVnContainer* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_ITcVnContainer_Params params(ipElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[412 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_ITcVnForwardIterator_Params
		{
			ITcVnForwardIterator* ipElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_ITcVnForwardIterator_Params(ITcVnForwardIterator* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element (represented by an iterator) into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, ITcVnForwardIterator* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_ITcVnForwardIterator_Params params(ipElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[413 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_ITcVnImage_Params
		{
			ITcVnImage* ipElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_ITcVnImage_Params(ITcVnImage* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type ITcVnImage into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, ITcVnImage* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_ITcVnImage_Params params(ipElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[414 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_LREAL_Params
		{
			double fElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_LREAL_Params(double fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : fElement(fElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type LREAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, double fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_LREAL_Params params(fElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[415 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_REAL_Params
		{
			float fElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_REAL_Params(float fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : fElement(fElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type REAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, float fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_REAL_Params params(fElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[416 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_SINT_Params
		{
			char nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_SINT_Params(char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type SINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_SINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[417 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnDMatch_Params
		{
			TcVnDMatch& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnDMatch_Params(TcVnDMatch& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnDMatch into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnDMatch& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnDMatch_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[418 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnKeyPoint_Params
		{
			TcVnKeyPoint& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnKeyPoint_Params(TcVnKeyPoint& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnKeyPoint into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnKeyPoint& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnKeyPoint_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[419 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnPoint2_DINT_Params
		{
			VN_TcVnPoint2_DINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnPoint2_DINT_Params(TcVnPoint2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnPoint2_DINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnPoint2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnPoint2_DINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[420 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnPoint2_LREAL_Params
		{
			VN_TcVnPoint2_LREAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnPoint2_LREAL_Params(TcVnPoint2_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnPoint2_LREAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnPoint2_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnPoint2_LREAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[421 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnPoint2_REAL_Params
		{
			VN_TcVnPoint2_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnPoint2_REAL_Params(TcVnPoint2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnPoint2_REAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnPoint2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnPoint2_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[422 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnPoint3_LREAL_Params
		{
			VN_TcVnPoint3_LREAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnPoint3_LREAL_Params(TcVnPoint3_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnPoint3_LREAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnPoint3_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnPoint3_LREAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[423 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnPoint3_REAL_Params
		{
			VN_TcVnPoint3_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnPoint3_REAL_Params(TcVnPoint3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnPoint3_REAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnPoint3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnPoint3_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[424 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnRectangle_DINT_Params
		{
			TcVnRectangle_DINT& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnRectangle_DINT_Params(TcVnRectangle_DINT& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnRectangle_DINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnRectangle_DINT& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnRectangle_DINT_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[425 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnRotatedRectangle_Params
		{
			TcVnRotatedRectangle& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnRotatedRectangle_Params(TcVnRotatedRectangle& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnRotatedRectangle into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnRotatedRectangle& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnRotatedRectangle_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[426 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector2_DINT_Params
		{
			VN_TcVnVector2_DINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector2_DINT_Params(TcVnVector2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector2_DINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector2_DINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[427 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector2_INT_Params
		{
			VN_TcVnVector2_INT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector2_INT_Params(TcVnVector2_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector2_INT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector2_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector2_INT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[428 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector2_REAL_Params
		{
			VN_TcVnVector2_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector2_REAL_Params(TcVnVector2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector2_REAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector2_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[429 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector2_SINT_Params
		{
			VN_TcVnVector2_SINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector2_SINT_Params(TcVnVector2_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector2_SINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector2_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector2_SINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[430 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector2_UINT_Params
		{
			VN_TcVnVector2_UINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector2_UINT_Params(TcVnVector2_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector2_UINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector2_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector2_UINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[431 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector2_USINT_Params
		{
			VN_TcVnVector2_USINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector2_USINT_Params(TcVnVector2_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector2_USINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector2_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector2_USINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[432 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector3_INT_Params
		{
			VN_TcVnVector3_INT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector3_INT_Params(TcVnVector3_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector3_INT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector3_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector3_INT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[433 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector3_REAL_Params
		{
			VN_TcVnVector3_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector3_REAL_Params(TcVnVector3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector3_REAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector3_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[434 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector3_SINT_Params
		{
			VN_TcVnVector3_SINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector3_SINT_Params(TcVnVector3_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector3_SINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector3_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector3_SINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[435 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector3_UINT_Params
		{
			VN_TcVnVector3_UINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector3_UINT_Params(TcVnVector3_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector3_UINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector3_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector3_UINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[436 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector3_USINT_Params
		{
			VN_TcVnVector3_USINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector3_USINT_Params(TcVnVector3_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector3_USINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector3_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector3_USINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[437 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector4_DINT_Params
		{
			VN_TcVnVector4_DINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector4_DINT_Params(TcVnVector4_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector4_DINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector4_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector4_DINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[438 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector4_INT_Params
		{
			VN_TcVnVector4_INT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector4_INT_Params(TcVnVector4_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector4_INT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector4_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector4_INT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[439 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector4_LREAL_Params
		{
			VN_TcVnVector4_LREAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector4_LREAL_Params(TcVnVector4_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector4_LREAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector4_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector4_LREAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[440 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector4_REAL_Params
		{
			VN_TcVnVector4_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector4_REAL_Params(TcVnVector4_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector4_REAL into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector4_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector4_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[441 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector4_SINT_Params
		{
			VN_TcVnVector4_SINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector4_SINT_Params(TcVnVector4_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector4_SINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector4_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector4_SINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[442 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector4_UINT_Params
		{
			VN_TcVnVector4_UINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector4_UINT_Params(TcVnVector4_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector4_UINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector4_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector4_UINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[443 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_TcVnVector4_USINT_Params
		{
			VN_TcVnVector4_USINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_TcVnVector4_USINT_Params(TcVnVector4_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type TcVnVector4_USINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, TcVnVector4_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_TcVnVector4_USINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[444 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_UDINT_Params
		{
			ULONG nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_UDINT_Params(ULONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type UDINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, ULONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_UDINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[445 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_UINT_Params
		{
			USHORT nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_UINT_Params(USHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type UINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, USHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_UINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[446 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_ULINT_Params
		{
			ULONGLONG nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_ULINT_Params(ULONGLONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type ULINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, ULONGLONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_ULINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[447 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InsertIntoContainer_USINT_Params
		{
			unsigned char nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			InsertIntoContainer_USINT_Params(unsigned char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Insert an element of type USINT into a container before the specified position.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Single element to insert into ipContainer</param>
	/// <param name="ipContainer">Container in which to insert the element</param>
	/// <param name="nIndex">Position, before which the element will be inserted</param>
	/// <returns>HRESULT</returns>
	static HRESULT InsertIntoContainer(HRESULT hrPrev, unsigned char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::InsertIntoContainer_USINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[448 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InverseDft_Params
		{
			ITcVnImage* ipFrequencyImage;
			ITcVnImage*& ipSpatialImage;
			bool bRealOutput;
			HRESULT hrPrev;
			HRESULT retVal;

			InverseDft_Params(ITcVnImage* ipFrequencyImage, ITcVnImage*& ipSpatialImage, bool bRealOutput, HRESULT hrPrev) : ipFrequencyImage(ipFrequencyImage), ipSpatialImage(ipSpatialImage), bRealOutput(bRealOutput), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute the inverse DFT for a given frequency image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFrequencyImage">Source frequency image (elements of type REAL or LREAL, 1 (packed CCS) or 2 (Re + Im) channels)</param>
	/// <param name="ipSpatialImage">Destination image (Same type as ipFrequencyImage, but number of channels can vary depending on bRealOutput. An appropriate image will be created if required.)</param>
	/// <param name="bRealOutput">Only relevant if ipFrequencyImage has 2 channels. If true, the result image will have only 1 channel. Otherwise, the result image will have 2 separate channels (Re + Im). If ipFrequencyImage has only 1 channel, packed CCS format is assumed and the result image will always have only 1 channel.</param>
	/// <returns>HRESULT</returns>
	static HRESULT InverseDft(HRESULT hrPrev, ITcVnImage* ipFrequencyImage, ITcVnImage*& ipSpatialImage, bool bRealOutput)
	{
		Internal::InverseDft_Params params(ipFrequencyImage, ipSpatialImage, bRealOutput, hrPrev);

		libraryInfo.functions[449 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InvertAffineTransformation_Params
		{
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			TcVnMatrix2x3_LREAL& aInvertedTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			InvertAffineTransformation_Params(TcVnMatrix2x3_LREAL& aTransformationMatrix, TcVnMatrix2x3_LREAL& aInvertedTransformationMatrix, HRESULT hrPrev) : aTransformationMatrix(aTransformationMatrix), aInvertedTransformationMatrix(aInvertedTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Invert a 2D affine transformation matrix. The inverted transformation compensates the affine transformation on an image if it is used in the F_VN_WarpAffine function.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aTransformationMatrix">Source affine transformation matrix</param>
	/// <param name="aInvertedTransformationMatrix">Resulting inverted affine transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT InvertAffineTransformation(HRESULT hrPrev, TcVnMatrix2x3_LREAL& aTransformationMatrix, TcVnMatrix2x3_LREAL& aInvertedTransformationMatrix)
	{
		Internal::InvertAffineTransformation_Params params(aTransformationMatrix, aInvertedTransformationMatrix, hrPrev);

		libraryInfo.functions[450 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InvertImageColor_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fMaxValue;
			HRESULT hrPrev;
			HRESULT retVal;

			InvertImageColor_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fMaxValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fMaxValue(fMaxValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Invert the color of an image. For signed integer or negative floating point values, only the signs will be switched. If the image contains only positive floating point values, each pixel value is subtracted from the maximum available pixel value (or 1.0, whatever is higher).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="fMaxValue">Maximum pixel value (e.g. if a 16 bit image contains 12 bit values). -1 means the default values are used.</param>
	/// <returns>HRESULT</returns>
	static HRESULT InvertImageColor(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fMaxValue = -1)
	{
		Internal::InvertImageColor_Params params(ipSrcImage, ipDestImage, fMaxValue, hrPrev);

		libraryInfo.functions[451 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InvertMatrix3x3_Params
		{
			TcVnMatrix3x3_LREAL& aSrcMatrix;
			TcVnMatrix3x3_LREAL& aInvertedMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			InvertMatrix3x3_Params(TcVnMatrix3x3_LREAL& aSrcMatrix, TcVnMatrix3x3_LREAL& aInvertedMatrix, HRESULT hrPrev) : aSrcMatrix(aSrcMatrix), aInvertedMatrix(aInvertedMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Invert a 3x3 matrix.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcMatrix">Source matrix</param>
	/// <param name="aInvertedMatrix">Returns inverted matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT InvertMatrix3x3(HRESULT hrPrev, TcVnMatrix3x3_LREAL& aSrcMatrix, TcVnMatrix3x3_LREAL& aInvertedMatrix)
	{
		Internal::InvertMatrix3x3_Params params(aSrcMatrix, aInvertedMatrix, hrPrev);

		libraryInfo.functions[452 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct IteratorDistance_Params
		{
			ITcVnForwardIterator* ipIteratorFirst;
			ITcVnForwardIterator* ipIteratorLast;
			LONGLONG& nDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			IteratorDistance_Params(ITcVnForwardIterator* ipIteratorFirst, ITcVnForwardIterator* ipIteratorLast, LONGLONG& nDistance, HRESULT hrPrev) : ipIteratorFirst(ipIteratorFirst), ipIteratorLast(ipIteratorLast), nDistance(nDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the distance between 2 iterators.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIteratorFirst">First iterator</param>
	/// <param name="ipIteratorLast">Last iterator</param>
	/// <param name="nDistance">Returns the computed distance</param>
	/// <returns>HRESULT</returns>
	static HRESULT IteratorDistance(HRESULT hrPrev, ITcVnForwardIterator* ipIteratorFirst, ITcVnForwardIterator* ipIteratorLast, LONGLONG& nDistance)
	{
		Internal::IteratorDistance_Params params(ipIteratorFirst, ipIteratorLast, nDistance, hrPrev);

		libraryInfo.functions[453 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LaplacianFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnElementType eDestDepth;
			ULONG nKernelSize;
			double fScale;
			double fDelta;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			LaplacianFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, ULONG nKernelSize, double fScale, double fDelta, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eDestDepth(eDestDepth), nKernelSize(nKernelSize), fScale(fScale), fDelta(fDelta), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a Laplacian filter to an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eDestDepth">Destination image depth</param>
	/// <param name="nKernelSize">Aperture size used to compute the second-derivative filters (1, 3, 5, ..., 31)</param>
	/// <param name="fScale">Scale factor for the computed derivative values</param>
	/// <param name="fDelta">Delta value that is added to the results before storing them</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT LaplacianFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, ULONG nKernelSize = 1, double fScale = 1, double fDelta = 0, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::LaplacianFilter_Params params(ipSrcImage, ipDestImage, eDestDepth, nKernelSize, fScale, fDelta, eBorderType, hrPrev);

		libraryInfo.functions[454 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LineIntersectionPoint_Params
		{
			VN_TcVnVector4_LREAL& aLine1;
			VN_TcVnVector4_LREAL& aLine2;
			VN_TcVnPoint2_REAL& aIntersecPoint;
			HRESULT hrPrev;
			HRESULT retVal;

			LineIntersectionPoint_Params(TcVnVector4_LREAL& aLine1, TcVnVector4_LREAL& aLine2, TcVnPoint2_REAL& aIntersecPoint, HRESULT hrPrev) : aLine1(aLine1), aLine2(aLine2), aIntersecPoint(aIntersecPoint), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the intersection point between two lines (returns S_FALSE if the provided lines are parallel).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine1">First line. The first and second element describe the x and y component of a vector collinear to the line. The third and fourth element describe the x and y component of a point on the line.</param>
	/// <param name="aLine2">Second line. The first and second element describe the x and y component of a vector collinear to the line. The third and fourth element describe the x and y component of a point on the line.</param>
	/// <param name="aIntersecPoint">Returns the intersection point of aLine1 and aLine2.</param>
	/// <returns>HRESULT</returns>
	static HRESULT LineIntersectionPoint(HRESULT hrPrev, TcVnVector4_LREAL& aLine1, TcVnVector4_LREAL& aLine2, TcVnPoint2_REAL& aIntersecPoint)
	{
		Internal::LineIntersectionPoint_Params params(aLine1, aLine2, aIntersecPoint, hrPrev);

		libraryInfo.functions[455 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LineIntersectionPointAndAngle_Params
		{
			VN_TcVnVector4_LREAL& aLine1;
			VN_TcVnVector4_LREAL& aLine2;
			VN_TcVnPoint2_REAL& aIntersecPoint;
			float& fAngle;
			bool bAngleInDegrees;
			HRESULT hrPrev;
			HRESULT retVal;

			LineIntersectionPointAndAngle_Params(TcVnVector4_LREAL& aLine1, TcVnVector4_LREAL& aLine2, TcVnPoint2_REAL& aIntersecPoint, float& fAngle, bool bAngleInDegrees, HRESULT hrPrev) : aLine1(aLine1), aLine2(aLine2), aIntersecPoint(aIntersecPoint), fAngle(fAngle), bAngleInDegrees(bAngleInDegrees), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the intersection point and angle between two lines (returns S_FALSE if the provided lines are parallel).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aLine1">First line. The first and second element describe the x and y component of a vector collinear to the line. The third and fourth element describe the x and y component of a point on the line.</param>
	/// <param name="aLine2">Second line. The first and second element describe the x and y component of a vector collinear to the line. The third and fourth element describe the x and y component of a point on the line.</param>
	/// <param name="aIntersecPoint">Returns the intersection point of aLine1 and aLine2.</param>
	/// <param name="fAngle">Returns the intersection angle of aLine1 and aLine2.</param>
	/// <param name="bAngleInDegrees">If TRUE, fAngle is in degrees. If FALSE, fAngle is in radians.</param>
	/// <returns>HRESULT</returns>
	static HRESULT LineIntersectionPointAndAngle(HRESULT hrPrev, TcVnVector4_LREAL& aLine1, TcVnVector4_LREAL& aLine2, TcVnPoint2_REAL& aIntersecPoint, float& fAngle, bool bAngleInDegrees)
	{
		Internal::LineIntersectionPointAndAngle_Params params(aLine1, aLine2, aIntersecPoint, fAngle, bAngleInDegrees, hrPrev);

		libraryInfo.functions[456 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LocalMaxima_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			LocalMaxima_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Find local maxima in a gray-scale single-channel image. The found maxima are marked by a value of 1 in the destination image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT or UINT, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (Must be different from ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocalMaxima(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::LocalMaxima_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[457 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LocalMinima_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			LocalMinima_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Find local minima in a gray-scale single-channel image. The found minima are marked by a value of 1 in the destination image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT or UINT, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (Must be different from ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocalMinima(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::LocalMinima_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[458 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxContainer_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxContainer_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise maximum of two containers (same length and type).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxContainer(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::MaxContainer_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[459 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElement_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnBidirectionalIterator*& ipDestIterator;
			ULONGLONG& nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElement_Params(ITcVnContainer* ipSrcContainer, ITcVnBidirectionalIterator*& ipDestIterator, ULONGLONG& nIndex, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestIterator(ipDestIterator), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the maximum element of a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container (Arithmetic, point and vector element types are supported. For points and vectors, the euclidean norm is used.)</param>
	/// <param name="ipDestIterator">Returns an iterator to the requested element</param>
	/// <param name="nIndex">Returns the position of the requested element within the container</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElement(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnBidirectionalIterator*& ipDestIterator, ULONGLONG& nIndex)
	{
		Internal::MaxElement_Params params(ipSrcContainer, ipDestIterator, nIndex, hrPrev);

		libraryInfo.functions[460 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_DINT_Params
		{
			ITcVnContainer* ipContainer;
			LONG& nMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_DINT_Params(ITcVnContainer* ipContainer, LONG& nMax, HRESULT hrPrev) : ipContainer(ipContainer), nMax(nMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, LONG& nMax)
	{
		Internal::MaxElementElementwise_DINT_Params params(ipContainer, nMax, hrPrev);

		libraryInfo.functions[461 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_INT_Params
		{
			ITcVnContainer* ipContainer;
			SHORT& nMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_INT_Params(ITcVnContainer* ipContainer, SHORT& nMax, HRESULT hrPrev) : ipContainer(ipContainer), nMax(nMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, SHORT& nMax)
	{
		Internal::MaxElementElementwise_INT_Params params(ipContainer, nMax, hrPrev);

		libraryInfo.functions[462 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			double& fMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_LREAL_Params(ITcVnContainer* ipContainer, double& fMax, HRESULT hrPrev) : ipContainer(ipContainer), fMax(fMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="fMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, double& fMax)
	{
		Internal::MaxElementElementwise_LREAL_Params params(ipContainer, fMax, hrPrev);

		libraryInfo.functions[463 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_REAL_Params
		{
			ITcVnContainer* ipContainer;
			float& fMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_REAL_Params(ITcVnContainer* ipContainer, float& fMax, HRESULT hrPrev) : ipContainer(ipContainer), fMax(fMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="fMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, float& fMax)
	{
		Internal::MaxElementElementwise_REAL_Params params(ipContainer, fMax, hrPrev);

		libraryInfo.functions[464 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_SINT_Params
		{
			ITcVnContainer* ipContainer;
			char& nMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_SINT_Params(ITcVnContainer* ipContainer, char& nMax, HRESULT hrPrev) : ipContainer(ipContainer), nMax(nMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, char& nMax)
	{
		Internal::MaxElementElementwise_SINT_Params params(ipContainer, nMax, hrPrev);

		libraryInfo.functions[465 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnPoint2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_DINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnPoint2_DINT_Params(ITcVnContainer* ipContainer, TcVnPoint2_DINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_DINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnPoint2_DINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[466 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnPoint2_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_LREAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnPoint2_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnPoint2_LREAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[467 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnPoint2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_REAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnPoint2_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_REAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_REAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnPoint2_REAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[468 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnPoint3_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_LREAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnPoint3_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnPoint3_LREAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[469 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnPoint3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_REAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnPoint3_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_REAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_REAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnPoint3_REAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[470 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_DINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector2_DINT_Params(ITcVnContainer* ipContainer, TcVnVector2_DINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_DINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector2_DINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[471 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector2_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_INT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector2_INT_Params(ITcVnContainer* ipContainer, TcVnVector2_INT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_INT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector2_INT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[472 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_REAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector2_REAL_Params(ITcVnContainer* ipContainer, TcVnVector2_REAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_REAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector2_REAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[473 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector2_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_SINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector2_SINT_Params(ITcVnContainer* ipContainer, TcVnVector2_SINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_SINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector2_SINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[474 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector2_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_UINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector2_UINT_Params(ITcVnContainer* ipContainer, TcVnVector2_UINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_UINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector2_UINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[475 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector2_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_USINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector2_USINT_Params(ITcVnContainer* ipContainer, TcVnVector2_USINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_USINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector2_USINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[476 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector3_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_INT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector3_INT_Params(ITcVnContainer* ipContainer, TcVnVector3_INT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_INT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector3_INT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[477 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_REAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector3_REAL_Params(ITcVnContainer* ipContainer, TcVnVector3_REAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_REAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector3_REAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[478 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector3_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_SINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector3_SINT_Params(ITcVnContainer* ipContainer, TcVnVector3_SINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_SINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector3_SINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[479 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector3_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_UINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector3_UINT_Params(ITcVnContainer* ipContainer, TcVnVector3_UINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_UINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector3_UINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[480 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector3_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_USINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector3_USINT_Params(ITcVnContainer* ipContainer, TcVnVector3_USINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_USINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector3_USINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[481 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector4_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_DINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector4_DINT_Params(ITcVnContainer* ipContainer, TcVnVector4_DINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_DINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector4_DINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[482 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector4_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_INT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector4_INT_Params(ITcVnContainer* ipContainer, TcVnVector4_INT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_INT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector4_INT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[483 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector4_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_LREAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector4_LREAL_Params(ITcVnContainer* ipContainer, TcVnVector4_LREAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_LREAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector4_LREAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[484 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector4_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_REAL& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector4_REAL_Params(ITcVnContainer* ipContainer, TcVnVector4_REAL& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_REAL& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector4_REAL_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[485 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector4_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_SINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector4_SINT_Params(ITcVnContainer* ipContainer, TcVnVector4_SINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_SINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector4_SINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[486 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector4_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_UINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector4_UINT_Params(ITcVnContainer* ipContainer, TcVnVector4_UINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_UINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector4_UINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[487 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_TcVnVector4_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_USINT& aMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_TcVnVector4_USINT_Params(ITcVnContainer* ipContainer, TcVnVector4_USINT& aMax, HRESULT hrPrev) : ipContainer(ipContainer), aMax(aMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_USINT& aMax)
	{
		Internal::MaxElementElementwise_TcVnVector4_USINT_Params params(ipContainer, aMax, hrPrev);

		libraryInfo.functions[488 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_UDINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONG& nMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_UDINT_Params(ITcVnContainer* ipContainer, ULONG& nMax, HRESULT hrPrev) : ipContainer(ipContainer), nMax(nMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONG& nMax)
	{
		Internal::MaxElementElementwise_UDINT_Params params(ipContainer, nMax, hrPrev);

		libraryInfo.functions[489 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_UINT_Params
		{
			ITcVnContainer* ipContainer;
			USHORT& nMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_UINT_Params(ITcVnContainer* ipContainer, USHORT& nMax, HRESULT hrPrev) : ipContainer(ipContainer), nMax(nMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, USHORT& nMax)
	{
		Internal::MaxElementElementwise_UINT_Params params(ipContainer, nMax, hrPrev);

		libraryInfo.functions[490 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_ULINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG& nMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_ULINT_Params(ITcVnContainer* ipContainer, ULONGLONG& nMax, HRESULT hrPrev) : ipContainer(ipContainer), nMax(nMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG& nMax)
	{
		Internal::MaxElementElementwise_ULINT_Params params(ipContainer, nMax, hrPrev);

		libraryInfo.functions[491 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxElementElementwise_USINT_Params
		{
			ITcVnContainer* ipContainer;
			unsigned char& nMax;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxElementElementwise_USINT_Params(ITcVnContainer* ipContainer, unsigned char& nMax, HRESULT hrPrev) : ipContainer(ipContainer), nMax(nMax), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise maximum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMax">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, unsigned char& nMax)
	{
		Internal::MaxElementElementwise_USINT_Params params(ipContainer, nMax, hrPrev);

		libraryInfo.functions[492 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxImage_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxImage_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise maximum of two images.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxImage(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::MaxImage_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[493 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxImageExp_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxImageExp_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise maximum of two images. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask of type USINT</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxImage(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::MaxImageExp_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[494 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxImageWithScalar_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxImageWithScalar_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise maximum of image and scalar value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxImageWithScalar(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::MaxImageWithScalar_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[495 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxImageWithScalarExp_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxImageWithScalarExp_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise maximum of image and scalar value. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask of type USINT</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxImageWithScalar(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::MaxImageWithScalarExp_Params params(fScalar, ipSrcImage, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[496 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxImageWithVector_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxImageWithVector_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise maximum of image and vector (1 element for each image channel).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxImageWithVector(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::MaxImageWithVector_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[497 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxImageWithVectorExp_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxImageWithVectorExp_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise maximum of image and vector (1 element for each image channel). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask of type USINT</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxImageWithVector(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::MaxImageWithVectorExp_Params params(aVector, ipSrcImage, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[498 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MaxPixelValue_Params
		{
			ITcVnImage* ipImage;
			VN_TcVnVector4_LREAL& aMaxValue;
			VN_TcVnPoint2_DINT& aPosition;
			ITcVnImage* ipMask;
			ETcVnVectorCompareMethod eVectorCompareMethod;
			HRESULT hrPrev;
			HRESULT retVal;

			MaxPixelValue_Params(ITcVnImage* ipImage, TcVnVector4_LREAL& aMaxValue, TcVnPoint2_DINT& aPosition, ITcVnImage* ipMask, ETcVnVectorCompareMethod eVectorCompareMethod, HRESULT hrPrev) : ipImage(ipImage), aMaxValue(aMaxValue), aPosition(aPosition), ipMask(ipMask), eVectorCompareMethod(eVectorCompareMethod), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Finds the maximum pixel value in an image (1 - 4 channels supported). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image</param>
	/// <param name="aMaxValue">Returns the maximum pixel value</param>
	/// <param name="aPosition">Returns the first found position of aMaxValue (not supported for multi-channel images with ELEMENTWISE)</param>
	/// <param name="ipMask">Optional mask to specify which pixel positions are considered (USINT, set parameter to 0 if not required)</param>
	/// <param name="eVectorCompareMethod">Select a vector compare method for multi-channel images</param>
	/// <returns>HRESULT</returns>
	static HRESULT MaxPixelValue(HRESULT hrPrev, ITcVnImage* ipImage, TcVnVector4_LREAL& aMaxValue, TcVnPoint2_DINT& aPosition, ITcVnImage* ipMask = nullptr, ETcVnVectorCompareMethod eVectorCompareMethod = VCM_EUCLIDEAN)
	{
		Internal::MaxPixelValue_Params params(ipImage, aMaxValue, aPosition, ipMask, eVectorCompareMethod, hrPrev);

		libraryInfo.functions[499 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElement_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnBidirectionalIterator*& ipDestIterator;
			ULONGLONG& nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElement_Params(ITcVnContainer* ipSrcContainer, ITcVnBidirectionalIterator*& ipDestIterator, ULONGLONG& nIndex, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestIterator(ipDestIterator), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the median element of a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container (Arithmetic, point and vector element types are supported. For points and vectors, the euclidean norm is used.)</param>
	/// <param name="ipDestIterator">Returns an iterator to the requested element</param>
	/// <param name="nIndex">Returns the position of the requested element within the container</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElement(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnBidirectionalIterator*& ipDestIterator, ULONGLONG& nIndex)
	{
		Internal::MedianElement_Params params(ipSrcContainer, ipDestIterator, nIndex, hrPrev);

		libraryInfo.functions[500 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_DINT_Params
		{
			ITcVnContainer* ipContainer;
			LONG& nMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_DINT_Params(ITcVnContainer* ipContainer, LONG& nMedian, HRESULT hrPrev) : ipContainer(ipContainer), nMedian(nMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, LONG& nMedian)
	{
		Internal::MedianElementElementwise_DINT_Params params(ipContainer, nMedian, hrPrev);

		libraryInfo.functions[501 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_INT_Params
		{
			ITcVnContainer* ipContainer;
			SHORT& nMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_INT_Params(ITcVnContainer* ipContainer, SHORT& nMedian, HRESULT hrPrev) : ipContainer(ipContainer), nMedian(nMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, SHORT& nMedian)
	{
		Internal::MedianElementElementwise_INT_Params params(ipContainer, nMedian, hrPrev);

		libraryInfo.functions[502 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			double& fMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_LREAL_Params(ITcVnContainer* ipContainer, double& fMedian, HRESULT hrPrev) : ipContainer(ipContainer), fMedian(fMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="fMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, double& fMedian)
	{
		Internal::MedianElementElementwise_LREAL_Params params(ipContainer, fMedian, hrPrev);

		libraryInfo.functions[503 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_REAL_Params
		{
			ITcVnContainer* ipContainer;
			float& fMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_REAL_Params(ITcVnContainer* ipContainer, float& fMedian, HRESULT hrPrev) : ipContainer(ipContainer), fMedian(fMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="fMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, float& fMedian)
	{
		Internal::MedianElementElementwise_REAL_Params params(ipContainer, fMedian, hrPrev);

		libraryInfo.functions[504 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_SINT_Params
		{
			ITcVnContainer* ipContainer;
			char& nMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_SINT_Params(ITcVnContainer* ipContainer, char& nMedian, HRESULT hrPrev) : ipContainer(ipContainer), nMedian(nMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, char& nMedian)
	{
		Internal::MedianElementElementwise_SINT_Params params(ipContainer, nMedian, hrPrev);

		libraryInfo.functions[505 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnPoint2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_DINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnPoint2_DINT_Params(ITcVnContainer* ipContainer, TcVnPoint2_DINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_DINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnPoint2_DINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[506 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnPoint2_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_LREAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnPoint2_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnPoint2_LREAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[507 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnPoint2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_REAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnPoint2_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_REAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_REAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnPoint2_REAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[508 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnPoint3_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_LREAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnPoint3_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnPoint3_LREAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[509 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnPoint3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_REAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnPoint3_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_REAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_REAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnPoint3_REAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[510 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_DINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector2_DINT_Params(ITcVnContainer* ipContainer, TcVnVector2_DINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_DINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector2_DINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[511 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector2_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_INT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector2_INT_Params(ITcVnContainer* ipContainer, TcVnVector2_INT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_INT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector2_INT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[512 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_REAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector2_REAL_Params(ITcVnContainer* ipContainer, TcVnVector2_REAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_REAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector2_REAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[513 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector2_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_SINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector2_SINT_Params(ITcVnContainer* ipContainer, TcVnVector2_SINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_SINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector2_SINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[514 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector2_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_UINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector2_UINT_Params(ITcVnContainer* ipContainer, TcVnVector2_UINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_UINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector2_UINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[515 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector2_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_USINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector2_USINT_Params(ITcVnContainer* ipContainer, TcVnVector2_USINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_USINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector2_USINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[516 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector3_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_INT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector3_INT_Params(ITcVnContainer* ipContainer, TcVnVector3_INT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_INT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector3_INT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[517 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_REAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector3_REAL_Params(ITcVnContainer* ipContainer, TcVnVector3_REAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_REAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector3_REAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[518 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector3_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_SINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector3_SINT_Params(ITcVnContainer* ipContainer, TcVnVector3_SINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_SINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector3_SINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[519 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector3_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_UINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector3_UINT_Params(ITcVnContainer* ipContainer, TcVnVector3_UINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_UINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector3_UINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[520 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector3_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_USINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector3_USINT_Params(ITcVnContainer* ipContainer, TcVnVector3_USINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_USINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector3_USINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[521 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector4_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_DINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector4_DINT_Params(ITcVnContainer* ipContainer, TcVnVector4_DINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_DINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector4_DINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[522 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector4_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_INT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector4_INT_Params(ITcVnContainer* ipContainer, TcVnVector4_INT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_INT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector4_INT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[523 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector4_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_LREAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector4_LREAL_Params(ITcVnContainer* ipContainer, TcVnVector4_LREAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_LREAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector4_LREAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[524 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector4_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_REAL& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector4_REAL_Params(ITcVnContainer* ipContainer, TcVnVector4_REAL& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_REAL& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector4_REAL_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[525 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector4_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_SINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector4_SINT_Params(ITcVnContainer* ipContainer, TcVnVector4_SINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_SINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector4_SINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[526 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector4_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_UINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector4_UINT_Params(ITcVnContainer* ipContainer, TcVnVector4_UINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_UINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector4_UINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[527 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_TcVnVector4_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_USINT& aMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_TcVnVector4_USINT_Params(ITcVnContainer* ipContainer, TcVnVector4_USINT& aMedian, HRESULT hrPrev) : ipContainer(ipContainer), aMedian(aMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_USINT& aMedian)
	{
		Internal::MedianElementElementwise_TcVnVector4_USINT_Params params(ipContainer, aMedian, hrPrev);

		libraryInfo.functions[528 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_UDINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONG& nMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_UDINT_Params(ITcVnContainer* ipContainer, ULONG& nMedian, HRESULT hrPrev) : ipContainer(ipContainer), nMedian(nMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONG& nMedian)
	{
		Internal::MedianElementElementwise_UDINT_Params params(ipContainer, nMedian, hrPrev);

		libraryInfo.functions[529 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_UINT_Params
		{
			ITcVnContainer* ipContainer;
			USHORT& nMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_UINT_Params(ITcVnContainer* ipContainer, USHORT& nMedian, HRESULT hrPrev) : ipContainer(ipContainer), nMedian(nMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, USHORT& nMedian)
	{
		Internal::MedianElementElementwise_UINT_Params params(ipContainer, nMedian, hrPrev);

		libraryInfo.functions[530 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_ULINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG& nMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_ULINT_Params(ITcVnContainer* ipContainer, ULONGLONG& nMedian, HRESULT hrPrev) : ipContainer(ipContainer), nMedian(nMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG& nMedian)
	{
		Internal::MedianElementElementwise_ULINT_Params params(ipContainer, nMedian, hrPrev);

		libraryInfo.functions[531 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianElementElementwise_USINT_Params
		{
			ITcVnContainer* ipContainer;
			unsigned char& nMedian;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianElementElementwise_USINT_Params(ITcVnContainer* ipContainer, unsigned char& nMedian, HRESULT hrPrev) : ipContainer(ipContainer), nMedian(nMedian), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise median container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMedian">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, unsigned char& nMedian)
	{
		Internal::MedianElementElementwise_USINT_Params params(ipContainer, nMedian, hrPrev);

		libraryInfo.functions[532 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MedianFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ULONG nFilterSize;
			HRESULT hrPrev;
			HRESULT retVal;

			MedianFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nFilterSize, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nFilterSize(nFilterSize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a Median filter to an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (for nFilterSize 3 or 5: USINT, UINT, REAL. For bigger filters, only USINT is supported.</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="nFilterSize">Size (width and height) of the filter (3, 5, 7, ...)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MedianFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nFilterSize)
	{
		Internal::MedianFilter_Params params(ipSrcImage, ipDestImage, nFilterSize, hrPrev);

		libraryInfo.functions[533 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinContainer_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			MinContainer_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise minimum of two containers (same length and type).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinContainer(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::MinContainer_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[534 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElement_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnBidirectionalIterator*& ipDestIterator;
			ULONGLONG& nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElement_Params(ITcVnContainer* ipSrcContainer, ITcVnBidirectionalIterator*& ipDestIterator, ULONGLONG& nIndex, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestIterator(ipDestIterator), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the minimum element of a container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container (Arithmetic, point and vector element types are supported. For points and vectors, the euclidean norm is used.)</param>
	/// <param name="ipDestIterator">Returns an iterator to the requested element</param>
	/// <param name="nIndex">Returns the position of the requested element within the container</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElement(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnBidirectionalIterator*& ipDestIterator, ULONGLONG& nIndex)
	{
		Internal::MinElement_Params params(ipSrcContainer, ipDestIterator, nIndex, hrPrev);

		libraryInfo.functions[535 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_DINT_Params
		{
			ITcVnContainer* ipContainer;
			LONG& nMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_DINT_Params(ITcVnContainer* ipContainer, LONG& nMin, HRESULT hrPrev) : ipContainer(ipContainer), nMin(nMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, LONG& nMin)
	{
		Internal::MinElementElementwise_DINT_Params params(ipContainer, nMin, hrPrev);

		libraryInfo.functions[536 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_INT_Params
		{
			ITcVnContainer* ipContainer;
			SHORT& nMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_INT_Params(ITcVnContainer* ipContainer, SHORT& nMin, HRESULT hrPrev) : ipContainer(ipContainer), nMin(nMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, SHORT& nMin)
	{
		Internal::MinElementElementwise_INT_Params params(ipContainer, nMin, hrPrev);

		libraryInfo.functions[537 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			double& fMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_LREAL_Params(ITcVnContainer* ipContainer, double& fMin, HRESULT hrPrev) : ipContainer(ipContainer), fMin(fMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="fMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, double& fMin)
	{
		Internal::MinElementElementwise_LREAL_Params params(ipContainer, fMin, hrPrev);

		libraryInfo.functions[538 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_REAL_Params
		{
			ITcVnContainer* ipContainer;
			float& fMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_REAL_Params(ITcVnContainer* ipContainer, float& fMin, HRESULT hrPrev) : ipContainer(ipContainer), fMin(fMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="fMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, float& fMin)
	{
		Internal::MinElementElementwise_REAL_Params params(ipContainer, fMin, hrPrev);

		libraryInfo.functions[539 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_SINT_Params
		{
			ITcVnContainer* ipContainer;
			char& nMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_SINT_Params(ITcVnContainer* ipContainer, char& nMin, HRESULT hrPrev) : ipContainer(ipContainer), nMin(nMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, char& nMin)
	{
		Internal::MinElementElementwise_SINT_Params params(ipContainer, nMin, hrPrev);

		libraryInfo.functions[540 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnPoint2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_DINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnPoint2_DINT_Params(ITcVnContainer* ipContainer, TcVnPoint2_DINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_DINT& aMin)
	{
		Internal::MinElementElementwise_TcVnPoint2_DINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[541 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnPoint2_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_LREAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnPoint2_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_LREAL& aMin)
	{
		Internal::MinElementElementwise_TcVnPoint2_LREAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[542 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnPoint2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint2_REAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnPoint2_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint2_REAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint2_REAL& aMin)
	{
		Internal::MinElementElementwise_TcVnPoint2_REAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[543 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnPoint3_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_LREAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnPoint3_LREAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_LREAL& aMin)
	{
		Internal::MinElementElementwise_TcVnPoint3_LREAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[544 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnPoint3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnPoint3_REAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnPoint3_REAL_Params(ITcVnContainer* ipContainer, TcVnPoint3_REAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnPoint3_REAL& aMin)
	{
		Internal::MinElementElementwise_TcVnPoint3_REAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[545 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector2_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_DINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector2_DINT_Params(ITcVnContainer* ipContainer, TcVnVector2_DINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_DINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector2_DINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[546 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector2_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_INT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector2_INT_Params(ITcVnContainer* ipContainer, TcVnVector2_INT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_INT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector2_INT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[547 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector2_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_REAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector2_REAL_Params(ITcVnContainer* ipContainer, TcVnVector2_REAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_REAL& aMin)
	{
		Internal::MinElementElementwise_TcVnVector2_REAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[548 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector2_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_SINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector2_SINT_Params(ITcVnContainer* ipContainer, TcVnVector2_SINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_SINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector2_SINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[549 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector2_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_UINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector2_UINT_Params(ITcVnContainer* ipContainer, TcVnVector2_UINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_UINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector2_UINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[550 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector2_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector2_USINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector2_USINT_Params(ITcVnContainer* ipContainer, TcVnVector2_USINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector2_USINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector2_USINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[551 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector3_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_INT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector3_INT_Params(ITcVnContainer* ipContainer, TcVnVector3_INT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_INT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector3_INT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[552 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector3_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_REAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector3_REAL_Params(ITcVnContainer* ipContainer, TcVnVector3_REAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_REAL& aMin)
	{
		Internal::MinElementElementwise_TcVnVector3_REAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[553 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector3_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_SINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector3_SINT_Params(ITcVnContainer* ipContainer, TcVnVector3_SINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_SINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector3_SINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[554 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector3_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_UINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector3_UINT_Params(ITcVnContainer* ipContainer, TcVnVector3_UINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_UINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector3_UINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[555 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector3_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector3_USINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector3_USINT_Params(ITcVnContainer* ipContainer, TcVnVector3_USINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector3_USINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector3_USINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[556 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector4_DINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_DINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector4_DINT_Params(ITcVnContainer* ipContainer, TcVnVector4_DINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_DINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector4_DINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[557 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector4_INT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_INT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector4_INT_Params(ITcVnContainer* ipContainer, TcVnVector4_INT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_INT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector4_INT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[558 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector4_LREAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_LREAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector4_LREAL_Params(ITcVnContainer* ipContainer, TcVnVector4_LREAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_LREAL& aMin)
	{
		Internal::MinElementElementwise_TcVnVector4_LREAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[559 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector4_REAL_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_REAL& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector4_REAL_Params(ITcVnContainer* ipContainer, TcVnVector4_REAL& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_REAL& aMin)
	{
		Internal::MinElementElementwise_TcVnVector4_REAL_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[560 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector4_SINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_SINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector4_SINT_Params(ITcVnContainer* ipContainer, TcVnVector4_SINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_SINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector4_SINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[561 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector4_UINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_UINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector4_UINT_Params(ITcVnContainer* ipContainer, TcVnVector4_UINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_UINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector4_UINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[562 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_TcVnVector4_USINT_Params
		{
			ITcVnContainer* ipContainer;
			VN_TcVnVector4_USINT& aMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_TcVnVector4_USINT_Params(ITcVnContainer* ipContainer, TcVnVector4_USINT& aMin, HRESULT hrPrev) : ipContainer(ipContainer), aMin(aMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="aMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, TcVnVector4_USINT& aMin)
	{
		Internal::MinElementElementwise_TcVnVector4_USINT_Params params(ipContainer, aMin, hrPrev);

		libraryInfo.functions[563 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_UDINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONG& nMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_UDINT_Params(ITcVnContainer* ipContainer, ULONG& nMin, HRESULT hrPrev) : ipContainer(ipContainer), nMin(nMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONG& nMin)
	{
		Internal::MinElementElementwise_UDINT_Params params(ipContainer, nMin, hrPrev);

		libraryInfo.functions[564 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_UINT_Params
		{
			ITcVnContainer* ipContainer;
			USHORT& nMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_UINT_Params(ITcVnContainer* ipContainer, USHORT& nMin, HRESULT hrPrev) : ipContainer(ipContainer), nMin(nMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, USHORT& nMin)
	{
		Internal::MinElementElementwise_UINT_Params params(ipContainer, nMin, hrPrev);

		libraryInfo.functions[565 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_ULINT_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG& nMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_ULINT_Params(ITcVnContainer* ipContainer, ULONGLONG& nMin, HRESULT hrPrev) : ipContainer(ipContainer), nMin(nMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG& nMin)
	{
		Internal::MinElementElementwise_ULINT_Params params(ipContainer, nMin, hrPrev);

		libraryInfo.functions[566 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinElementElementwise_USINT_Params
		{
			ITcVnContainer* ipContainer;
			unsigned char& nMin;
			HRESULT hrPrev;
			HRESULT retVal;

			MinElementElementwise_USINT_Params(ITcVnContainer* ipContainer, unsigned char& nMin, HRESULT hrPrev) : ipContainer(ipContainer), nMin(nMin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Gets the element wise minimum container element.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Source container</param>
	/// <param name="nMin">Returns the requested element</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinElementElementwise(HRESULT hrPrev, ITcVnContainer* ipContainer, unsigned char& nMin)
	{
		Internal::MinElementElementwise_USINT_Params params(ipContainer, nMin, hrPrev);

		libraryInfo.functions[567 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinImage_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MinImage_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise minimum of two images.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinImage(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::MinImage_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[568 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinImageExp_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			MinImageExp_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise minimum of two images. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask of type USINT</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinImage(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::MinImageExp_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[569 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinImageWithScalar_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MinImageWithScalar_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise minimum of image and scalar value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinImageWithScalar(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::MinImageWithScalar_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[570 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinImageWithScalarExp_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			MinImageWithScalarExp_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise minimum of image and scalar value. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask of type USINT</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinImageWithScalar(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::MinImageWithScalarExp_Params params(fScalar, ipSrcImage, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[571 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinImageWithVector_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MinImageWithVector_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise minimum of image and vector (1 element for each image channel).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinImageWithVector(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::MinImageWithVector_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[572 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinImageWithVectorExp_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			MinImageWithVectorExp_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise minimum of image and vector (1 element for each image channel). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="ipMask">Mask of type USINT</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinImageWithVector(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMask)
	{
		Internal::MinImageWithVectorExp_Params params(aVector, ipSrcImage, ipDestImage, ipMask, hrPrev);

		libraryInfo.functions[573 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MinPixelValue_Params
		{
			ITcVnImage* ipImage;
			VN_TcVnVector4_LREAL& aMinValue;
			VN_TcVnPoint2_DINT& aPosition;
			ITcVnImage* ipMask;
			ETcVnVectorCompareMethod eVectorCompareMethod;
			HRESULT hrPrev;
			HRESULT retVal;

			MinPixelValue_Params(ITcVnImage* ipImage, TcVnVector4_LREAL& aMinValue, TcVnPoint2_DINT& aPosition, ITcVnImage* ipMask, ETcVnVectorCompareMethod eVectorCompareMethod, HRESULT hrPrev) : ipImage(ipImage), aMinValue(aMinValue), aPosition(aPosition), ipMask(ipMask), eVectorCompareMethod(eVectorCompareMethod), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Finds the minimum pixel value in an image (1 - 4 channels supported). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image</param>
	/// <param name="aMinValue">Returns the minimum pixel value</param>
	/// <param name="aPosition">Returns the first found position of aMinValue (not supported for multi-channel images with ELEMENTWISE)</param>
	/// <param name="ipMask">Optional mask to specify which pixel positions are considered (USINT, set parameter to 0 if not required)</param>
	/// <param name="eVectorCompareMethod">Select a vector compare method for multi-channel images</param>
	/// <returns>HRESULT</returns>
	static HRESULT MinPixelValue(HRESULT hrPrev, ITcVnImage* ipImage, TcVnVector4_LREAL& aMinValue, TcVnPoint2_DINT& aPosition, ITcVnImage* ipMask = nullptr, ETcVnVectorCompareMethod eVectorCompareMethod = VCM_EUCLIDEAN)
	{
		Internal::MinPixelValue_Params params(ipImage, aMinValue, aPosition, ipMask, eVectorCompareMethod, hrPrev);

		libraryInfo.functions[574 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MixImageChannels_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnContainer* ipIndicesFromTo;
			HRESULT hrPrev;
			HRESULT retVal;

			MixImageChannels_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnContainer* ipIndicesFromTo, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipIndicesFromTo(ipIndicesFromTo), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Mix image channels by copying the specified channels of the source image into the specified channels of the destination image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="ipIndicesFromTo">Index pairs (ContainerType_Vector_TcVnVector2_DINT), specifying which source channel (TcVnVector2_DINT [0]) should be copied to which destination channel (TcVnVector2_DINT [1]).</param>
	/// <returns>HRESULT</returns>
	static HRESULT MixImageChannels(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnContainer* ipIndicesFromTo)
	{
		Internal::MixImageChannels_Params params(ipSrcImage, ipDestImage, ipIndicesFromTo, hrPrev);

		libraryInfo.functions[575 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MorphologicalOperator_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnMorphologicalOperator eOperator;
			ITcVnImage* ipStructuringElement;
			HRESULT hrPrev;
			HRESULT retVal;

			MorphologicalOperator_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnMorphologicalOperator eOperator, ITcVnImage* ipStructuringElement, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eOperator(eOperator), ipStructuringElement(ipStructuringElement), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a morphological operator.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (only 1 channel supported for reconstruction operators)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eOperator">Operator type</param>
	/// <param name="ipStructuringElement">Structuring element to be applied (Typically created via F_VN_CreateStructuringElement.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MorphologicalOperator(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnMorphologicalOperator eOperator, ITcVnImage* ipStructuringElement)
	{
		Internal::MorphologicalOperator_Params params(ipSrcImage, ipDestImage, eOperator, ipStructuringElement, hrPrev);

		libraryInfo.functions[576 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyContainers_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyContainers_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise multiplication of two containers (same length and type).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyContainers(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::MultiplyContainers_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[577 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise multiplication of two images using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image</param>
	/// <param name="ipSrcImage2">Second source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::MultiplyImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[578 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyImageWithScalar_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyImageWithScalar_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Multiply each image pixel by a scalar value using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyImageWithScalar(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::MultiplyImageWithScalar_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[579 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyImageWithVector_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyImageWithVector_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Multiply each image pixel by a vector (1 element for each image channel) using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyImageWithVector(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::MultiplyImageWithVector_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[580 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyMatrices_Params
		{
			TcVnMatrix& stSrcMatrix1;
			TcVnMatrix& stSrcMatrix2;
			TcVnMatrix& stDestMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyMatrices_Params(TcVnMatrix& stSrcMatrix1, TcVnMatrix& stSrcMatrix2, TcVnMatrix& stDestMatrix, HRESULT hrPrev) : stSrcMatrix1(stSrcMatrix1), stSrcMatrix2(stSrcMatrix2), stDestMatrix(stDestMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Matrix multiplication of two matrices (A * B = C). All matrices are represented by structs holding a pointer to an array of the appropriate size.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stSrcMatrix1">First source matrix (A)</param>
	/// <param name="stSrcMatrix2">Second source matrix (B)</param>
	/// <param name="stDestMatrix">Destination matrix (C) (The destination matrix is filled by this function, but the required memory needs to be provided.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyMatrices(HRESULT hrPrev, TcVnMatrix& stSrcMatrix1, TcVnMatrix& stSrcMatrix2, TcVnMatrix& stDestMatrix)
	{
		Internal::MultiplyMatrices_Params params(stSrcMatrix1, stSrcMatrix2, stDestMatrix, hrPrev);

		libraryInfo.functions[581 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyWithContainerElements1_Params
		{
			double fValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyWithContainerElements1_Params(double fValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : fValue(fValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Multiply each container element with a value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fValue">Value</param>
	/// <param name="ipContainer">Container with 1-dimensional elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyWithContainerElements(HRESULT hrPrev, double fValue, ITcVnContainer* ipContainer)
	{
		Internal::MultiplyWithContainerElements1_Params params(fValue, ipContainer, hrPrev);

		libraryInfo.functions[582 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyWithContainerElements2_Params
		{
			VN_TcVnVector2_LREAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyWithContainerElements2_Params(TcVnVector2_LREAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Multiply each container element with a value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with 2-dimensional elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyWithContainerElements(HRESULT hrPrev, TcVnVector2_LREAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::MultiplyWithContainerElements2_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[583 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyWithContainerElements3_Params
		{
			VN_TcVnVector3_LREAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyWithContainerElements3_Params(TcVnVector3_LREAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Multiply each container element with a value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with 3-dimensional elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyWithContainerElements(HRESULT hrPrev, TcVnVector3_LREAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::MultiplyWithContainerElements3_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[584 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MultiplyWithContainerElements4_Params
		{
			VN_TcVnVector4_LREAL& aValue;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			MultiplyWithContainerElements4_Params(TcVnVector4_LREAL& aValue, ITcVnContainer* ipContainer, HRESULT hrPrev) : aValue(aValue), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Multiply each container element with a value.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aValue">Value</param>
	/// <param name="ipContainer">Container with 4-dimensional elements</param>
	/// <returns>HRESULT</returns>
	static HRESULT MultiplyWithContainerElements(HRESULT hrPrev, TcVnVector4_LREAL& aValue, ITcVnContainer* ipContainer)
	{
		Internal::MultiplyWithContainerElements4_Params params(aValue, ipContainer, hrPrev);

		libraryInfo.functions[585 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct NegateContainer_Params
		{
			ITcVnContainer* ipSrcContainer;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			NegateContainer_Params(ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer(ipSrcContainer), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise negation of a container (two's complement).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer">Source container</param>
	/// <param name="ipDestContainer">Returns the resulting container (same type as ipSrcContainer)</param>
	/// <returns>HRESULT</returns>
	static HRESULT NegateContainer(HRESULT hrPrev, ITcVnContainer* ipSrcContainer, ITcVnContainer*& ipDestContainer)
	{
		Internal::NegateContainer_Params params(ipSrcContainer, ipDestContainer, hrPrev);

		libraryInfo.functions[586 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct NonMaxSuppression_Params
		{
			ITcVnContainer* ipBoundingBoxes;
			ITcVnContainer* ipScores;
			ITcVnContainer*& ipDestIndcies;
			float fScoreThreshold;
			float fOverlapThreshold;
			ITcVnContainer* ipClassIndcies;
			float fEta;
			LONG nTopK;
			HRESULT hrPrev;
			HRESULT retVal;

			NonMaxSuppression_Params(ITcVnContainer* ipBoundingBoxes, ITcVnContainer* ipScores, ITcVnContainer*& ipDestIndcies, float fScoreThreshold, float fOverlapThreshold, ITcVnContainer* ipClassIndcies, float fEta, LONG nTopK, HRESULT hrPrev) : ipBoundingBoxes(ipBoundingBoxes), ipScores(ipScores), ipDestIndcies(ipDestIndcies), fScoreThreshold(fScoreThreshold), fOverlapThreshold(fOverlapThreshold), ipClassIndcies(ipClassIndcies), fEta(fEta), nTopK(nTopK), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Perform non-maximum suppression on given bounding boxes and corresponding scores. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipBoundingBoxes">Container of bounding boxes to apply the non maximum supresion (ContainerType_Vector_TcVnRectangle_DINT)</param>
	/// <param name="ipScores">Container of coreeponding score for each bounding box (ContainerType_Vector_REAL)</param>
	/// <param name="ipDestIndcies">Container of the kept indcies after apply the non maximum suppression (ContainerType_Vector_DINT)</param>
	/// <param name="fScoreThreshold">A threshold [0.0 to 1.0] used to filter the bounding boxes by score</param>
	/// <param name="fOverlapThreshold">A threshold [0.0 to 1.0] that determines the minimum degree of intersection over union (IoU) required for bounding boxes to be considered overlapping</param>
	/// <param name="ipClassIndcies">Container of corresponding set of class indcies (ContainerType_Vector_DINT)</param>
	/// <param name="fEta">An adjustable threshold [0.0 to 1.0] used to dynamically reduce the overlap threshold during processing. Setting it to 1 maintains a constant value for the overlap threshold</param>
	/// <param name="nTopK">The maximum number of bounding boxes with the highest scores to undergo the suppression algorithm (must be &gt;= 0). Setting it to zero applies the algorithm to all bounding boxes</param>
	/// <returns>HRESULT</returns>
	static HRESULT NonMaxSuppression(HRESULT hrPrev, ITcVnContainer* ipBoundingBoxes, ITcVnContainer* ipScores, ITcVnContainer*& ipDestIndcies, float fScoreThreshold, float fOverlapThreshold, ITcVnContainer* ipClassIndcies = nullptr, float fEta = 1.0f, LONG nTopK = 0)
	{
		Internal::NonMaxSuppression_Params params(ipBoundingBoxes, ipScores, ipDestIndcies, fScoreThreshold, fOverlapThreshold, ipClassIndcies, fEta, nTopK, hrPrev);

		libraryInfo.functions[587 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct NormalizeImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fAlpha;
			double fBeta;
			ETcVnNormalizationType eNormType;
			ETcVnElementType eDestType;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			NormalizeImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fAlpha, double fBeta, ETcVnNormalizationType eNormType, ETcVnElementType eDestType, ITcVnImage* ipMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fAlpha(fAlpha), fBeta(fBeta), eNormType(eNormType), eDestType(eDestType), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Normalize an image regarding its value range (e.g. stretch pixel values [50..150] to full range [0..255]) or scale the values regarding a specific normalization (e.g. L2-norm). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fAlpha">Lower range boundary (in case of normalizing the value range) or value to normalize to (||ipDestImage|| = fAlpha)</param>
	/// <param name="fBeta">Upper range boundary (in case of normalizing the value range)</param>
	/// <param name="eNormType">Normalization type (only INF, L1, L2 or MINMAX)</param>
	/// <param name="eDestType">Destination image depth (usually SAME_AS_SOURCE)</param>
	/// <param name="ipMask">Mask to restrict the normalization to specific pixel positions (set 0 to normalize the whole image)</param>
	/// <returns>HRESULT</returns>
	static HRESULT NormalizeImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fAlpha = 0, double fBeta = 255, ETcVnNormalizationType eNormType = NT_MINMAX, ETcVnElementType eDestType = TCVN_ET_SAME_AS_SOURCE, ITcVnImage* ipMask = nullptr)
	{
		Internal::NormalizeImage_Params params(ipSrcImage, ipDestImage, fAlpha, fBeta, eNormType, eDestType, ipMask, hrPrev);

		libraryInfo.functions[588 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct NormalizeImageForDisplay_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnSignedNormalization eSignedNormalization;
			HRESULT hrPrev;
			HRESULT retVal;

			NormalizeImageForDisplay_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnSignedNormalization eSignedNormalization, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eSignedNormalization(eSignedNormalization), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Normalize an image for display, i.e. scale it to the full value range of the underlying data type (-1 to 1 for floating point).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eSignedNormalization">Option for normalizing signed values</param>
	/// <returns>HRESULT</returns>
	static HRESULT NormalizeImageForDisplay(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnSignedNormalization eSignedNormalization)
	{
		Internal::NormalizeImageForDisplay_Params params(ipSrcImage, ipDestImage, eSignedNormalization, hrPrev);

		libraryInfo.functions[589 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct OptimalDftSize_Params
		{
			ITcVnImage* ipImage;
			ULONG& nOptWidth;
			ULONG& nOptHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			OptimalDftSize_Params(ITcVnImage* ipImage, ULONG& nOptWidth, ULONG& nOptHeight, HRESULT hrPrev) : ipImage(ipImage), nOptWidth(nOptWidth), nOptHeight(nOptHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the optimal image size for applying a dft (can lead to better performance).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image for which to compute the optimal width and height</param>
	/// <param name="nOptWidth">Returns the optimal width of the image</param>
	/// <param name="nOptHeight">Returns the optimal height of the image</param>
	/// <returns>HRESULT</returns>
	static HRESULT OptimalDftSize(HRESULT hrPrev, ITcVnImage* ipImage, ULONG& nOptWidth, ULONG& nOptHeight)
	{
		Internal::OptimalDftSize_Params params(ipImage, nOptWidth, nOptHeight, hrPrev);

		libraryInfo.functions[590 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct OrthogonalVector_TcVnVector2_DINT_Params
		{
			VN_TcVnVector2_DINT& aSrc;
			VN_TcVnVector2_LREAL& aOrthogonal;
			bool bNormalize;
			HRESULT hrPrev;
			HRESULT retVal;

			OrthogonalVector_TcVnVector2_DINT_Params(TcVnVector2_DINT& aSrc, TcVnVector2_LREAL& aOrthogonal, bool bNormalize, HRESULT hrPrev) : aSrc(aSrc), aOrthogonal(aOrthogonal), bNormalize(bNormalize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes an orthogonal vector to a given source vector.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrc">Source vector</param>
	/// <param name="aOrthogonal">Returns a vector orthogonal to aSrc</param>
	/// <param name="bNormalize">If true, aOrthogonal length is normalized to 1, otherwise aOrthogonal has the same length as aSrc</param>
	/// <returns>HRESULT</returns>
	static HRESULT OrthogonalVector(HRESULT hrPrev, TcVnVector2_DINT& aSrc, TcVnVector2_LREAL& aOrthogonal, bool bNormalize)
	{
		Internal::OrthogonalVector_TcVnVector2_DINT_Params params(aSrc, aOrthogonal, bNormalize, hrPrev);

		libraryInfo.functions[591 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct OrthogonalVector_TcVnVector2_LREAL_Params
		{
			VN_TcVnVector2_LREAL& aSrc;
			VN_TcVnVector2_LREAL& aOrthogonal;
			bool bNormalize;
			HRESULT hrPrev;
			HRESULT retVal;

			OrthogonalVector_TcVnVector2_LREAL_Params(TcVnVector2_LREAL& aSrc, TcVnVector2_LREAL& aOrthogonal, bool bNormalize, HRESULT hrPrev) : aSrc(aSrc), aOrthogonal(aOrthogonal), bNormalize(bNormalize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes an orthogonal vector to a given source vector.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrc">Source vector</param>
	/// <param name="aOrthogonal">Returns a vector orthogonal to aSrc</param>
	/// <param name="bNormalize">If true, aOrthogonal length is normalized to 1, otherwise aOrthogonal has the same length as aSrc</param>
	/// <returns>HRESULT</returns>
	static HRESULT OrthogonalVector(HRESULT hrPrev, TcVnVector2_LREAL& aSrc, TcVnVector2_LREAL& aOrthogonal, bool bNormalize)
	{
		Internal::OrthogonalVector_TcVnVector2_LREAL_Params params(aSrc, aOrthogonal, bNormalize, hrPrev);

		libraryInfo.functions[592 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct OrthogonalVector_TcVnVector2_REAL_Params
		{
			VN_TcVnVector2_REAL& aSrc;
			VN_TcVnVector2_REAL& aOrthogonal;
			bool bNormalize;
			HRESULT hrPrev;
			HRESULT retVal;

			OrthogonalVector_TcVnVector2_REAL_Params(TcVnVector2_REAL& aSrc, TcVnVector2_REAL& aOrthogonal, bool bNormalize, HRESULT hrPrev) : aSrc(aSrc), aOrthogonal(aOrthogonal), bNormalize(bNormalize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes an orthogonal vector to a given source vector.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrc">Source vector</param>
	/// <param name="aOrthogonal">Returns a vector orthogonal to aSrc</param>
	/// <param name="bNormalize">If true, aOrthogonal length is normalized to 1, otherwise aOrthogonal has the same length as aSrc</param>
	/// <returns>HRESULT</returns>
	static HRESULT OrthogonalVector(HRESULT hrPrev, TcVnVector2_REAL& aSrc, TcVnVector2_REAL& aOrthogonal, bool bNormalize)
	{
		Internal::OrthogonalVector_TcVnVector2_REAL_Params params(aSrc, aOrthogonal, bNormalize, hrPrev);

		libraryInfo.functions[593 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL PadImageBorder_aPaddingValueDefault = {0, 0, 0, 0};

		struct PadImageBorder_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipPaddedImage;
			ULONG nTopBorder;
			ULONG nBottomBorder;
			ULONG nLeftBorder;
			ULONG nRightBorder;
			ETcVnBorderInterpolationMethod ePaddingType;
			VN_TcVnVector4_LREAL& aPaddingValue;
			HRESULT hrPrev;
			HRESULT retVal;

			PadImageBorder_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipPaddedImage, ULONG nTopBorder, ULONG nBottomBorder, ULONG nLeftBorder, ULONG nRightBorder, ETcVnBorderInterpolationMethod ePaddingType, TcVnVector4_LREAL& aPaddingValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipPaddedImage(ipPaddedImage), nTopBorder(nTopBorder), nBottomBorder(nBottomBorder), nLeftBorder(nLeftBorder), nRightBorder(nRightBorder), ePaddingType(ePaddingType), aPaddingValue(aPaddingValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Add padding around the original image borders. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipPaddedImage">Padded destination image (Same type as ipSrcImage, an appropriate destination image will be created if required.)</param>
	/// <param name="nTopBorder">Padding height in pixels above top border</param>
	/// <param name="nBottomBorder">Padding height in pixels below bottom border</param>
	/// <param name="nLeftBorder">Padding width in pixels before left border</param>
	/// <param name="nRightBorder">Padding width in pixels after right border</param>
	/// <param name="ePaddingType">Specifies how the pixel values of the padding area are determined</param>
	/// <param name="aPaddingValue">Specifies the padding value if CONSTANT is used</param>
	/// <returns>HRESULT</returns>
	static HRESULT PadImageBorder(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipPaddedImage, ULONG nTopBorder, ULONG nBottomBorder, ULONG nLeftBorder, ULONG nRightBorder, ETcVnBorderInterpolationMethod ePaddingType = BIM_CONSTANT, TcVnVector4_LREAL& aPaddingValue = Internal::PadImageBorder_aPaddingValueDefault)
	{
		Internal::PadImageBorder_Params params(ipSrcImage, ipPaddedImage, nTopBorder, nBottomBorder, nLeftBorder, nRightBorder, ePaddingType, aPaddingValue, hrPrev);

		libraryInfo.functions[594 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PerspectiveTransformation_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			HRESULT hrPrev;
			HRESULT retVal;

			PerspectiveTransformation_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a perspective transformation (rotation + translation, e.g. from extrinsic calibration) to 3D point coordinates.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Container with 3D source points (TcVnPoint3_REAL or TcVnPoint3_LREAL)</param>
	/// <param name="ipDestPoints">Returns the transformed points (same type as ipSrcPoints)</param>
	/// <param name="aRotationMatrix">3x3 rotation matrix</param>
	/// <param name="aTranslationVector">Translation vector</param>
	/// <returns>HRESULT</returns>
	static HRESULT PerspectiveTransformation(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector)
	{
		Internal::PerspectiveTransformation_Params params(ipSrcPoints, ipDestPoints, aRotationMatrix, aTranslationVector, hrPrev);

		libraryInfo.functions[595 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL PlotIntensityProfile_aBackgroundColorDefault = {0, 0, 0, 0};
		static TcVnVector4_LREAL PlotIntensityProfile_aLineColorDefault = {255, 255, 255, 255};
		static TcVnVector4_LREAL PlotIntensityProfile_aGridColorDefault = {64, 64, 64, 64};

		struct PlotIntensityProfile_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			VN_TcVnVector4_LREAL& aBackgroundColor;
			VN_TcVnVector4_LREAL& aLineColor;
			VN_TcVnVector4_LREAL& aGridColor;
			LONG nScaleX;
			LONG nScaleY;
			LONG nThickness;
			LONG nDestChannels;
			HRESULT hrPrev;
			HRESULT retVal;

			PlotIntensityProfile_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, TcVnVector4_LREAL& aBackgroundColor, TcVnVector4_LREAL& aLineColor, TcVnVector4_LREAL& aGridColor, LONG nScaleX, LONG nScaleY, LONG nThickness, LONG nDestChannels, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aStartPoint(aStartPoint), aEndPoint(aEndPoint), aBackgroundColor(aBackgroundColor), aLineColor(aLineColor), aGridColor(aGridColor), nScaleX(nScaleX), nScaleY(nScaleY), nThickness(nThickness), nDestChannels(nDestChannels), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Plots the pixel intensity profile along a line segment in an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (USINT, 1 channel. x: position, y: intensity, origin: bottom left. An appropriate destination image will be created if required.)</param>
	/// <param name="aStartPoint">Start point of the line segment</param>
	/// <param name="aEndPoint">End point of the line segment</param>
	/// <param name="aBackgroundColor">Background color</param>
	/// <param name="aLineColor">Line color</param>
	/// <param name="aGridColor">Grid color</param>
	/// <param name="nScaleX">Scale in x direction (ipDestImage will have a width of nScaleX * (ipSrcImage width - 1) + 1)</param>
	/// <param name="nScaleY">Scale in y direction (ipDestImage will have a height of nScaleY * 255 + 1)</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="nDestChannels">ipDestImage channels (1 or 3)</param>
	/// <returns>HRESULT</returns>
	static HRESULT PlotIntensityProfile(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, TcVnVector4_LREAL& aBackgroundColor = Internal::PlotIntensityProfile_aBackgroundColorDefault, TcVnVector4_LREAL& aLineColor = Internal::PlotIntensityProfile_aLineColorDefault, TcVnVector4_LREAL& aGridColor = Internal::PlotIntensityProfile_aGridColorDefault, LONG nScaleX = 2, LONG nScaleY = 2, LONG nThickness = 1, LONG nDestChannels = 1)
	{
		Internal::PlotIntensityProfile_Params params(ipSrcImage, ipDestImage, aStartPoint, aEndPoint, aBackgroundColor, aLineColor, aGridColor, nScaleX, nScaleY, nThickness, nDestChannels, hrPrev);

		libraryInfo.functions[596 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToLineDistance_TcVnPoint2_DINT_Params
		{
			VN_TcVnPoint2_DINT& aPoint;
			VN_TcVnPoint2_DINT& aLinePoint1;
			VN_TcVnPoint2_DINT& aLinePoint2;
			double& fDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToLineDistance_TcVnPoint2_DINT_Params(TcVnPoint2_DINT& aPoint, TcVnPoint2_DINT& aLinePoint1, TcVnPoint2_DINT& aLinePoint2, double& fDistance, HRESULT hrPrev) : aPoint(aPoint), aLinePoint1(aLinePoint1), aLinePoint2(aLinePoint2), fDistance(fDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the shortest distance between a point and a line.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint">Point</param>
	/// <param name="aLinePoint1">Line Point 1</param>
	/// <param name="aLinePoint2">Line Point 2</param>
	/// <param name="fDistance">Returns the distance between the point and the line</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToLineDistance(HRESULT hrPrev, TcVnPoint2_DINT& aPoint, TcVnPoint2_DINT& aLinePoint1, TcVnPoint2_DINT& aLinePoint2, double& fDistance)
	{
		Internal::PointToLineDistance_TcVnPoint2_DINT_Params params(aPoint, aLinePoint1, aLinePoint2, fDistance, hrPrev);

		libraryInfo.functions[597 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToLineDistance_TcVnPoint2_LREAL_Params
		{
			VN_TcVnPoint2_LREAL& aPoint;
			VN_TcVnPoint2_LREAL& aLinePoint1;
			VN_TcVnPoint2_LREAL& aLinePoint2;
			double& fDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToLineDistance_TcVnPoint2_LREAL_Params(TcVnPoint2_LREAL& aPoint, TcVnPoint2_LREAL& aLinePoint1, TcVnPoint2_LREAL& aLinePoint2, double& fDistance, HRESULT hrPrev) : aPoint(aPoint), aLinePoint1(aLinePoint1), aLinePoint2(aLinePoint2), fDistance(fDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the shortest distance between a point and a line.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint">Point</param>
	/// <param name="aLinePoint1">Line Point 1</param>
	/// <param name="aLinePoint2">Line Point 2</param>
	/// <param name="fDistance">Returns the distance between the point and the line</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToLineDistance(HRESULT hrPrev, TcVnPoint2_LREAL& aPoint, TcVnPoint2_LREAL& aLinePoint1, TcVnPoint2_LREAL& aLinePoint2, double& fDistance)
	{
		Internal::PointToLineDistance_TcVnPoint2_LREAL_Params params(aPoint, aLinePoint1, aLinePoint2, fDistance, hrPrev);

		libraryInfo.functions[598 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToLineDistance_TcVnPoint2_REAL_Params
		{
			VN_TcVnPoint2_REAL& aPoint;
			VN_TcVnPoint2_REAL& aLinePoint1;
			VN_TcVnPoint2_REAL& aLinePoint2;
			double& fDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToLineDistance_TcVnPoint2_REAL_Params(TcVnPoint2_REAL& aPoint, TcVnPoint2_REAL& aLinePoint1, TcVnPoint2_REAL& aLinePoint2, double& fDistance, HRESULT hrPrev) : aPoint(aPoint), aLinePoint1(aLinePoint1), aLinePoint2(aLinePoint2), fDistance(fDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the shortest distance between a point and a line.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint">Point</param>
	/// <param name="aLinePoint1">Line Point 1</param>
	/// <param name="aLinePoint2">Line Point 2</param>
	/// <param name="fDistance">Returns the distance between the point and the line</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToLineDistance(HRESULT hrPrev, TcVnPoint2_REAL& aPoint, TcVnPoint2_REAL& aLinePoint1, TcVnPoint2_REAL& aLinePoint2, double& fDistance)
	{
		Internal::PointToLineDistance_TcVnPoint2_REAL_Params params(aPoint, aLinePoint1, aLinePoint2, fDistance, hrPrev);

		libraryInfo.functions[599 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToPointDirection_TcVnPoint2_DINT_Params
		{
			VN_TcVnPoint2_DINT& aPoint1;
			VN_TcVnPoint2_DINT& aPoint2;
			VN_TcVnVector2_LREAL& aDirection;
			bool bNormalize;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToPointDirection_TcVnPoint2_DINT_Params(TcVnPoint2_DINT& aPoint1, TcVnPoint2_DINT& aPoint2, TcVnVector2_LREAL& aDirection, bool bNormalize, HRESULT hrPrev) : aPoint1(aPoint1), aPoint2(aPoint2), aDirection(aDirection), bNormalize(bNormalize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the direction vector between 2 points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint1">Point 1</param>
	/// <param name="aPoint2">Point 2</param>
	/// <param name="aDirection">Returns the direction vector from aPoint1 to aPoint2</param>
	/// <param name="bNormalize">If true, aDirection length is normalized to 1, otherwise aDirection length is the distance between aPoint1 and aPoint2</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToPointDirection(HRESULT hrPrev, TcVnPoint2_DINT& aPoint1, TcVnPoint2_DINT& aPoint2, TcVnVector2_LREAL& aDirection, bool bNormalize)
	{
		Internal::PointToPointDirection_TcVnPoint2_DINT_Params params(aPoint1, aPoint2, aDirection, bNormalize, hrPrev);

		libraryInfo.functions[600 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToPointDirection_TcVnPoint2_LREAL_Params
		{
			VN_TcVnPoint2_LREAL& aPoint1;
			VN_TcVnPoint2_LREAL& aPoint2;
			VN_TcVnVector2_LREAL& aDirection;
			bool bNormalize;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToPointDirection_TcVnPoint2_LREAL_Params(TcVnPoint2_LREAL& aPoint1, TcVnPoint2_LREAL& aPoint2, TcVnVector2_LREAL& aDirection, bool bNormalize, HRESULT hrPrev) : aPoint1(aPoint1), aPoint2(aPoint2), aDirection(aDirection), bNormalize(bNormalize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the direction vector between 2 points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint1">Point 1</param>
	/// <param name="aPoint2">Point 2</param>
	/// <param name="aDirection">Returns the direction vector from aPoint1 to aPoint2</param>
	/// <param name="bNormalize">If true, aDirection length is normalized to 1, otherwise aDirection length is the distance between aPoint1 and aPoint2</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToPointDirection(HRESULT hrPrev, TcVnPoint2_LREAL& aPoint1, TcVnPoint2_LREAL& aPoint2, TcVnVector2_LREAL& aDirection, bool bNormalize)
	{
		Internal::PointToPointDirection_TcVnPoint2_LREAL_Params params(aPoint1, aPoint2, aDirection, bNormalize, hrPrev);

		libraryInfo.functions[601 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToPointDirection_TcVnPoint2_REAL_Params
		{
			VN_TcVnPoint2_REAL& aPoint1;
			VN_TcVnPoint2_REAL& aPoint2;
			VN_TcVnVector2_REAL& aDirection;
			bool bNormalize;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToPointDirection_TcVnPoint2_REAL_Params(TcVnPoint2_REAL& aPoint1, TcVnPoint2_REAL& aPoint2, TcVnVector2_REAL& aDirection, bool bNormalize, HRESULT hrPrev) : aPoint1(aPoint1), aPoint2(aPoint2), aDirection(aDirection), bNormalize(bNormalize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the direction vector between 2 points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint1">Point 1</param>
	/// <param name="aPoint2">Point 2</param>
	/// <param name="aDirection">Returns the direction vector from aPoint1 to aPoint2</param>
	/// <param name="bNormalize">If true, aDirection length is normalized to 1, otherwise aDirection length is the distance between aPoint1 and aPoint2</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToPointDirection(HRESULT hrPrev, TcVnPoint2_REAL& aPoint1, TcVnPoint2_REAL& aPoint2, TcVnVector2_REAL& aDirection, bool bNormalize)
	{
		Internal::PointToPointDirection_TcVnPoint2_REAL_Params params(aPoint1, aPoint2, aDirection, bNormalize, hrPrev);

		libraryInfo.functions[602 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToPointDistance_TcVnPoint2_DINT_Params
		{
			VN_TcVnPoint2_DINT& aPoint1;
			VN_TcVnPoint2_DINT& aPoint2;
			double& fDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToPointDistance_TcVnPoint2_DINT_Params(TcVnPoint2_DINT& aPoint1, TcVnPoint2_DINT& aPoint2, double& fDistance, HRESULT hrPrev) : aPoint1(aPoint1), aPoint2(aPoint2), fDistance(fDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the distance between 2 points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint1">Point 1</param>
	/// <param name="aPoint2">Point 2</param>
	/// <param name="fDistance">Returns the distance between the points</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToPointDistance(HRESULT hrPrev, TcVnPoint2_DINT& aPoint1, TcVnPoint2_DINT& aPoint2, double& fDistance)
	{
		Internal::PointToPointDistance_TcVnPoint2_DINT_Params params(aPoint1, aPoint2, fDistance, hrPrev);

		libraryInfo.functions[603 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToPointDistance_TcVnPoint2_LREAL_Params
		{
			VN_TcVnPoint2_LREAL& aPoint1;
			VN_TcVnPoint2_LREAL& aPoint2;
			double& fDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToPointDistance_TcVnPoint2_LREAL_Params(TcVnPoint2_LREAL& aPoint1, TcVnPoint2_LREAL& aPoint2, double& fDistance, HRESULT hrPrev) : aPoint1(aPoint1), aPoint2(aPoint2), fDistance(fDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the distance between 2 points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint1">Point 1</param>
	/// <param name="aPoint2">Point 2</param>
	/// <param name="fDistance">Returns the distance between the points</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToPointDistance(HRESULT hrPrev, TcVnPoint2_LREAL& aPoint1, TcVnPoint2_LREAL& aPoint2, double& fDistance)
	{
		Internal::PointToPointDistance_TcVnPoint2_LREAL_Params params(aPoint1, aPoint2, fDistance, hrPrev);

		libraryInfo.functions[604 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PointToPointDistance_TcVnPoint2_REAL_Params
		{
			VN_TcVnPoint2_REAL& aPoint1;
			VN_TcVnPoint2_REAL& aPoint2;
			double& fDistance;
			HRESULT hrPrev;
			HRESULT retVal;

			PointToPointDistance_TcVnPoint2_REAL_Params(TcVnPoint2_REAL& aPoint1, TcVnPoint2_REAL& aPoint2, double& fDistance, HRESULT hrPrev) : aPoint1(aPoint1), aPoint2(aPoint2), fDistance(fDistance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the distance between 2 points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aPoint1">Point 1</param>
	/// <param name="aPoint2">Point 2</param>
	/// <param name="fDistance">Returns the distance between the points</param>
	/// <returns>HRESULT</returns>
	static HRESULT PointToPointDistance(HRESULT hrPrev, TcVnPoint2_REAL& aPoint1, TcVnPoint2_REAL& aPoint2, double& fDistance)
	{
		Internal::PointToPointDistance_TcVnPoint2_REAL_Params params(aPoint1, aPoint2, fDistance, hrPrev);

		libraryInfo.functions[605 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL PutLabel_aFontColorDefault = {0, 0, 0, 0};
		static TcVnVector4_LREAL PutLabel_aBackgroundColorDefault = {255, 255, 255, 255};

		struct PutLabel_Params
		{
			PCCH sText;
			ITcVnImage* ipDestImage;
			ULONG nX;
			ULONG nY;
			double fFontScale;
			ULONG nThickness;
			ETcVnFontType eFontType;
			VN_TcVnVector4_LREAL& aFontColor;
			VN_TcVnVector4_LREAL& aBackgroundColor;
			ETcVnLineType eLineType;
			HRESULT hrPrev;
			HRESULT retVal;

			PutLabel_Params(PCCH sText, ITcVnImage* ipDestImage, ULONG nX, ULONG nY, double fFontScale, ULONG nThickness, ETcVnFontType eFontType, TcVnVector4_LREAL& aFontColor, TcVnVector4_LREAL& aBackgroundColor, ETcVnLineType eLineType, HRESULT hrPrev) : sText(sText), ipDestImage(ipDestImage), nX(nX), nY(nY), fFontScale(fFontScale), nThickness(nThickness), eFontType(eFontType), aFontColor(aFontColor), aBackgroundColor(aBackgroundColor), eLineType(eLineType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Write a label (text on unified background) into an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="sText">Text</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="nX">x coordinate (bottom left)</param>
	/// <param name="nY">y coordinate (bottom left)</param>
	/// <param name="fFontScale">Scaling factor</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="eFontType">Font type</param>
	/// <param name="aFontColor">Font color</param>
	/// <param name="aBackgroundColor">Background color</param>
	/// <param name="eLineType">Line type</param>
	/// <returns>HRESULT</returns>
	static HRESULT PutLabel(HRESULT hrPrev, PCCH sText, ITcVnImage* ipDestImage, ULONG nX, ULONG nY, double fFontScale, ULONG nThickness = 1, ETcVnFontType eFontType = FT_HERSHEY_SIMPLEX, TcVnVector4_LREAL& aFontColor = Internal::PutLabel_aFontColorDefault, TcVnVector4_LREAL& aBackgroundColor = Internal::PutLabel_aBackgroundColorDefault, ETcVnLineType eLineType = LT_4_CONNECTED)
	{
		Internal::PutLabel_Params params(sText, ipDestImage, nX, nY, fFontScale, nThickness, eFontType, aFontColor, aBackgroundColor, eLineType, hrPrev);

		libraryInfo.functions[606 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PutText_Params
		{
			PCCH sText;
			ITcVnImage* ipDestImage;
			ULONG nX;
			ULONG nY;
			ETcVnFontType eFontType;
			double fFontScale;
			VN_TcVnVector4_LREAL& aColor;
			LONG nThickness;
			ETcVnLineType eLineType;
			bool bBottomLeftOrigin;
			HRESULT hrPrev;
			HRESULT retVal;

			PutText_Params(PCCH sText, ITcVnImage* ipDestImage, ULONG nX, ULONG nY, ETcVnFontType eFontType, double fFontScale, TcVnVector4_LREAL& aColor, LONG nThickness, ETcVnLineType eLineType, bool bBottomLeftOrigin, HRESULT hrPrev) : sText(sText), ipDestImage(ipDestImage), nX(nX), nY(nY), eFontType(eFontType), fFontScale(fFontScale), aColor(aColor), nThickness(nThickness), eLineType(eLineType), bBottomLeftOrigin(bBottomLeftOrigin), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Write text into an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="sText">Text</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="nX">x coordinate (bottom left)</param>
	/// <param name="nY">y coordinate (bottom left)</param>
	/// <param name="eFontType">Font type</param>
	/// <param name="fFontScale">Scaling factor</param>
	/// <param name="aColor">Text color</param>
	/// <param name="nThickness">Line thickness</param>
	/// <param name="eLineType">Line type</param>
	/// <param name="bBottomLeftOrigin">Sets the image origin to the bottom left corner, if true</param>
	/// <returns>HRESULT</returns>
	static HRESULT PutText(HRESULT hrPrev, PCCH sText, ITcVnImage* ipDestImage, ULONG nX, ULONG nY, ETcVnFontType eFontType, double fFontScale, TcVnVector4_LREAL& aColor, LONG nThickness = 1, ETcVnLineType eLineType = LT_8_CONNECTED, bool bBottomLeftOrigin = false)
	{
		Internal::PutText_Params params(sText, ipDestImage, nX, nY, eFontType, fFontScale, aColor, nThickness, eLineType, bBottomLeftOrigin, hrPrev);

		libraryInfo.functions[607 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PyramidDown_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			PyramidDown_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Downsamples an image to half width and height.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT PyramidDown(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::PyramidDown_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[608 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PyramidUp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			PyramidUp_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Upsamples an image to double width and height.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT PyramidUp(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::PyramidUp_Params params(ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[609 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct Reduce_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			LONG nDim;
			ETcVnReduceType eReduceType;
			HRESULT hrPrev;
			HRESULT retVal;

			Reduce_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, LONG nDim, ETcVnReduceType eReduceType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nDim(nDim), eReduceType(eReduceType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Reduce ipSrcImage by applying the specified operation across rows/columns to obtain a single row/column/channel with the resulting values.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT or REAL elements, 1 channel)</param>
	/// <param name="ipDestImage">Destination image. If ipSrcImage is of type USINT and the reduction type is SUM or AVG, ipDestImage will be of type REAL; otherwise, it retains the same type as ipSrcImage (An appropriate single channel destination image will be created if required.)</param>
	/// <param name="nDim">Index along which the ITcVnImage is reduced: 0 reduces the matrix to a single row, 1 reduces it to a single column, and 2 reduces to a single channel</param>
	/// <param name="eReduceType">Reduction operation</param>
	/// <returns>HRESULT</returns>
	static HRESULT Reduce(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, LONG nDim, ETcVnReduceType eReduceType)
	{
		Internal::Reduce_Params params(ipSrcImage, ipDestImage, nDim, eReduceType, hrPrev);

		libraryInfo.functions[610 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReduceArg_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			LONG nDim;
			LONG eReduceType;
			HRESULT hrPrev;
			HRESULT retVal;

			ReduceArg_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, LONG nDim, LONG eReduceType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nDim(nDim), eReduceType(eReduceType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Finds indices of max/min elements along provided axis and reduce the ipSrcImage to a single row/column/channel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image of type DINT (An appropriate single channel destination image will be created if required.)</param>
	/// <param name="nDim">Index along which the ipSrcImage is reduced: 0 reduces the matrix to a single row, 1 reduces it to a single column, and 2 reduces to a single channel</param>
	/// <param name="eReduceType">Reduction operation REDUCE_MAX or REDUCE_MIN</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReduceArg(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, LONG nDim, LONG eReduceType)
	{
		Internal::ReduceArg_Params params(ipSrcImage, ipDestImage, nDim, eReduceType, hrPrev);

		libraryInfo.functions[611 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReferenceColorSimilarity_ITcVnColorModel_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnColorModel* ipColorModel;
			float fVariance;
			float fLuminanceWeight;
			HRESULT hrPrev;
			HRESULT retVal;

			ReferenceColorSimilarity_ITcVnColorModel_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnColorModel* ipColorModel, float fVariance, float fLuminanceWeight, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipColorModel(ipColorModel), fVariance(fVariance), fLuminanceWeight(fLuminanceWeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the similarity to a reference color model for each pixel in the source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">RGB source image (USINT, 3 channels)</param>
	/// <param name="ipDestImage">Returns the similarity to ipColorModel for each pixel in ipSrcImage (USINT, 1 channel. An appropriate destination image will be created if required.)</param>
	/// <param name="ipColorModel">Color model</param>
	/// <param name="fVariance">Allowed color variance (0.1 - 0.3 might be a good start to try)</param>
	/// <param name="fLuminanceWeight">Weight the impact of the luminance ([0..1], e.g. set to 0 to be more resistant to unequal illumination, but might be required to differentiate between some colors. Ignored if ipColorModel is of type RGB.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReferenceColorSimilarity(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnColorModel* ipColorModel, float fVariance = 0.15f, float fLuminanceWeight = 0)
	{
		Internal::ReferenceColorSimilarity_ITcVnColorModel_Params params(ipSrcImage, ipDestImage, ipColorModel, fVariance, fLuminanceWeight, hrPrev);

		libraryInfo.functions[612 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReferenceColorSimilarity_ITcVnMlModel_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnMlModel* ipColorModel;
			float fVariance;
			float fLuminanceWeight;
			HRESULT hrPrev;
			HRESULT retVal;

			ReferenceColorSimilarity_ITcVnMlModel_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnMlModel* ipColorModel, float fVariance, float fLuminanceWeight, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipColorModel(ipColorModel), fVariance(fVariance), fLuminanceWeight(fLuminanceWeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the similarity to a reference color model for each pixel in the source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">RGB source image (USINT, 3 channels)</param>
	/// <param name="ipDestImage">Returns the similarity to ipColorModel for each pixel in ipSrcImage (USINT, 1 channel. An appropriate destination image will be created if required.)</param>
	/// <param name="ipColorModel">Color model</param>
	/// <param name="fVariance">Allowed color variance (0.1 - 0.3 might be a good start to try)</param>
	/// <param name="fLuminanceWeight">Weight the impact of the luminance ([0..1], e.g. set to 0 to be more resistant to unequal illumination, but might be required to differentiate between some colors. Ignored if ipColorModel is of type RGB.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReferenceColorSimilarity(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnMlModel* ipColorModel, float fVariance = 0.15f, float fLuminanceWeight = 0)
	{
		Internal::ReferenceColorSimilarity_ITcVnMlModel_Params params(ipSrcImage, ipDestImage, ipColorModel, fVariance, fLuminanceWeight, hrPrev);

		libraryInfo.functions[613 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReferenceColorSimilarity_TcVnVector3_LREAL_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			VN_TcVnVector3_LREAL& aRefColor;
			float fVariance;
			float fLuminanceWeight;
			HRESULT hrPrev;
			HRESULT retVal;

			ReferenceColorSimilarity_TcVnVector3_LREAL_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnVector3_LREAL& aRefColor, float fVariance, float fLuminanceWeight, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aRefColor(aRefColor), fVariance(fVariance), fLuminanceWeight(fLuminanceWeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the similarity to a reference color for each pixel in the source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">RGB source image (USINT, 3 channels)</param>
	/// <param name="ipDestImage">Returns the similarity to aRefColor for each pixel in ipSrcImage (USINT, 1 channel. An appropriate destination image will be created if required.)</param>
	/// <param name="aRefColor">Reference color (RGB, [0..255])</param>
	/// <param name="fVariance">Allowed color variance (0.1 - 0.3 might be a good start to try)</param>
	/// <param name="fLuminanceWeight">Weight the impact of the luminance ([0..1], e.g. set to 0 to be more resistant to unequal illumination, but might be required to differentiate between some colors)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReferenceColorSimilarity(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnVector3_LREAL& aRefColor, float fVariance = 0.15f, float fLuminanceWeight = 0)
	{
		Internal::ReferenceColorSimilarity_TcVnVector3_LREAL_Params params(ipSrcImage, ipDestImage, aRefColor, fVariance, fLuminanceWeight, hrPrev);

		libraryInfo.functions[614 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RegionOrientation_Params
		{
			ITcVnImage* ipSrcImage;
			TcVnRotatedRectangle& stOrientation;
			ETcVnOrientationMethod eMethod;
			HRESULT hrPrev;
			HRESULT retVal;

			RegionOrientation_Params(ITcVnImage* ipSrcImage, TcVnRotatedRectangle& stOrientation, ETcVnOrientationMethod eMethod, HRESULT hrPrev) : ipSrcImage(ipSrcImage), stOrientation(stOrientation), eMethod(eMethod), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the orientation of a region based on a binary image that contains a non zero value for every pixel in that region. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel, binary)</param>
	/// <param name="stOrientation">Resulting rotated rectangle, containig center of mass, lenghts of axes, and rotation angle of the region in clockwise direction.</param>
	/// <param name="eMethod">Method for calculating the orientation.</param>
	/// <returns>HRESULT</returns>
	static HRESULT RegionOrientation(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnRotatedRectangle& stOrientation, ETcVnOrientationMethod eMethod = OM_PCA)
	{
		Internal::RegionOrientation_Params params(ipSrcImage, stOrientation, eMethod, hrPrev);

		libraryInfo.functions[615 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReinterpretUnsupportedImage_Params
		{
			ITcVnImage* ipImage;
			ETcVnElementType ePixelType;
			HRESULT hrPrev;
			HRESULT retVal;

			ReinterpretUnsupportedImage_Params(ITcVnImage* ipImage, ETcVnElementType ePixelType, HRESULT hrPrev) : ipImage(ipImage), ePixelType(ePixelType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Reinterpret an unsupported image using additional information. If successful, the image will be of a supported type.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image to be reinterpreted</param>
	/// <param name="ePixelType">Pixel element type to be used for reinterpreting the image data</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReinterpretUnsupportedImage(HRESULT hrPrev, ITcVnImage* ipImage, ETcVnElementType ePixelType)
	{
		Internal::ReinterpretUnsupportedImage_Params params(ipImage, ePixelType, hrPrev);

		libraryInfo.functions[616 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RemapImageToLogPolarSpace_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			VN_TcVnPoint2_REAL& aCenter;
			double fScale;
			ETcVnInterpolationType eInterpolationType;
			LONG nDestWidth;
			LONG nDestHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			RemapImageToLogPolarSpace_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnPoint2_REAL& aCenter, double fScale, ETcVnInterpolationType eInterpolationType, LONG nDestWidth, LONG nDestHeight, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aCenter(aCenter), fScale(fScale), eInterpolationType(eInterpolationType), nDestWidth(nDestWidth), nDestHeight(nDestHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Remap an image to log-polar space. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (Must not be the same as ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <param name="aCenter">Center point for the transformation</param>
	/// <param name="fScale">Magnitude scale parameter, i.e. image width / ln(radius) (set to 0 for auto select)</param>
	/// <param name="eInterpolationType">Interpolation type</param>
	/// <param name="nDestWidth">Destination image width (set to -1 for source image width, 0 to auto scale to transformed radius, &gt; 0 for a user defined width)</param>
	/// <param name="nDestHeight">destination image height (set to -1 for source image height, 0 to auto scale to transformed radius * PI, &gt; 0 for a user defined height)</param>
	/// <returns>HRESULT</returns>
	static HRESULT RemapImageToLogPolarSpace(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnPoint2_REAL& aCenter, double fScale = 0, ETcVnInterpolationType eInterpolationType = IT_BILINEAR, LONG nDestWidth = -1, LONG nDestHeight = -1)
	{
		Internal::RemapImageToLogPolarSpace_Params params(ipSrcImage, ipDestImage, aCenter, fScale, eInterpolationType, nDestWidth, nDestHeight, hrPrev);

		libraryInfo.functions[617 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RemapImageToPolarSpace_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			VN_TcVnPoint2_REAL& aCenter;
			double fMaxRadius;
			ETcVnInterpolationType eInterpolationType;
			LONG nDestWidth;
			LONG nDestHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			RemapImageToPolarSpace_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnPoint2_REAL& aCenter, double fMaxRadius, ETcVnInterpolationType eInterpolationType, LONG nDestWidth, LONG nDestHeight, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aCenter(aCenter), fMaxRadius(fMaxRadius), eInterpolationType(eInterpolationType), nDestWidth(nDestWidth), nDestHeight(nDestHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Remap an image to polar space. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (Must not be the same as ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <param name="aCenter">Center point for the transformation</param>
	/// <param name="fMaxRadius">Maximum radius for the transformation (set to 0 for auto select)</param>
	/// <param name="eInterpolationType">Interpolation type</param>
	/// <param name="nDestWidth">Destination image width (set to -1 for source image width, 0 to auto scale to transformed radius, &gt; 0 for a user defined width)</param>
	/// <param name="nDestHeight">destination image height (set to -1 for source image height, 0 to auto scale to transformed radius * PI, &gt; 0 for a user defined height)</param>
	/// <returns>HRESULT</returns>
	static HRESULT RemapImageToPolarSpace(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnPoint2_REAL& aCenter, double fMaxRadius = 0, ETcVnInterpolationType eInterpolationType = IT_BILINEAR, LONG nDestWidth = -1, LONG nDestHeight = -1)
	{
		Internal::RemapImageToPolarSpace_Params params(ipSrcImage, ipDestImage, aCenter, fMaxRadius, eInterpolationType, nDestWidth, nDestHeight, hrPrev);

		libraryInfo.functions[618 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RemoveLocalMaxima_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			RemoveLocalMaxima_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fHeight, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fHeight(fHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Remove local maxima up to a given height from a gray-scale single-channel image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, UINT, INT, REAL, or LREAL, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fHeight">Maximum height of the maxima to be removed (must be greater than 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT RemoveLocalMaxima(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fHeight)
	{
		Internal::RemoveLocalMaxima_Params params(ipSrcImage, ipDestImage, fHeight, hrPrev);

		libraryInfo.functions[619 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RemoveLocalMinima_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fHeight;
			HRESULT hrPrev;
			HRESULT retVal;

			RemoveLocalMinima_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fHeight, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fHeight(fHeight), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Remove local minima up to a given height from a gray-scale single-channel image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, UINT, INT, REAL, or LREAL, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fHeight">Maximum height of the minima to be removed (must be greater than 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT RemoveLocalMinima(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fHeight)
	{
		Internal::RemoveLocalMinima_Params params(ipSrcImage, ipDestImage, fHeight, hrPrev);

		libraryInfo.functions[620 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReserveContainerMemory_Params
		{
			ITcVnContainer* ipContainer;
			ULONGLONG nElements;
			HRESULT hrPrev;
			HRESULT retVal;

			ReserveContainerMemory_Params(ITcVnContainer* ipContainer, ULONGLONG nElements, HRESULT hrPrev) : ipContainer(ipContainer), nElements(nElements), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Reserve container memory (call with maximum required number of elements before manually appending elements for better performance)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container for which to reserve the memory</param>
	/// <param name="nElements">Number of elements for which the container should reserve memory</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReserveContainerMemory(HRESULT hrPrev, ITcVnContainer* ipContainer, ULONGLONG nElements)
	{
		Internal::ReserveContainerMemory_Params params(ipContainer, nElements, hrPrev);

		libraryInfo.functions[621 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ResetRoi_Params
		{
			ITcVnImage* ipImage;
			HRESULT hrPrev;
			HRESULT retVal;

			ResetRoi_Params(ITcVnImage* ipImage, HRESULT hrPrev) : ipImage(ipImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Reset the region of interest (ROI) of an image. (After this operation, the ROI is set to the entire image.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Image</param>
	/// <returns>HRESULT</returns>
	static HRESULT ResetRoi(HRESULT hrPrev, ITcVnImage* ipImage)
	{
		Internal::ResetRoi_Params params(ipImage, hrPrev);

		libraryInfo.functions[622 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReshapeImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnArray33_UDINT& aNewShape;
			HRESULT hrPrev;
			HRESULT retVal;

			ReshapeImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnArray33_UDINT& aNewShape, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aNewShape(aNewShape), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Changes the shape of an ITcVnImage. The total number of elements in the new shape must be equal to the total number of elements in ipSrcImage.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate single channel destination image will be created if required.)</param>
	/// <param name="aNewShape">Specifies the shape of ipDestImage. First entry is the number of dimensions (max. 32), followed by the sizes of each dimension. If one dimension is set to zero, its value will be automatically calculated based on the total elements of ipSrcImage (Only one dimension can be set to zero.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReshapeImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnArray33_UDINT& aNewShape)
	{
		Internal::ReshapeImage_Params params(ipSrcImage, ipDestImage, aNewShape, hrPrev);

		libraryInfo.functions[623 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL ResizeImage_aBorderValueDefault = {0, 0, 0, 0};

		struct ResizeImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ULONG nWidth;
			ULONG nHeight;
			ETcVnInterpolationType eInterpolationType;
			ETcVnPaddingMode ePaddingMode;
			VN_TcVnVector4_LREAL& aBorderValue;
			HRESULT hrPrev;
			HRESULT retVal;

			ResizeImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nWidth, ULONG nHeight, ETcVnInterpolationType eInterpolationType, ETcVnPaddingMode ePaddingMode, TcVnVector4_LREAL& aBorderValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nWidth(nWidth), nHeight(nHeight), eInterpolationType(eInterpolationType), ePaddingMode(ePaddingMode), aBorderValue(aBorderValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Resize an image using a specific interpolation type while maintaining its aspect ratio. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="nWidth">New width</param>
	/// <param name="nHeight">New height</param>
	/// <param name="eInterpolationType">Interpolation type</param>
	/// <param name="ePaddingMode">Image padding mode</param>
	/// <param name="aBorderValue">Border value, if TCVN_PM_LETTERBOX is used</param>
	/// <returns>HRESULT</returns>
	static HRESULT ResizeImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nWidth, ULONG nHeight, ETcVnInterpolationType eInterpolationType, ETcVnPaddingMode ePaddingMode = PM_NONE, TcVnVector4_LREAL& aBorderValue = Internal::ResizeImage_aBorderValueDefault)
	{
		Internal::ResizeImage_Params params(ipSrcImage, ipDestImage, nWidth, nHeight, eInterpolationType, ePaddingMode, aBorderValue, hrPrev);

		libraryInfo.functions[624 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReverseContainer_Params
		{
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			ReverseContainer_Params(ITcVnContainer* ipContainer, HRESULT hrPrev) : ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Reverse the container elements.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContainer">Container to be reversed</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReverseContainer(HRESULT hrPrev, ITcVnContainer* ipContainer)
	{
		Internal::ReverseContainer_Params params(ipContainer, hrPrev);

		libraryInfo.functions[625 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RotatedRectangleCorners_Params
		{
			TcVnRotatedRectangle& stRect;
			TcVnArray4_Point2_REAL& aCorners;
			HRESULT hrPrev;
			HRESULT retVal;

			RotatedRectangleCorners_Params(TcVnRotatedRectangle& stRect, TcVnArray4_Point2_REAL& aCorners, HRESULT hrPrev) : stRect(stRect), aCorners(aCorners), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the 4 corner points of a rotated rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRect">Rotated rectangle</param>
	/// <param name="aCorners">Returns the 4 corner points</param>
	/// <returns>HRESULT</returns>
	static HRESULT RotatedRectangleCorners(HRESULT hrPrev, TcVnRotatedRectangle& stRect, TcVnArray4_Point2_REAL& aCorners)
	{
		Internal::RotatedRectangleCorners_Params params(stRect, aCorners, hrPrev);

		libraryInfo.functions[626 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RotatedRectangleIntersection_Params
		{
			TcVnRotatedRectangle& stRect1;
			TcVnRotatedRectangle& stRect2;
			ITcVnContainer*& ipIntersection;
			ETcVnRectangleIntersection& eIntersection;
			HRESULT hrPrev;
			HRESULT retVal;

			RotatedRectangleIntersection_Params(TcVnRotatedRectangle& stRect1, TcVnRotatedRectangle& stRect2, ITcVnContainer*& ipIntersection, ETcVnRectangleIntersection& eIntersection, HRESULT hrPrev) : stRect1(stRect1), stRect2(stRect2), ipIntersection(ipIntersection), eIntersection(eIntersection), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Finds the intersection of 2 rotated rectangles.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRect1">Rotated rectangle 1</param>
	/// <param name="stRect2">Rotated rectangle 2</param>
	/// <param name="ipIntersection">Returns the intersection points (ContainerType_Vector_TcVnPoint2_REAL, non-zero interface pointers are reused)</param>
	/// <param name="eIntersection">Returns the intersection type</param>
	/// <returns>HRESULT</returns>
	static HRESULT RotatedRectangleIntersection(HRESULT hrPrev, TcVnRotatedRectangle& stRect1, TcVnRotatedRectangle& stRect2, ITcVnContainer*& ipIntersection, ETcVnRectangleIntersection& eIntersection)
	{
		Internal::RotatedRectangleIntersection_Params params(stRect1, stRect2, ipIntersection, eIntersection, hrPrev);

		libraryInfo.functions[627 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct RotateImage_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnRotationAngle eAngle;
			HRESULT hrPrev;
			HRESULT retVal;

			RotateImage_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnRotationAngle eAngle, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eAngle(eAngle), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Rotate an image by 90, 180, or 270 degrees in clockwise direction.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="eAngle">Rotation angle</param>
	/// <returns>HRESULT</returns>
	static HRESULT RotateImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnRotationAngle eAngle)
	{
		Internal::RotateImage_Params params(ipSrcImage, ipDestImage, eAngle, hrPrev);

		libraryInfo.functions[628 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL RotateImageExp_aBorderValueDefault = {0, 0, 0, 0};

		struct RotateImageExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fAngleDeg;
			bool bAdjustDestSize;
			ETcVnInterpolationType eInterpolationType;
			ETcVnBorderInterpolationMethod eBorderInterpolation;
			VN_TcVnVector4_LREAL& aBorderValue;
			HRESULT hrPrev;
			HRESULT retVal;

			RotateImageExp_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fAngleDeg, bool bAdjustDestSize, ETcVnInterpolationType eInterpolationType, ETcVnBorderInterpolationMethod eBorderInterpolation, TcVnVector4_LREAL& aBorderValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fAngleDeg(fAngleDeg), bAdjustDestSize(bAdjustDestSize), eInterpolationType(eInterpolationType), eBorderInterpolation(eBorderInterpolation), aBorderValue(aBorderValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Rotate an image by an individual rotation angle in degrees. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="fAngleDeg">Rotation angle in degree (positive: counter-clockwise, negative: clockwise)</param>
	/// <param name="bAdjustDestSize">If true, ipDestImage size is adjusted so that the whole rotated ipSrcImage is contained. Otherwise, ipDestImage size is set to ipSrcImage size.</param>
	/// <param name="eInterpolationType">Interpolation method</param>
	/// <param name="eBorderInterpolation">Border interpolation method (ISOLATED not supported)</param>
	/// <param name="aBorderValue">Border value, if CONSTANT is used</param>
	/// <returns>HRESULT</returns>
	static HRESULT RotateImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fAngleDeg, bool bAdjustDestSize, ETcVnInterpolationType eInterpolationType = IT_BILINEAR, ETcVnBorderInterpolationMethod eBorderInterpolation = BIM_CONSTANT, TcVnVector4_LREAL& aBorderValue = Internal::RotateImageExp_aBorderValueDefault)
	{
		Internal::RotateImageExp_Params params(ipSrcImage, ipDestImage, fAngleDeg, bAdjustDestSize, eInterpolationType, eBorderInterpolation, aBorderValue, hrPrev);

		libraryInfo.functions[629 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SauvolaThreshold_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& pipDestImage;
			ULONG nBlockSize;
			double fParamK;
			double fMaxSigma;
			ETcVnThresholdType eThresholdType;
			HRESULT hrPrev;
			HRESULT retVal;

			SauvolaThreshold_Params(ITcVnImage* ipSrcImage, ITcVnImage*& pipDestImage, ULONG nBlockSize, double fParamK, double fMaxSigma, ETcVnThresholdType eThresholdType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), pipDestImage(pipDestImage), nBlockSize(nBlockSize), fParamK(fParamK), fMaxSigma(fMaxSigma), eThresholdType(eThresholdType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply Sauvola local threshold to source image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, UINT, INT, REAL, or LREAL, 1 channel)</param>
	/// <param name="pipDestImage">Destination image (An appropriate single channel destination image will be created if required.))</param>
	/// <param name="nBlockSize">Size of the pixel neighborhood to calculate the local threshold (3, 5, 7, ...)</param>
	/// <param name="fParamK">parameter K which takes positive values in range (0,1). Recommended are K in range [0.2, 0.5]</param>
	/// <param name="fMaxSigma">Maximum value of the standard deviation, required to be strictly positive. (fMaxSigma = 128 for a grayscale document). </param>
	/// <param name="eThresholdType">Threshold type to be applied. Supported are TCVN_TT_BINARY and TCVN_TT_BINARY_INV.</param>
	/// <returns>HRESULT</returns>
	static HRESULT SauvolaThreshold(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& pipDestImage, ULONG nBlockSize, double fParamK, double fMaxSigma, ETcVnThresholdType eThresholdType)
	{
		Internal::SauvolaThreshold_Params params(ipSrcImage, pipDestImage, nBlockSize, fParamK, fMaxSigma, eThresholdType, hrPrev);

		libraryInfo.functions[630 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ScharrFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnElementType eDestDepth;
			ETcVnFilterDirection eFilterDirection;
			double fScale;
			double fDelta;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			ScharrFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, ETcVnFilterDirection eFilterDirection, double fScale, double fDelta, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eDestDepth(eDestDepth), eFilterDirection(eFilterDirection), fScale(fScale), fDelta(fDelta), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculates the first order derivative in x or y direction using a Scharr filter. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eDestDepth">Destination image depth</param>
	/// <param name="eFilterDirection">Filter direction</param>
	/// <param name="fScale">Scale factor for the computed derivative values</param>
	/// <param name="fDelta">Delta value that is added to the results prior to storing them in dest</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT ScharrFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, ETcVnFilterDirection eFilterDirection, double fScale = 1, double fDelta = 0, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::ScharrFilter_Params params(ipSrcImage, ipDestImage, eDestDepth, eFilterDirection, fScale, fDelta, eBorderType, hrPrev);

		libraryInfo.functions[631 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnPoint SeparableCustomFilter_aAnchorDefault = {-1, -1};

		struct SeparableCustomFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnElementType eDestDepth;
			TcVnMatrix& stKernelX;
			TcVnMatrix& stKernelY;
			VN_TcVnPoint& aAnchor;
			double fDelta;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			SeparableCustomFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, TcVnMatrix& stKernelX, TcVnMatrix& stKernelY, TcVnPoint& aAnchor, double fDelta, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eDestDepth(eDestDepth), stKernelX(stKernelX), stKernelY(stKernelY), aAnchor(aAnchor), fDelta(fDelta), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a separable custom filter to the image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eDestDepth">Destination image depth</param>
	/// <param name="stKernelX">1D custom row-filter kernel with values of type REAL or LREAL</param>
	/// <param name="stKernelY">1D custom column-filter kernel with values of type REAL or LREAL</param>
	/// <param name="aAnchor">Anchor point of the kernel</param>
	/// <param name="fDelta">Value added to each pixel after filtering</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT SeparableCustomFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, TcVnMatrix& stKernelX, TcVnMatrix& stKernelY, TcVnPoint& aAnchor = Internal::SeparableCustomFilter_aAnchorDefault, double fDelta = 0, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::SeparableCustomFilter_Params params(ipSrcImage, ipDestImage, eDestDepth, stKernelX, stKernelY, aAnchor, fDelta, eBorderType, hrPrev);

		libraryInfo.functions[632 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_DINT_Params
		{
			LONG nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_DINT_Params(LONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with DINT elements, in which the element at position nIndex is replaced by nElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, LONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_DINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[633 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_INT_Params
		{
			SHORT nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_INT_Params(SHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with INT elements, in which the element at position nIndex is replaced by nElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, SHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_INT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[634 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_ITcVnContainer_Params
		{
			ITcVnContainer* ipElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_ITcVnContainer_Params(ITcVnContainer* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container. (Alternatively use interface method .SetAt.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with ITcVnContainer elements, in which the element at position nIndex is replaced by ipElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, ITcVnContainer* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_ITcVnContainer_Params params(ipElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[635 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_ITcVnImage_Params
		{
			ITcVnImage* ipElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_ITcVnImage_Params(ITcVnImage* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : ipElement(ipElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with ITcVnImage elements, in which the element at position nIndex is replaced by ipElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, ITcVnImage* ipElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_ITcVnImage_Params params(ipElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[636 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_LREAL_Params
		{
			double fElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_LREAL_Params(double fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : fElement(fElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with LREAL elements, in which the element at position nIndex is replaced by fElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, double fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_LREAL_Params params(fElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[637 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_REAL_Params
		{
			float fElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_REAL_Params(float fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : fElement(fElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with REAL elements, in which the element at position nIndex is replaced by fElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, float fElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_REAL_Params params(fElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[638 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_SINT_Params
		{
			char nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_SINT_Params(char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with SINT elements, in which the element at position nIndex is replaced by nElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_SINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[639 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnDMatch_Params
		{
			TcVnDMatch& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnDMatch_Params(TcVnDMatch& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnDMatch elements, in which the element at position nIndex is replaced by stElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnDMatch& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnDMatch_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[640 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnKeyPoint_Params
		{
			TcVnKeyPoint& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnKeyPoint_Params(TcVnKeyPoint& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnKeyPoint elements, in which the element at position nIndex is replaced by stElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnKeyPoint& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnKeyPoint_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[641 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnPoint2_DINT_Params
		{
			VN_TcVnPoint2_DINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnPoint2_DINT_Params(TcVnPoint2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnPoint2_DINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnPoint2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnPoint2_DINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[642 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnPoint2_LREAL_Params
		{
			VN_TcVnPoint2_LREAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnPoint2_LREAL_Params(TcVnPoint2_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnPoint2_LREAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnPoint2_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnPoint2_LREAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[643 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnPoint2_REAL_Params
		{
			VN_TcVnPoint2_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnPoint2_REAL_Params(TcVnPoint2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnPoint2_REAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnPoint2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnPoint2_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[644 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnPoint3_LREAL_Params
		{
			VN_TcVnPoint3_LREAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnPoint3_LREAL_Params(TcVnPoint3_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnPoint3_LREAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnPoint3_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnPoint3_LREAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[645 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnPoint3_REAL_Params
		{
			VN_TcVnPoint3_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnPoint3_REAL_Params(TcVnPoint3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnPoint3_REAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnPoint3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnPoint3_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[646 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnRectangle_DINT_Params
		{
			TcVnRectangle_DINT& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnRectangle_DINT_Params(TcVnRectangle_DINT& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnRectangle_DINT elements, in which the element at position nIndex is replaced by stElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnRectangle_DINT& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnRectangle_DINT_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[647 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnRotatedRectangle_Params
		{
			TcVnRotatedRectangle& stElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnRotatedRectangle_Params(TcVnRotatedRectangle& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : stElement(stElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnRotatedRectangle elements, in which the element at position nIndex is replaced by stElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnRotatedRectangle& stElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnRotatedRectangle_Params params(stElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[648 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector2_DINT_Params
		{
			VN_TcVnVector2_DINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector2_DINT_Params(TcVnVector2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector2_DINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector2_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector2_DINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[649 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector2_INT_Params
		{
			VN_TcVnVector2_INT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector2_INT_Params(TcVnVector2_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector2_INT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector2_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector2_INT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[650 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector2_REAL_Params
		{
			VN_TcVnVector2_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector2_REAL_Params(TcVnVector2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector2_REAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector2_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector2_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[651 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector2_SINT_Params
		{
			VN_TcVnVector2_SINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector2_SINT_Params(TcVnVector2_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector2_SINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector2_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector2_SINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[652 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector2_UINT_Params
		{
			VN_TcVnVector2_UINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector2_UINT_Params(TcVnVector2_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector2_UINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector2_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector2_UINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[653 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector2_USINT_Params
		{
			VN_TcVnVector2_USINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector2_USINT_Params(TcVnVector2_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector2_USINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector2_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector2_USINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[654 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector3_INT_Params
		{
			VN_TcVnVector3_INT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector3_INT_Params(TcVnVector3_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector3_INT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector3_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector3_INT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[655 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector3_REAL_Params
		{
			VN_TcVnVector3_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector3_REAL_Params(TcVnVector3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector3_REAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector3_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector3_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[656 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector3_SINT_Params
		{
			VN_TcVnVector3_SINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector3_SINT_Params(TcVnVector3_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector3_SINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector3_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector3_SINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[657 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector3_UINT_Params
		{
			VN_TcVnVector3_UINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector3_UINT_Params(TcVnVector3_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector3_UINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector3_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector3_UINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[658 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector3_USINT_Params
		{
			VN_TcVnVector3_USINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector3_USINT_Params(TcVnVector3_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector3_USINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector3_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector3_USINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[659 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector4_DINT_Params
		{
			VN_TcVnVector4_DINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector4_DINT_Params(TcVnVector4_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector4_DINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector4_DINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector4_DINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[660 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector4_INT_Params
		{
			VN_TcVnVector4_INT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector4_INT_Params(TcVnVector4_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector4_INT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector4_INT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector4_INT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[661 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector4_LREAL_Params
		{
			VN_TcVnVector4_LREAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector4_LREAL_Params(TcVnVector4_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector4_LREAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector4_LREAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector4_LREAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[662 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector4_REAL_Params
		{
			VN_TcVnVector4_REAL& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector4_REAL_Params(TcVnVector4_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector4_REAL elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector4_REAL& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector4_REAL_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[663 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector4_SINT_Params
		{
			VN_TcVnVector4_SINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector4_SINT_Params(TcVnVector4_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector4_SINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector4_SINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector4_SINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[664 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector4_UINT_Params
		{
			VN_TcVnVector4_UINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector4_UINT_Params(TcVnVector4_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector4_UINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector4_UINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector4_UINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[665 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_TcVnVector4_USINT_Params
		{
			VN_TcVnVector4_USINT& aElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_TcVnVector4_USINT_Params(TcVnVector4_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : aElement(aElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with TcVnVector4_USINT elements, in which the element at position nIndex is replaced by aElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, TcVnVector4_USINT& aElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_TcVnVector4_USINT_Params params(aElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[666 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_UDINT_Params
		{
			ULONG nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_UDINT_Params(ULONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with UDINT elements, in which the element at position nIndex is replaced by nElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, ULONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_UDINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[667 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_UINT_Params
		{
			USHORT nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_UINT_Params(USHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with UINT elements, in which the element at position nIndex is replaced by nElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, USHORT nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_UINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[668 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_ULINT_Params
		{
			ULONGLONG nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_ULINT_Params(ULONGLONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with ULINT elements, in which the element at position nIndex is replaced by nElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, ULONGLONG nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_ULINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[669 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetAt_USINT_Params
		{
			unsigned char nElement;
			ITcVnContainer* ipContainer;
			ULONGLONG nIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetAt_USINT_Params(unsigned char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex, HRESULT hrPrev) : nElement(nElement), ipContainer(ipContainer), nIndex(nIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the element at the specified index of the container.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nElement">Element to set at the specified container position</param>
	/// <param name="ipContainer">Container with USINT elements, in which the element at position nIndex is replaced by nElement</param>
	/// <param name="nIndex">Index</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetAt(HRESULT hrPrev, unsigned char nElement, ITcVnContainer* ipContainer, ULONGLONG nIndex)
	{
		Internal::SetAt_USINT_Params params(nElement, ipContainer, nIndex, hrPrev);

		libraryInfo.functions[670 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetContainer_Params
		{
			ITcVnForwardIterator* ipIterator;
			ITcVnContainer* ipContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			SetContainer_Params(ITcVnForwardIterator* ipIterator, ITcVnContainer* ipContainer, HRESULT hrPrev) : ipIterator(ipIterator), ipContainer(ipContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the current element using an ITcVnContainer interface (only possible for container types). (Alternatively use interface method .SetContainer.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIterator">Iterator</param>
	/// <param name="ipContainer">Container interface of which the content is to be assigned to the current element</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetContainer(HRESULT hrPrev, ITcVnForwardIterator* ipIterator, ITcVnContainer* ipContainer)
	{
		Internal::SetContainer_Params params(ipIterator, ipContainer, hrPrev);

		libraryInfo.functions[671 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetImageChannel_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			USHORT nSrcChannelIndex;
			USHORT nDestChannelIndex;
			HRESULT hrPrev;
			HRESULT retVal;

			SetImageChannel_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, USHORT nSrcChannelIndex, USHORT nDestChannelIndex, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nSrcChannelIndex(nSrcChannelIndex), nDestChannelIndex(nDestChannelIndex), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the specified destination image channel to the values of the specified source image channel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="nSrcChannelIndex">Index of the source image channel</param>
	/// <param name="nDestChannelIndex">Index of the destination image channel, which will be replaced by the specified source image channel</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetImageChannel(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, USHORT nSrcChannelIndex, USHORT nDestChannelIndex)
	{
		Internal::SetImageChannel_Params params(ipSrcImage, ipDestImage, nSrcChannelIndex, nDestChannelIndex, hrPrev);

		libraryInfo.functions[672 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetIteratorToBegin_Params
		{
			ITcVnForwardIterator* ipIterator;
			HRESULT hrPrev;
			HRESULT retVal;

			SetIteratorToBegin_Params(ITcVnForwardIterator* ipIterator, HRESULT hrPrev) : ipIterator(ipIterator), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the iterator to the first element of the container. (Alternatively use interface method .SetToBegin.)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipIterator">Iterator</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetIteratorToBegin(HRESULT hrPrev, ITcVnForwardIterator* ipIterator)
	{
		Internal::SetIteratorToBegin_Params params(ipIterator, hrPrev);

		libraryInfo.functions[673 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetPixel_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnVector4_LREAL& aValue;
			ULONG nX;
			ULONG nY;
			HRESULT hrPrev;
			HRESULT retVal;

			SetPixel_Params(ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aValue, ULONG nX, ULONG nY, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aValue(aValue), nX(nX), nY(nY), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets a specific pixel.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="aValue">The pixel value to set (additional channels are ignored.)</param>
	/// <param name="nX">x coordinate of the pixel</param>
	/// <param name="nY">y coordinate of the pixel</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetPixel(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aValue, ULONG nX, ULONG nY)
	{
		Internal::SetPixel_Params params(ipSrcImage, aValue, nX, nY, hrPrev);

		libraryInfo.functions[674 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetPixels_Params
		{
			ITcVnImage* ipDestImage;
			VN_TcVnVector4_LREAL& aValue;
			ITcVnImage* ipMask;
			HRESULT hrPrev;
			HRESULT retVal;

			SetPixels_Params(ITcVnImage* ipDestImage, TcVnVector4_LREAL& aValue, ITcVnImage* ipMask, HRESULT hrPrev) : ipDestImage(ipDestImage), aValue(aValue), ipMask(ipMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets all pixels of an image to a given value. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <param name="aValue">Pixel value</param>
	/// <param name="ipMask">Mask image</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetPixels(HRESULT hrPrev, ITcVnImage* ipDestImage, TcVnVector4_LREAL& aValue, ITcVnImage* ipMask = nullptr)
	{
		Internal::SetPixels_Params params(ipDestImage, aValue, ipMask, hrPrev);

		libraryInfo.functions[675 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetRngSeed_Params
		{
			LONG nSeed;
			HRESULT hrPrev;
			HRESULT retVal;

			SetRngSeed_Params(LONG nSeed, HRESULT hrPrev) : nSeed(nSeed), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets the internal pseudo random number generator seed (intended for testing purposes only).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nSeed">seed (0 sets the generator back to its initial state)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetRngSeed(HRESULT hrPrev, LONG nSeed)
	{
		Internal::SetRngSeed_Params params(nSeed, hrPrev);

		libraryInfo.functions[676 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetRoi_Params
		{
			ULONG nX;
			ULONG nY;
			ULONG nWidth;
			ULONG nHeight;
			ITcVnImage* ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SetRoi_Params(ULONG nX, ULONG nY, ULONG nWidth, ULONG nHeight, ITcVnImage* ipDestImage, HRESULT hrPrev) : nX(nX), nY(nY), nWidth(nWidth), nHeight(nHeight), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets a region of interest (ROI) within an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nX">Left boundary (inclusive 0-based index)</param>
	/// <param name="nY">Upper boundary (inclusive 0-based index)</param>
	/// <param name="nWidth">ROI width</param>
	/// <param name="nHeight">ROI height</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetRoi(HRESULT hrPrev, ULONG nX, ULONG nY, ULONG nWidth, ULONG nHeight, ITcVnImage* ipDestImage)
	{
		Internal::SetRoi_Params params(nX, nY, nWidth, nHeight, ipDestImage, hrPrev);

		libraryInfo.functions[677 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetRoi_TcVnRectangle_DINT_Params
		{
			TcVnRectangle_DINT& stRoi;
			ITcVnImage* ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SetRoi_TcVnRectangle_DINT_Params(TcVnRectangle_DINT& stRoi, ITcVnImage* ipDestImage, HRESULT hrPrev) : stRoi(stRoi), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets a region of interest (ROI) within an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRoi">Region of interest</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetRoi(HRESULT hrPrev, TcVnRectangle_DINT& stRoi, ITcVnImage* ipDestImage)
	{
		Internal::SetRoi_TcVnRectangle_DINT_Params params(stRoi, ipDestImage, hrPrev);

		libraryInfo.functions[678 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SetRoi_TcVnRectangle_UDINT_Params
		{
			TcVnRectangle_UDINT& stRoi;
			ITcVnImage* ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SetRoi_TcVnRectangle_UDINT_Params(TcVnRectangle_UDINT& stRoi, ITcVnImage* ipDestImage, HRESULT hrPrev) : stRoi(stRoi), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sets a region of interest (ROI) within an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="stRoi">Region of interest</param>
	/// <param name="ipDestImage">Destination image</param>
	/// <returns>HRESULT</returns>
	static HRESULT SetRoi(HRESULT hrPrev, TcVnRectangle_UDINT& stRoi, ITcVnImage* ipDestImage)
	{
		Internal::SetRoi_TcVnRectangle_UDINT_Params params(stRoi, ipDestImage, hrPrev);

		libraryInfo.functions[679 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct Sigmoid_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			float fShift;
			float fSteepness;
			HRESULT hrPrev;
			HRESULT retVal;

			Sigmoid_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, float fShift, float fSteepness, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fShift(fShift), fSteepness(fSteepness), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply the logistic function 1 / (1 + exp(-fSteepness * (x - fShift))) element-wise to a single- or multi-channel REAL image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (REAL)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fShift">Determines the intensity level around which the logistic function transitions.</param>
	/// <param name="fSteepness">Controls the sharpness of the transition.</param>
	/// <returns>HRESULT</returns>
	static HRESULT Sigmoid(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, float fShift = 0.0f, float fSteepness = 1.0f)
	{
		Internal::Sigmoid_Params params(ipSrcImage, ipDestImage, fShift, fSteepness, hrPrev);

		libraryInfo.functions[680 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SobelFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ETcVnElementType eDestDepth;
			ULONG nXOrder;
			ULONG nYOrder;
			ULONG nKernelSize;
			double fScale;
			double fDelta;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			SobelFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, ULONG nXOrder, ULONG nYOrder, ULONG nKernelSize, double fScale, double fDelta, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), eDestDepth(eDestDepth), nXOrder(nXOrder), nYOrder(nYOrder), nKernelSize(nKernelSize), fScale(fScale), fDelta(fDelta), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculates the first, second, third, or mixed image derivatives using an extended Sobel filter. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="eDestDepth">Destination image depth</param>
	/// <param name="nXOrder">Order of the x-derivative (must be &lt; nKernelSize)</param>
	/// <param name="nYOrder">Order of the y-derivative (must be &lt; nKernelSize)</param>
	/// <param name="nKernelSize">Size of the extended Sobel kernel (3, 5, 7, ..., 31)</param>
	/// <param name="fScale">Scale factor for the computed derivative values</param>
	/// <param name="fDelta">Delta value that is added to the results prior to storing them in dest</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT SobelFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ETcVnElementType eDestDepth, ULONG nXOrder, ULONG nYOrder, ULONG nKernelSize = 3, double fScale = 1, double fDelta = 0, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::SobelFilter_Params params(ipSrcImage, ipDestImage, eDestDepth, nXOrder, nYOrder, nKernelSize, fScale, fDelta, eBorderType, hrPrev);

		libraryInfo.functions[681 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SoftMax_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			bool bFlatten;
			HRESULT hrPrev;
			HRESULT retVal;

			SoftMax_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, bool bFlatten, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), bFlatten(bFlatten), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply softmax function pixel-wise to a single channel REAL image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (REAL, 1 channel)</param>
	/// <param name="ipDestImage">Destination image (An appropriate single channel destination image will be created if required.)</param>
	/// <param name="bFlatten">If true, the resulting image will be reshaped into a single row.</param>
	/// <returns>HRESULT</returns>
	static HRESULT SoftMax(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, bool bFlatten)
	{
		Internal::SoftMax_Params params(ipSrcImage, ipDestImage, bFlatten, hrPrev);

		libraryInfo.functions[682 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SplitImageChannels_Params
		{
			ITcVnImage* ipSrcImage;
			PVOID pDestImages;
			USHORT nArraySize;
			HRESULT hrPrev;
			HRESULT retVal;
			USHORT nImageChannels;

			SplitImageChannels_Params(ITcVnImage* ipSrcImage, PVOID pDestImages, USHORT nArraySize, HRESULT hrPrev) : ipSrcImage(ipSrcImage), pDestImages(pDestImages), nArraySize(nArraySize), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Split a multi-channel image into multiple single channel images (1 for each source image channel).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image with multiple channels</param>
	/// <param name="pDestImages">Pointer to an array of ITcVnImage (appropriate destination images will be created if required)</param>
	/// <param name="nArraySize">Number of pDestImages array elements (array must be &gt;= ipSourceImage channels)</param>
	/// <param name="nImageChannels">Actual source image channels</param>
	/// <returns>HRESULT</returns>
	static HRESULT SplitImageChannels(HRESULT hrPrev, ITcVnImage* ipSrcImage, PVOID pDestImages, USHORT nArraySize, USHORT& nImageChannels)
	{
		Internal::SplitImageChannels_Params params(ipSrcImage, pDestImages, nArraySize, hrPrev);

		libraryInfo.functions[683 - Lic0FuncsOffs].pFct(&params);

		AssignTo(nImageChannels, params.nImageChannels);

		return params.retVal;
	}

	/// <summary>
	/// Split a multi-channel image into multiple single channel images (1 for each source image channel).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image with multiple channels</param>
	/// <param name="pDestImages">Pointer to an array of ITcVnImage (appropriate destination images will be created if required)</param>
	/// <param name="nArraySize">Number of pDestImages array elements (array must be &gt;= ipSourceImage channels)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SplitImageChannels(HRESULT hrPrev, ITcVnImage* ipSrcImage, PVOID pDestImages, USHORT nArraySize)
	{
		Internal::SplitImageChannels_Params params(ipSrcImage, pDestImages, nArraySize, hrPrev);

		libraryInfo.functions[683 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct StartAbsWatchdog_Params
		{
			LONG tStop;
			ETcWatchdogAccumulationType eWatchdogAccType;
			HRESULT hrPrev;
			HRESULT retVal;

			StartAbsWatchdog_Params(LONG tStop, ETcWatchdogAccumulationType eWatchdogAccType, HRESULT hrPrev) : tStop(tStop), eWatchdogAccType(eWatchdogAccType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Start a cooperative watchdog given an absolute stop time. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="tStop">Stop time in us</param>
	/// <param name="eWatchdogAccType">Accumalation method used for combining the results of multiple functions enclosed by this watchdog</param>
	/// <returns>HRESULT</returns>
	static HRESULT StartAbsWatchdog(HRESULT hrPrev, LONG tStop, ETcWatchdogAccumulationType eWatchdogAccType = WD_ACC_TYPE_PRODUCT)
	{
		Internal::StartAbsWatchdog_Params params(tStop, eWatchdogAccType, hrPrev);

		libraryInfo.functions[684 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct StartRelWatchdog_Params
		{
			LONG tStop;
			ETcWatchdogAccumulationType eWatchdogAccType;
			HRESULT hrPrev;
			HRESULT retVal;

			StartRelWatchdog_Params(LONG tStop, ETcWatchdogAccumulationType eWatchdogAccType, HRESULT hrPrev) : tStop(tStop), eWatchdogAccType(eWatchdogAccType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Start a cooperative watchdog given a stop time relative to the current time. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="tStop">Stop time in us</param>
	/// <param name="eWatchdogAccType">Accumalation method used for combining the results of multiple functions enclosed by this watchdog</param>
	/// <returns>HRESULT</returns>
	static HRESULT StartRelWatchdog(HRESULT hrPrev, LONG tStop, ETcWatchdogAccumulationType eWatchdogAccType = WD_ACC_TYPE_PRODUCT)
	{
		Internal::StartRelWatchdog_Params params(tStop, eWatchdogAccType, hrPrev);

		libraryInfo.functions[685 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct StopWatchdog_Params
		{
			HRESULT hrStartWatchdog;
			HRESULT retVal;
			ULONGLONG nFunctionsMonitored;
			ULONG nFractionProcessed;
			LONG tRest;

			StopWatchdog_Params(HRESULT hrStartWatchdog) : hrStartWatchdog(hrStartWatchdog) { }
		};
	}

	/// <summary>
	/// Stops a watchdog and provide runtime information.
	/// </summary>
	/// <param name="hrStartWatchdog">HRESULT indicating the result of the function used to start the watchdog (If SUCCEEDED(hrStartWatchdog) equals false, no operation is executed.)</param>
	/// <param name="nFunctionsMonitored">Returns the number of functions monitored</param>
	/// <param name="nFractionProcessed">Returns the fraction processed accumulated over the monitored functions in percent</param>
	/// <param name="tRest">Returns the remaining computation time in us (may be negative)</param>
	/// <returns>HRESULT</returns>
	static HRESULT StopWatchdog(HRESULT hrStartWatchdog, ULONGLONG& nFunctionsMonitored, ULONG& nFractionProcessed, LONG& tRest)
	{
		Internal::StopWatchdog_Params params(hrStartWatchdog);

		libraryInfo.functions[686 - Lic0FuncsOffs].pFct(&params);

		AssignTo(nFunctionsMonitored, params.nFunctionsMonitored);
		AssignTo(nFractionProcessed, params.nFractionProcessed);
		AssignTo(tRest, params.tRest);

		return params.retVal;
	}

	/// <summary>
	/// Stops a watchdog and provide runtime information.
	/// </summary>
	/// <param name="hrStartWatchdog">HRESULT indicating the result of the function used to start the watchdog (If SUCCEEDED(hrStartWatchdog) equals false, no operation is executed.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT StopWatchdog(HRESULT hrStartWatchdog)
	{
		Internal::StopWatchdog_Params params(hrStartWatchdog);

		libraryInfo.functions[686 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SubtractContainers_Params
		{
			ITcVnContainer* ipSrcContainer1;
			ITcVnContainer* ipSrcContainer2;
			ITcVnContainer*& ipDestContainer;
			HRESULT hrPrev;
			HRESULT retVal;

			SubtractContainers_Params(ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer, HRESULT hrPrev) : ipSrcContainer1(ipSrcContainer1), ipSrcContainer2(ipSrcContainer2), ipDestContainer(ipDestContainer), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise subtraction of two containers (same length and type).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcContainer1">Source container 1</param>
	/// <param name="ipSrcContainer2">Source container 2</param>
	/// <param name="ipDestContainer">Returns the resulting container</param>
	/// <returns>HRESULT</returns>
	static HRESULT SubtractContainers(HRESULT hrPrev, ITcVnContainer* ipSrcContainer1, ITcVnContainer* ipSrcContainer2, ITcVnContainer*& ipDestContainer)
	{
		Internal::SubtractContainers_Params params(ipSrcContainer1, ipSrcContainer2, ipDestContainer, hrPrev);

		libraryInfo.functions[687 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SubtractImageFromScalar_Params
		{
			double fScalar;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SubtractImageFromScalar_Params(double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : fScalar(fScalar), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Subtract each image pixel from a scalar value using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SubtractImageFromScalar(HRESULT hrPrev, double fScalar, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::SubtractImageFromScalar_Params params(fScalar, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[688 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SubtractImageFromVector_Params
		{
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SubtractImageFromVector_Params(TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : aVector(aVector), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Subtract each image pixel from a vector (1 element for each image channel) using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SubtractImageFromVector(HRESULT hrPrev, TcVnVector4_LREAL& aVector, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::SubtractImageFromVector_Params params(aVector, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[689 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SubtractImages_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnImage* ipSrcImage2;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SubtractImages_Params(ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipSrcImage2(ipSrcImage2), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Element-wise subtraction of two images using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">First source image (minuend)</param>
	/// <param name="ipSrcImage2">Second source image (subtrahend)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SubtractImages(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnImage* ipSrcImage2, ITcVnImage*& ipDestImage)
	{
		Internal::SubtractImages_Params params(ipSrcImage1, ipSrcImage2, ipDestImage, hrPrev);

		libraryInfo.functions[690 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SubtractScalarFromImage_Params
		{
			ITcVnImage* ipSrcImage;
			double fScalar;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SubtractScalarFromImage_Params(ITcVnImage* ipSrcImage, double fScalar, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), fScalar(fScalar), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Subtract a scalar value from each image pixel using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="fScalar">Scalar value</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SubtractScalarFromImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, double fScalar, ITcVnImage*& ipDestImage)
	{
		Internal::SubtractScalarFromImage_Params params(ipSrcImage, fScalar, ipDestImage, hrPrev);

		libraryInfo.functions[691 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SubtractVectorFromImage_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnVector4_LREAL& aVector;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			SubtractVectorFromImage_Params(ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aVector, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aVector(aVector), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Subtract a vector (1 element for each image channel) from each image pixel using saturation arithmetics.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="aVector">4-element vector (1 element for each image channel. If the image has less channels, the further vector elements are ignored.)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SubtractVectorFromImage(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnVector4_LREAL& aVector, ITcVnImage*& ipDestImage)
	{
		Internal::SubtractVectorFromImage_Params params(ipSrcImage, aVector, ipDestImage, hrPrev);

		libraryInfo.functions[692 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct Threshold_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			double fThreshold;
			double fMaxValue;
			ETcVnThresholdType eThresholdType;
			HRESULT hrPrev;
			HRESULT retVal;

			Threshold_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fThreshold, double fMaxValue, ETcVnThresholdType eThresholdType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), fThreshold(fThreshold), fMaxValue(fMaxValue), eThresholdType(eThresholdType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a fixed threshold or a dynamic threshold according to Otsu.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (For Otsu and Triangle threshold types, only 1 channel of TCVN_ET_USINT is supported)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image will be created if required.)</param>
	/// <param name="fThreshold">Fixed threshold (unused if dynamic thresholding is selected)</param>
	/// <param name="fMaxValue">Maximum pixel value</param>
	/// <param name="eThresholdType">Threshold type to be applied</param>
	/// <returns>HRESULT</returns>
	static HRESULT Threshold(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, double fThreshold, double fMaxValue, ETcVnThresholdType eThresholdType)
	{
		Internal::Threshold_Params params(ipSrcImage, ipDestImage, fThreshold, fMaxValue, eThresholdType, hrPrev);

		libraryInfo.functions[693 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainImageColor_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnColorModel*& ipColorModel;
			ULONG nDifferentColors;
			ETcVnColorTrainingMethod eMethod;
			ITcVnImage* ipMask;
			ULONG nSkipPixels;
			ETcVnClusteringAlgorithm eClusteringAlgorithm;
			LONG nMaxClusterRadius;
			bool bSingleSplitSteps;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainImageColor_Params(ITcVnImage* ipSrcImage, ITcVnColorModel*& ipColorModel, ULONG nDifferentColors, ETcVnColorTrainingMethod eMethod, ITcVnImage* ipMask, ULONG nSkipPixels, ETcVnClusteringAlgorithm eClusteringAlgorithm, LONG nMaxClusterRadius, bool bSingleSplitSteps, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipColorModel(ipColorModel), nDifferentColors(nDifferentColors), eMethod(eMethod), ipMask(ipMask), nSkipPixels(nSkipPixels), eClusteringAlgorithm(eClusteringAlgorithm), nMaxClusterRadius(nMaxClusterRadius), bSingleSplitSteps(bSingleSplitSteps), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a new color model, describing the image color. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (3 channels (RGB) of type USINT)</param>
	/// <param name="ipColorModel">Returns the color model</param>
	/// <param name="nDifferentColors">Maximum number of different colors to distinguish (if LBG is used as a clustering algorithm, the result might have less different colors, depending on nMaxClusterRadius)</param>
	/// <param name="eMethod">Color training method</param>
	/// <param name="ipMask">Optional image mask (1 channel of type USINT, set to 0 if not required)</param>
	/// <param name="nSkipPixels">Number of pixels to skip between each evaluated color sample (to achieve a better performance). 0 takes every pixel into account and tends to be more accurate.</param>
	/// <param name="eClusteringAlgorithm">Clustering algorithm</param>
	/// <param name="nMaxClusterRadius">Only used for the LBG clustering algorithm. Maximum allowed radius (&gt; 0) of a single cluster, i.e. clusters with a higher radius will be split into smaller ones, until a global number of nDifferentColors is reached.</param>
	/// <param name="bSingleSplitSteps">Only used for the LBG clustering algorithm. If true, the global optimization is always run after a single cluster has been split. If false, several clusters are split within the same step before applying the global optimization. Applying the global optimization less often is faster, but can lead to less optimal results, especially having 2 nearby clusters that could be represented by 1)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainImageColor(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnColorModel*& ipColorModel, ULONG nDifferentColors, ETcVnColorTrainingMethod eMethod = CTM_LAB, ITcVnImage* ipMask = nullptr, ULONG nSkipPixels = 0, ETcVnClusteringAlgorithm eClusteringAlgorithm = CA_KMEANSPP, LONG nMaxClusterRadius = 50, bool bSingleSplitSteps = true)
	{
		Internal::TrainImageColor_Params params(ipSrcImage, ipColorModel, nDifferentColors, eMethod, ipMask, nSkipPixels, eClusteringAlgorithm, nMaxClusterRadius, bSingleSplitSteps, hrPrev);

		libraryInfo.functions[694 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainImageColor_ITcVnMlModel_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnMlModel*& ipColorModel;
			ULONG nDifferentColors;
			ETcVnColorTrainingMethod eMethod;
			ITcVnImage* ipMask;
			ULONG nSkipPixels;
			ETcVnClusteringAlgorithm eClusteringAlgorithm;
			LONG nMaxClusterRadius;
			bool bSingleSplitSteps;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainImageColor_ITcVnMlModel_Params(ITcVnImage* ipSrcImage, ITcVnMlModel*& ipColorModel, ULONG nDifferentColors, ETcVnColorTrainingMethod eMethod, ITcVnImage* ipMask, ULONG nSkipPixels, ETcVnClusteringAlgorithm eClusteringAlgorithm, LONG nMaxClusterRadius, bool bSingleSplitSteps, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipColorModel(ipColorModel), nDifferentColors(nDifferentColors), eMethod(eMethod), ipMask(ipMask), nSkipPixels(nSkipPixels), eClusteringAlgorithm(eClusteringAlgorithm), nMaxClusterRadius(nMaxClusterRadius), bSingleSplitSteps(bSingleSplitSteps), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a new color model, describing the image color. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (3 channels (RGB) of type USINT)</param>
	/// <param name="ipColorModel">Returns the color model</param>
	/// <param name="nDifferentColors">Maximum number of different colors to distinguish (if LBG is used as a clustering algorithm, the result might have less different colors, depending on nMaxClusterRadius)</param>
	/// <param name="eMethod">Color training method</param>
	/// <param name="ipMask">Optional image mask (1 channel of type USINT, set to 0 if not required)</param>
	/// <param name="nSkipPixels">Number of pixels to skip between each evaluated color sample (to achieve a better performance). 0 takes every pixel into account and tends to be more accurate.</param>
	/// <param name="eClusteringAlgorithm">Clustering algorithm</param>
	/// <param name="nMaxClusterRadius">Only used for the LBG clustering algorithm. Maximum allowed radius (&gt; 0) of a single cluster, i.e. clusters with a higher radius will be split into smaller ones, until a global number of nDifferentColors is reached.</param>
	/// <param name="bSingleSplitSteps">Only used for the LBG clustering algorithm. If true, the global optimization is always run after a single cluster has been split. If false, several clusters are split within the same step before applying the global optimization. Applying the global optimization less often is faster, but can lead to less optimal results, especially having 2 nearby clusters that could be represented by 1)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainImageColor(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnMlModel*& ipColorModel, ULONG nDifferentColors, ETcVnColorTrainingMethod eMethod = CTM_LAB, ITcVnImage* ipMask = nullptr, ULONG nSkipPixels = 0, ETcVnClusteringAlgorithm eClusteringAlgorithm = CA_KMEANSPP, LONG nMaxClusterRadius = 50, bool bSingleSplitSteps = true)
	{
		Internal::TrainImageColor_ITcVnMlModel_Params params(ipSrcImage, ipColorModel, nDifferentColors, eMethod, ipMask, nSkipPixels, eClusteringAlgorithm, nMaxClusterRadius, bSingleSplitSteps, hrPrev);

		libraryInfo.functions[695 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TransformCoordinatesPlanar_Container_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			TransformCoordinatesPlanar_Container_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute real-world coordinates for given image points or vice versa.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Container with 2D source points (TcVnPoint2_DINT or TcVnPoint2_REAL or TcVnPoint2_LREAL)</param>
	/// <param name="ipDestPoints">Returns the transformed 2D points (TcVnPoint2_LREAL)</param>
	/// <param name="aTransformationMatrix">Transformation matrix obtained with VnCalibrateCameraPlanar() or its inverse matrix obtained with VnInvertMatrix3x3()</param>
	/// <returns>HRESULT</returns>
	static HRESULT TransformCoordinatesPlanar(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix)
	{
		Internal::TransformCoordinatesPlanar_Container_Params params(ipSrcPoints, ipDestPoints, aTransformationMatrix, hrPrev);

		libraryInfo.functions[696 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TransformCoordinatesPlanar_Point_Params
		{
			VN_TcVnPoint2_LREAL& aSrcPoint;
			VN_TcVnPoint2_LREAL& aDestPoint;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			TransformCoordinatesPlanar_Point_Params(TcVnPoint2_LREAL& aSrcPoint, TcVnPoint2_LREAL& aDestPoint, TcVnMatrix3x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : aSrcPoint(aSrcPoint), aDestPoint(aDestPoint), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute real-world coordinates for a given image point or vice versa.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcPoint">Point in the source coordinate system</param>
	/// <param name="aDestPoint">Returns point in the destination coordinate system</param>
	/// <param name="aTransformationMatrix">Transformation matrix obtained with VnCalibrateCameraPlanar() or its inverse matrix obtained with VnInvertMatrix3x3()</param>
	/// <returns>HRESULT</returns>
	static HRESULT TransformCoordinatesPlanar(HRESULT hrPrev, TcVnPoint2_LREAL& aSrcPoint, TcVnPoint2_LREAL& aDestPoint, TcVnMatrix3x3_LREAL& aTransformationMatrix)
	{
		Internal::TransformCoordinatesPlanar_Point_Params params(aSrcPoint, aDestPoint, aTransformationMatrix, hrPrev);

		libraryInfo.functions[697 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TransformIntoDisplayableImage_Params
		{
			ITcVnImage*& ipSrcImage;
			ITcVnDisplayableImage*& ipDestImage;
			bool bAllowDeepCopy;
			HRESULT hrPrev;
			HRESULT retVal;

			TransformIntoDisplayableImage_Params(ITcVnImage*& ipSrcImage, ITcVnDisplayableImage*& ipDestImage, bool bAllowDeepCopy, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), bAllowDeepCopy(bAllowDeepCopy), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transform an image into a displayable image. The source image will be released and zeroed while existing destination images will be released and overwritten with the function result. If bAllowDeepCopy equals false, the source image must not be used anywhere else and the transformation is always very fast. Otherwise, if bAllowDeepCopy equals true, a deep copy of the source image might be created if required, which will result in a longer execution time. If you want to use ipSrcImage after this function call, use F_VN_CopyIntoDisplayableImage instead. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Returns the displayable image</param>
	/// <param name="bAllowDeepCopy">Allow deep image copies, if required</param>
	/// <returns>HRESULT</returns>
	static HRESULT TransformIntoDisplayableImage(HRESULT hrPrev, ITcVnImage*& ipSrcImage, ITcVnDisplayableImage*& ipDestImage, bool bAllowDeepCopy = false)
	{
		Internal::TransformIntoDisplayableImage_Params params(ipSrcImage, ipDestImage, bAllowDeepCopy, hrPrev);

		libraryInfo.functions[698 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct UpdateTimestamp_Params
		{
			ITcUnknown* ipUnknown;
			HRESULT hrPrev;
			HRESULT retVal;

			UpdateTimestamp_Params(ITcUnknown* ipUnknown, HRESULT hrPrev) : ipUnknown(ipUnknown), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Update the timestamp of an object to the actual DC time (e.g. ITcVnImage or ITcVnContainer)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipUnknown">An object implementing ITcUnknown and ITcVnTimestamp (e.g. ITcVnImage or ITcVnContainer)</param>
	/// <returns>HRESULT</returns>
	static HRESULT UpdateTimestamp(HRESULT hrPrev, ITcUnknown* ipUnknown)
	{
		Internal::UpdateTimestamp_Params params(ipUnknown, hrPrev);

		libraryInfo.functions[699 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct UprightBoundingRectangle_Params
		{
			ITcVnContainer* ipPointSet;
			TcVnRectangle_UDINT& stRectangle;
			HRESULT hrPrev;
			HRESULT retVal;

			UprightBoundingRectangle_Params(ITcVnContainer* ipPointSet, TcVnRectangle_UDINT& stRectangle, HRESULT hrPrev) : ipPointSet(ipPointSet), stRectangle(stRectangle), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Determines the upright bounding rectangle of a set of points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet">Source point set (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the individual points.)</param>
	/// <param name="stRectangle">Returns the determined rectangle</param>
	/// <returns>HRESULT</returns>
	static HRESULT UprightBoundingRectangle(HRESULT hrPrev, ITcVnContainer* ipPointSet, TcVnRectangle_UDINT& stRectangle)
	{
		Internal::UprightBoundingRectangle_Params params(ipPointSet, stRectangle, hrPrev);

		libraryInfo.functions[700 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct UprightInnerRectangle_Params
		{
			ITcVnImage* ipSrcImage;
			TcVnRectangle_DINT& stRectangle;
			LONG nDownScaleFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			UprightInnerRectangle_Params(ITcVnImage* ipSrcImage, TcVnRectangle_DINT& stRectangle, LONG nDownScaleFactor, HRESULT hrPrev) : ipSrcImage(ipSrcImage), stRectangle(stRectangle), nDownScaleFactor(nDownScaleFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the maximum area upright inner rectangle inside an area. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, binary, values &gt; 0 mark valid area)</param>
	/// <param name="stRectangle">Returns the maximum area upright inner rectangle</param>
	/// <param name="nDownScaleFactor">To tradeoff performance vs. accuracy, a factor can be provided, to reduce the internally used image resolution. As long as invalid areas enclosed in the valid area are larger than nDownScaleFactor, the result usually still is the optimal one. Use -1 to auto select depending on ipSrcImage resolution, 0 to always use full resolution (slower but always optimal result).</param>
	/// <returns>HRESULT</returns>
	static HRESULT UprightInnerRectangle(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnRectangle_DINT& stRectangle, LONG nDownScaleFactor = -1)
	{
		Internal::UprightInnerRectangle_Params params(ipSrcImage, stRectangle, nDownScaleFactor, hrPrev);

		libraryInfo.functions[701 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct VarianceFilter_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ULONG nKernelSize;
			double fScale;
			ETcVnBorderInterpolationMethod eBorderType;
			HRESULT hrPrev;
			HRESULT retVal;

			VarianceFilter_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nKernelSize, double fScale, ETcVnBorderInterpolationMethod eBorderType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), nKernelSize(nKernelSize), fScale(fScale), eBorderType(eBorderType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculates the local variance of an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image. Only TCVN_ET_USINT Type is supported.</param>
	/// <param name="ipDestImage">Destination image of type TCVN_ET_UINT (An appropriate destination image will be created if required.)</param>
	/// <param name="nKernelSize">Size of the kernel</param>
	/// <param name="fScale">Scale factor for the computed variance values</param>
	/// <param name="eBorderType">Image border handling</param>
	/// <returns>HRESULT</returns>
	static HRESULT VarianceFilter(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ULONG nKernelSize, double fScale = 1, ETcVnBorderInterpolationMethod eBorderType = BIM_DEFAULT)
	{
		Internal::VarianceFilter_Params params(ipSrcImage, ipDestImage, nKernelSize, fScale, eBorderType, hrPrev);

		libraryInfo.functions[702 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpAffine_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpAffine_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix2x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply an affine transformation to an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpAffine(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix2x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpAffine_Params params(ipSrcImage, ipDestImage, aTransformationMatrix, hrPrev);

		libraryInfo.functions[703 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpAffine_Container_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpAffine_Container_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix2x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply an affine transformation to a container of 2D points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Source points (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_LREAL)</param>
	/// <param name="ipDestPoints">Returns the transformed points (same type ID as ipSrcPoints; Non-zero interface pointers are reused.)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpAffine(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix2x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpAffine_Container_Params params(ipSrcPoints, ipDestPoints, aTransformationMatrix, hrPrev);

		libraryInfo.functions[704 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpAffine_Point_Params
		{
			VN_TcVnPoint2_LREAL& aSrcPoint;
			VN_TcVnPoint2_LREAL& aDestPoint;
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpAffine_Point_Params(TcVnPoint2_LREAL& aSrcPoint, TcVnPoint2_LREAL& aDestPoint, TcVnMatrix2x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : aSrcPoint(aSrcPoint), aDestPoint(aDestPoint), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply an affine transformation to a 2D point.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcPoint">Source point</param>
	/// <param name="aDestPoint">Destination point</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpAffine(HRESULT hrPrev, TcVnPoint2_LREAL& aSrcPoint, TcVnPoint2_LREAL& aDestPoint, TcVnMatrix2x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpAffine_Point_Params params(aSrcPoint, aDestPoint, aTransformationMatrix, hrPrev);

		libraryInfo.functions[705 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpAffine_Rectangle_Params
		{
			ULONG nTopLeftX;
			ULONG nTopLeftY;
			ULONG nBottomRightX;
			ULONG nBottomRightY;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpAffine_Rectangle_Params(ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnContainer*& ipDestPoints, TcVnMatrix2x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : nTopLeftX(nTopLeftX), nTopLeftY(nTopLeftY), nBottomRightX(nBottomRightX), nBottomRightY(nBottomRightY), ipDestPoints(ipDestPoints), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Use an affine transform to warp a rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nTopLeftX">x coordinate of the top left corner</param>
	/// <param name="nTopLeftY">y coordinate of the top left corner</param>
	/// <param name="nBottomRightX">x coordinate of the bottom right corner</param>
	/// <param name="nBottomRightY">y coordinate of the bottom right corner</param>
	/// <param name="ipDestPoints">Returns the 4 transformed points (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpAffine(HRESULT hrPrev, ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnContainer*& ipDestPoints, TcVnMatrix2x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpAffine_Rectangle_Params params(nTopLeftX, nTopLeftY, nBottomRightX, nBottomRightY, ipDestPoints, aTransformationMatrix, hrPrev);

		libraryInfo.functions[706 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpAffineExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnMatrix2x3_LREAL& aTransformationMatrix;
			ULONG nDestWidth;
			ULONG nDestHeight;
			ETcVnInterpolationType eInterpolationType;
			bool bWarpInverse;
			ETcVnBorderInterpolationMethod eBorderInterpolation;
			double fBorderValue;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpAffineExp_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix2x3_LREAL& aTransformationMatrix, ULONG nDestWidth, ULONG nDestHeight, ETcVnInterpolationType eInterpolationType, bool bWarpInverse, ETcVnBorderInterpolationMethod eBorderInterpolation, double fBorderValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aTransformationMatrix(aTransformationMatrix), nDestWidth(nDestWidth), nDestHeight(nDestHeight), eInterpolationType(eInterpolationType), bWarpInverse(bWarpInverse), eBorderInterpolation(eBorderInterpolation), fBorderValue(fBorderValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply an affine transformation to an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="aTransformationMatrix">Affine transformation matrix</param>
	/// <param name="nDestWidth">Width of the destination image</param>
	/// <param name="nDestHeight">Height of the destination image</param>
	/// <param name="eInterpolationType">Interpolation method</param>
	/// <param name="bWarpInverse">Handle aTransformationMatrix as the inverse transformation</param>
	/// <param name="eBorderInterpolation">Border interpolation method (ISOLATED not supported)</param>
	/// <param name="fBorderValue">Border value, if CONSTANT is used</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpAffine(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix2x3_LREAL& aTransformationMatrix, ULONG nDestWidth, ULONG nDestHeight, ETcVnInterpolationType eInterpolationType, bool bWarpInverse, ETcVnBorderInterpolationMethod eBorderInterpolation, double fBorderValue)
	{
		Internal::WarpAffineExp_Params params(ipSrcImage, ipDestImage, aTransformationMatrix, nDestWidth, nDestHeight, eInterpolationType, bWarpInverse, eBorderInterpolation, fBorderValue, hrPrev);

		libraryInfo.functions[707 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpPerspective_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpPerspective_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a perspective transformation to an image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="aTransformationMatrix">Perspective transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpPerspective(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpPerspective_Params params(ipSrcImage, ipDestImage, aTransformationMatrix, hrPrev);

		libraryInfo.functions[708 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpPerspective_Container_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpPerspective_Container_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a perspective transformation to a container of 2D points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Source points (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_LREAL)</param>
	/// <param name="ipDestPoints">Returns the transformed points (same type ID as ipSrcPoints; Non-zero interface pointers are reused.)</param>
	/// <param name="aTransformationMatrix">Perspective transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpPerspective(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpPerspective_Container_Params params(ipSrcPoints, ipDestPoints, aTransformationMatrix, hrPrev);

		libraryInfo.functions[709 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpPerspective_Point_Params
		{
			VN_TcVnPoint2_LREAL& aSrcPoint;
			VN_TcVnPoint2_LREAL& aDestPoint;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpPerspective_Point_Params(TcVnPoint2_LREAL& aSrcPoint, TcVnPoint2_LREAL& aDestPoint, TcVnMatrix3x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : aSrcPoint(aSrcPoint), aDestPoint(aDestPoint), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a perspective transformation to a 2D point.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcPoint">Source point</param>
	/// <param name="aDestPoint">Destination point</param>
	/// <param name="aTransformationMatrix">Perspective transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpPerspective(HRESULT hrPrev, TcVnPoint2_LREAL& aSrcPoint, TcVnPoint2_LREAL& aDestPoint, TcVnMatrix3x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpPerspective_Point_Params params(aSrcPoint, aDestPoint, aTransformationMatrix, hrPrev);

		libraryInfo.functions[710 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpPerspective_Rectangle_Params
		{
			ULONG nTopLeftX;
			ULONG nTopLeftY;
			ULONG nBottomRightX;
			ULONG nBottomRightY;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpPerspective_Rectangle_Params(ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix, HRESULT hrPrev) : nTopLeftX(nTopLeftX), nTopLeftY(nTopLeftY), nBottomRightX(nBottomRightX), nBottomRightY(nBottomRightY), ipDestPoints(ipDestPoints), aTransformationMatrix(aTransformationMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Use a perspective transform to warp a rectangle.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="nTopLeftX">x coordinate of the top left corner</param>
	/// <param name="nTopLeftY">y coordinate of the top left corner</param>
	/// <param name="nBottomRightX">x coordinate of the bottom right corner</param>
	/// <param name="nBottomRightY">y coordinate of the bottom right corner</param>
	/// <param name="ipDestPoints">Returns the 4 transformed points (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aTransformationMatrix">Perspective transformation matrix</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpPerspective(HRESULT hrPrev, ULONG nTopLeftX, ULONG nTopLeftY, ULONG nBottomRightX, ULONG nBottomRightY, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aTransformationMatrix)
	{
		Internal::WarpPerspective_Rectangle_Params params(nTopLeftX, nTopLeftY, nBottomRightX, nBottomRightY, ipDestPoints, aTransformationMatrix, hrPrev);

		libraryInfo.functions[711 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WarpPerspectiveExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnMatrix3x3_LREAL& aTransformationMatrix;
			ULONG nDestWidth;
			ULONG nDestHeight;
			ETcVnInterpolationType eInterpolationType;
			bool bWarpInverse;
			ETcVnBorderInterpolationMethod eBorderInterpolation;
			double fBorderValue;
			HRESULT hrPrev;
			HRESULT retVal;

			WarpPerspectiveExp_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aTransformationMatrix, ULONG nDestWidth, ULONG nDestHeight, ETcVnInterpolationType eInterpolationType, bool bWarpInverse, ETcVnBorderInterpolationMethod eBorderInterpolation, double fBorderValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aTransformationMatrix(aTransformationMatrix), nDestWidth(nDestWidth), nDestHeight(nDestHeight), eInterpolationType(eInterpolationType), bWarpInverse(bWarpInverse), eBorderInterpolation(eBorderInterpolation), fBorderValue(fBorderValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a perspective transformation to an image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (An appropriate image will be created if required.)</param>
	/// <param name="aTransformationMatrix">Perspective transformation matrix</param>
	/// <param name="nDestWidth">Width of the destination image</param>
	/// <param name="nDestHeight">Height of the destination image</param>
	/// <param name="eInterpolationType">Interpolation method</param>
	/// <param name="bWarpInverse">Handle aTransformationMatrix as the inverse transformation</param>
	/// <param name="eBorderInterpolation">Border interpolation method (ISOLATED not supported)</param>
	/// <param name="fBorderValue">Border value, if CONSTANT is used</param>
	/// <returns>HRESULT</returns>
	static HRESULT WarpPerspective(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aTransformationMatrix, ULONG nDestWidth, ULONG nDestHeight, ETcVnInterpolationType eInterpolationType, bool bWarpInverse, ETcVnBorderInterpolationMethod eBorderInterpolation, double fBorderValue)
	{
		Internal::WarpPerspectiveExp_Params params(ipSrcImage, ipDestImage, aTransformationMatrix, nDestWidth, nDestHeight, eInterpolationType, bWarpInverse, eBorderInterpolation, fBorderValue, hrPrev);

		libraryInfo.functions[712 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WatershedSegmentationExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			ITcVnImage* ipMarkers;
			HRESULT hrPrev;
			HRESULT retVal;

			WatershedSegmentationExp_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMarkers, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), ipMarkers(ipMarkers), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a marker-based watershed segmentation. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 3 channels)</param>
	/// <param name="ipDestImage">Destination image (DINT, 1 channel. An appropriate image will be created if required.)</param>
	/// <param name="ipMarkers">Marker image (DINT, 1 channel)</param>
	/// <returns>HRESULT</returns>
	static HRESULT WatershedSegmentation(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, ITcVnImage* ipMarkers)
	{
		Internal::WatershedSegmentationExp_Params params(ipSrcImage, ipDestImage, ipMarkers, hrPrev);

		libraryInfo.functions[713 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct WhiteBalance_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage** pipDestImage;
			float& fRatioRed;
			float& fRatioBlue;
			ULONG nMaxValue;
			HRESULT hrPrev;
			HRESULT retVal;

			WhiteBalance_Params(ITcVnImage* ipSrcImage, ITcVnImage** pipDestImage, float& fRatioRed, float& fRatioBlue, ULONG nMaxValue, HRESULT hrPrev) : ipSrcImage(ipSrcImage), pipDestImage(pipDestImage), fRatioRed(fRatioRed), fRatioBlue(fRatioBlue), nMaxValue(nMaxValue), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculates the white balance ratios for a RGB image. Uses the green channel as a reference and computes the relative ratios for the red and blue channels. Requires a non-reflecting, not overexposed white colored object (e.g. a sheet of paper) in at least 100 pixels of the image to provide reasonable results. The resulting ratios can then be set on the camera (multiply with existing ratios), or applied in the PLC via MultiplyImageWithVector.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (3 channels (RGB), USINT or UINT)</param>
	/// <param name="pipDestImage">Destination image with white balance applied (optional, set to 0 if not required. An appropriate image will be created if required.)</param>
	/// <param name="fRatioRed">Returns the ratio for the red channel</param>
	/// <param name="fRatioBlue">Returns the ratio for the blue channel</param>
	/// <param name="nMaxValue">Specify the maximum pixel value that would be achieved by overexposure (usually 255 for 8 bit or 4095 for 12 bit data)</param>
	/// <returns>HRESULT</returns>
	static HRESULT WhiteBalance(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage** pipDestImage, float& fRatioRed, float& fRatioBlue, ULONG nMaxValue)
	{
		Internal::WhiteBalance_Params params(ipSrcImage, pipDestImage, fRatioRed, fRatioBlue, nMaxValue, hrPrev);

		libraryInfo.functions[714 - Lic0FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Vision_Code_Reading

	namespace Internal
	{
		struct ReadBarcode_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			ULONG eBarcodeType;
			HRESULT hrPrev;
			HRESULT retVal;

			ReadBarcode_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ULONG eBarcodeType, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), eBarcodeType(eBarcodeType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect and interpret a 1d barcode within the provided image. Can be canceled by Watchdog.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT elements, 1 channel or 3 channel (3 channel input is expected to be RGB and internally converted to Gray))</param>
	/// <param name="ipDecodedData">Returns the decoded code (ContainerType_Vector_String_SINT)</param>
	/// <param name="eBarcodeType">Types of barcode to search for (ETcVnBarcodeType)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadBarcode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ULONG eBarcodeType)
	{
		Internal::ReadBarcode_Params params(ipSrcImage, ipDecodedData, eBarcodeType, hrPrev);

		libraryInfo.functions[715 - Lic1FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReadBarcodeExp_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			ITcVnContainer*& ipContours;
			ULONG eBarcodeType;
			LONG nCodeNumber;
			ETcVnBarcodeSearchDirection eSearchDirection;
			ITcVnContainer** pipAngles;
			HRESULT hrPrev;
			HRESULT retVal;

			ReadBarcodeExp_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer*& ipContours, ULONG eBarcodeType, LONG nCodeNumber, ETcVnBarcodeSearchDirection eSearchDirection, ITcVnContainer** pipAngles, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), ipContours(ipContours), eBarcodeType(eBarcodeType), nCodeNumber(nCodeNumber), eSearchDirection(eSearchDirection), pipAngles(pipAngles), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect and interpret a 1d barcode within the provided image. Can be canceled by Watchdog.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT elements, 1 channel or 3 channel (3 channel input is expected to be RGB and internally converted to Gray))</param>
	/// <param name="ipDecodedData">Returns the decoded code (ContainerType_Vector_String_SINT)</param>
	/// <param name="ipContours">Returns the code positions as contours (optional, set to 0 if not required; ContainerType_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="eBarcodeType">Types of barcode to search for (ETcVnBarcodeType)</param>
	/// <param name="nCodeNumber">Number of 1d barcode that should be detected within the provided image (currently only 1 supported).</param>
	/// <param name="eSearchDirection">Barcode search direction.</param>
	/// <param name="pipAngles">Returns the clockwise code rotation angles (optional, set to 0 if not required; ContainerType_Vector_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadBarcode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer*& ipContours, ULONG eBarcodeType, LONG nCodeNumber, ETcVnBarcodeSearchDirection eSearchDirection, ITcVnContainer** pipAngles = nullptr)
	{
		Internal::ReadBarcodeExp_Params params(ipSrcImage, ipDecodedData, ipContours, eBarcodeType, nCodeNumber, eSearchDirection, pipAngles, hrPrev);

		libraryInfo.functions[716 - Lic1FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReadBarcodeRoi_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			ETcVnBarcodeType eBarcodeType;
			ETcVnBarcodeSearchDirection eSearchDirection;
			ITcVnContainer** pipContour;
			LONG nMaxScans;
			HRESULT hrPrev;
			HRESULT retVal;
			float fAngleDeg;

			ReadBarcodeRoi_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ETcVnBarcodeType eBarcodeType, ETcVnBarcodeSearchDirection eSearchDirection, ITcVnContainer** pipContour, LONG nMaxScans, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), eBarcodeType(eBarcodeType), eSearchDirection(eSearchDirection), pipContour(pipContour), nMaxScans(nMaxScans), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect and interpret a 1d barcode within the provided image. For best performance, the code should be horizontally aligned and in the image center. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="eBarcodeType">Type of the barcode (supported: CODE39, CODE128, EAN8, EAN13, ITF, UPCA, UPCE)</param>
	/// <param name="fAngleDeg">Returns the approximate clockwise rotation angle in degree</param>
	/// <param name="eSearchDirection">Barcode search direction (BSD_ANY first tries horizontal, then vertical)</param>
	/// <param name="pipContour">Returns 4 approximate code corner points, including the quiet zone. The width is accurate, but the actual height is not measured for performance reasons. Instead, it is statically set to 10% of the width, centered around the scan line that was decoded. (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_DINT)</param>
	/// <param name="nMaxScans">Maximum number of scan lines that are evaluated to find the barcode. The scan always starts at the image center and then alternates up- and downwards with increasing distance, using steps of (ipSrcImage height / nMaxScans).</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadBarcodeRoi(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ETcVnBarcodeType eBarcodeType, float& fAngleDeg, ETcVnBarcodeSearchDirection eSearchDirection = BSD_ANY, ITcVnContainer** pipContour = nullptr, LONG nMaxScans = 30)
	{
		Internal::ReadBarcodeRoi_Params params(ipSrcImage, ipDecodedData, eBarcodeType, eSearchDirection, pipContour, nMaxScans, hrPrev);

		libraryInfo.functions[717 - Lic1FuncsOffs].pFct(&params);

		AssignTo(fAngleDeg, params.fAngleDeg);

		return params.retVal;
	}

	/// <summary>
	/// Detect and interpret a 1d barcode within the provided image. For best performance, the code should be horizontally aligned and in the image center. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="eBarcodeType">Type of the barcode (supported: CODE39, CODE128, EAN8, EAN13, ITF, UPCA, UPCE)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadBarcodeRoi(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ETcVnBarcodeType eBarcodeType)
	{
		Internal::ReadBarcodeRoi_Params params(ipSrcImage, ipDecodedData, eBarcodeType, BSD_ANY, nullptr, 30, hrPrev);

		libraryInfo.functions[717 - Lic1FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReadDataMatrixCode_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			ITcVnContainer** pipContours;
			LONG nCodeNumber;
			ULONG eSearchStrategy;
			ITcVnContainer** pipAngles;
			HRESULT hrPrev;
			HRESULT retVal;

			ReadDataMatrixCode_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer** pipContours, LONG nCodeNumber, ULONG eSearchStrategy, ITcVnContainer** pipAngles, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), pipContours(pipContours), nCodeNumber(nCodeNumber), eSearchStrategy(eSearchStrategy), pipAngles(pipAngles), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect and interpret a data matrix code (ECC200) within the provided image.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT elements, 1 or 3 channels)</param>
	/// <param name="ipDecodedData">Returns the decoded code (ContainerType_Vector_String_SINT)</param>
	/// <param name="pipContours">Returns the code positions as contours (optional, set to 0 if not required; ContainerType_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="nCodeNumber">Number of data matrix codes that should be detected within the provided image. (If set to -1, it tries to detect all data matrix codes.)</param>
	/// <param name="eSearchStrategy">Used search strategy (ETcVn2dCodeSearchStrategy)</param>
	/// <param name="pipAngles">Returns the clockwise code rotation angles (optional, set to 0 if not required; ContainerType_Vector_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadDataMatrixCode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer** pipContours = nullptr, LONG nCodeNumber = 1, ULONG eSearchStrategy = CSS_DEFAULT, ITcVnContainer** pipAngles = nullptr)
	{
		Internal::ReadDataMatrixCode_Params params(ipSrcImage, ipDecodedData, pipContours, nCodeNumber, eSearchStrategy, pipAngles, hrPrev);

		libraryInfo.functions[718 - Lic1FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReadDataMatrixCodeRoi_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			float fModuleWidth;
			ITcVnContainer** pipContour;
			ULONGLONG eOptions;
			unsigned char nRows;
			unsigned char nCols;
			bool bExtensiveSearch;
			HRESULT hrPrev;
			HRESULT retVal;
			float fAngleDeg;

			ReadDataMatrixCodeRoi_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, float fModuleWidth, ITcVnContainer** pipContour, ULONGLONG eOptions, unsigned char nRows, unsigned char nCols, bool bExtensiveSearch, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), fModuleWidth(fModuleWidth), pipContour(pipContour), eOptions(eOptions), nRows(nRows), nCols(nCols), bExtensiveSearch(bExtensiveSearch), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect and interpret a data matrix code (ECC200) within the provided image. The code should be in the image center. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT elements, 1 channel)</param>
	/// <param name="ipDecodedData">Returns the decoded code (ContainerType_String_SINT)</param>
	/// <param name="fModuleWidth">Minimum module width of the code in the image (in pixels). Must be at least 3, preferably 5 - 8.</param>
	/// <param name="fAngleDeg">Returns the clockwise rotation angle in degree</param>
	/// <param name="pipContour">Returns the contour of the detected code (ContainerType_Vector_TcVnPoint2_DINT; optional, set to 0 if not required)</param>
	/// <param name="eOptions">Specifies a combination of one or more ETcVnDataMatrixOptions</param>
	/// <param name="nRows">Specifies the number of code module rows, including the finder and clock pattern, excluding the quiet zone (8 - 144; set to 0 to search for any size)</param>
	/// <param name="nCols">Specifies the number of code module columns, including the finder and clock pattern, excluding the quiet zone (10 - 144; set to 0 to search for any size)</param>
	/// <param name="bExtensiveSearch">If true, tries different approaches if the specified options fail</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadDataMatrixCodeRoi(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, float fModuleWidth, float& fAngleDeg, ITcVnContainer** pipContour = nullptr, ULONGLONG eOptions = DMO_DEFAULT, unsigned char nRows = 0, unsigned char nCols = 0, bool bExtensiveSearch = true)
	{
		Internal::ReadDataMatrixCodeRoi_Params params(ipSrcImage, ipDecodedData, fModuleWidth, pipContour, eOptions, nRows, nCols, bExtensiveSearch, hrPrev);

		libraryInfo.functions[719 - Lic1FuncsOffs].pFct(&params);

		AssignTo(fAngleDeg, params.fAngleDeg);

		return params.retVal;
	}

	/// <summary>
	/// Detect and interpret a data matrix code (ECC200) within the provided image. The code should be in the image center. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT elements, 1 channel)</param>
	/// <param name="ipDecodedData">Returns the decoded code (ContainerType_String_SINT)</param>
	/// <param name="fModuleWidth">Minimum module width of the code in the image (in pixels). Must be at least 3, preferably 5 - 8.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadDataMatrixCodeRoi(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, float fModuleWidth)
	{
		Internal::ReadDataMatrixCodeRoi_Params params(ipSrcImage, ipDecodedData, fModuleWidth, nullptr, DMO_DEFAULT, 0, 0, true, hrPrev);

		libraryInfo.functions[719 - Lic1FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReadPharmaCode_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			ITcVnContainer** pipContours;
			LONG nCodeNumber;
			SHORT nMinBarNumber;
			ITcVnContainer** pipAngles;
			HRESULT hrPrev;
			HRESULT retVal;

			ReadPharmaCode_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer** pipContours, LONG nCodeNumber, SHORT nMinBarNumber, ITcVnContainer** pipAngles, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), pipContours(pipContours), nCodeNumber(nCodeNumber), nMinBarNumber(nMinBarNumber), pipAngles(pipAngles), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect and interpret a pharma code within the provided image. Can be canceled by Watchdog.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel (all element types) or 3 channel with elements of type TCVN_ET_USINT, TCVN_ET_UINT or TCVN_ET_REAL (3 channel input is expected to be RGB and internally converted to Gray))</param>
	/// <param name="ipDecodedData">Returns the decoded code (ContainerType_Vector_String_SINT)</param>
	/// <param name="pipContours">Returns the code positions as contours (optional, set to 0 if not required; ContainerType_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="nCodeNumber">Number of pharma codes that should be detected within the provided image (currently only 1 supported).</param>
	/// <param name="nMinBarNumber">Minimal number of (dark) bars that codes must have.</param>
	/// <param name="pipAngles">Returns the clockwise code rotation angles (optional, set to 0 if not required; ContainerType_Vector_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadPharmaCode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer** pipContours = nullptr, LONG nCodeNumber = 1, SHORT nMinBarNumber = 4, ITcVnContainer** pipAngles = nullptr)
	{
		Internal::ReadPharmaCode_Params params(ipSrcImage, ipDecodedData, pipContours, nCodeNumber, nMinBarNumber, pipAngles, hrPrev);

		libraryInfo.functions[720 - Lic1FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ReadQRCode_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			ITcVnContainer** pipContours;
			LONG nCodeNumber;
			ULONG eSearchStrategy;
			ITcVnContainer** pipAngles;
			HRESULT hrPrev;
			HRESULT retVal;

			ReadQRCode_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer** pipContours, LONG nCodeNumber, ULONG eSearchStrategy, ITcVnContainer** pipAngles, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), pipContours(pipContours), nCodeNumber(nCodeNumber), eSearchStrategy(eSearchStrategy), pipAngles(pipAngles), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect and interpret a QR code within the provided image. Can be canceled by Watchdog.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT elements, 1 channel or 3 channel (3 channel input is expected to be RGB and internally converted to Gray))</param>
	/// <param name="ipDecodedData">Returns the decoded code (ContainerType_Vector_String_SINT)</param>
	/// <param name="pipContours">Returns the code positions as contours (optional, set to 0 if not required; ContainerType_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="nCodeNumber">Number of QR codes that should be detected within the provided image (currently only 1 supported).</param>
	/// <param name="eSearchStrategy">Used search strategy (ETcVn2dCodeSearchStrategy)</param>
	/// <param name="pipAngles">Returns the clockwise code rotation angles (optional, set to 0 if not required; ContainerType_Vector_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ReadQRCode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, ITcVnContainer** pipContours = nullptr, LONG nCodeNumber = 1, ULONG eSearchStrategy = CSS_DEFAULT, ITcVnContainer** pipAngles = nullptr)
	{
		Internal::ReadQRCode_Params params(ipSrcImage, ipDecodedData, pipContours, nCodeNumber, eSearchStrategy, pipAngles, hrPrev);

		libraryInfo.functions[721 - Lic1FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Vision_Code_Quality

	namespace Internal
	{
		struct GradeBarcode_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			TcVnCodeGrades1D& stCodeGrades;
			ETcVnBarcodeType eBarcodeType;
			ETcVnBarcodeSearchDirection eSearchDirection;
			ITcVnImage** pipResultVisualization;
			ITcVnContainer** pipScanLineInfo;
			ITcVnContainer** pipContour;
			HRESULT hrPrev;
			HRESULT retVal;
			float fAngleDeg;

			GradeBarcode_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGrades1D& stCodeGrades, ETcVnBarcodeType eBarcodeType, ETcVnBarcodeSearchDirection eSearchDirection, ITcVnImage** pipResultVisualization, ITcVnContainer** pipScanLineInfo, ITcVnContainer** pipContour, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), stCodeGrades(stCodeGrades), eBarcodeType(eBarcodeType), eSearchDirection(eSearchDirection), pipResultVisualization(pipResultVisualization), pipScanLineInfo(pipScanLineInfo), pipContour(pipContour), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Grades a 1D barcode according to ISO / IEC 15416:2016. Requires uniform illumination, good focus and the image sensor plane parallel to the code plane to achieve meaningful results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image, only containing the horizontally aligned barcode region (USINT, 1 channel, including quiet zones on left and right, excluding Text or empty space on more than 10% total height on top or bottom)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="stCodeGrades">Returns the code grades in the range from 0 (very bad) to 4 (very good)</param>
	/// <param name="eBarcodeType">Type of the barcode (supported: CODE39, CODE128, EAN8, EAN13, ITF, UPCA, UPCE)</param>
	/// <param name="fAngleDeg">Returns the approximate clockwise rotation angle in degree</param>
	/// <param name="eSearchDirection">Barcode search direction (BSD_ANY first tries horizontal, then vertical)</param>
	/// <param name="pipResultVisualization">Returns a visualization of the scan lines (optional, set to 0 if not required). Grades are color coded: &gt;= 3 as green, &gt;= 2 as light blue, &gt;= 1 as orange, &lt; 1 as red</param>
	/// <param name="pipScanLineInfo">Returns additional scan line info for further evaluation, e.g. to use PlotIntensityProfile for visualization (optional, set to 0 if not required; ContainerType_Vector_TcVnVector3_REAL, containing [row index, overall grade, threshold])</param>
	/// <param name="pipContour">Returns the 4 approximate code corner points, including the quiet zone (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_DINT)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GradeBarcode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGrades1D& stCodeGrades, ETcVnBarcodeType eBarcodeType, float& fAngleDeg, ETcVnBarcodeSearchDirection eSearchDirection = BSD_ANY, ITcVnImage** pipResultVisualization = nullptr, ITcVnContainer** pipScanLineInfo = nullptr, ITcVnContainer** pipContour = nullptr)
	{
		Internal::GradeBarcode_Params params(ipSrcImage, ipDecodedData, stCodeGrades, eBarcodeType, eSearchDirection, pipResultVisualization, pipScanLineInfo, pipContour, hrPrev);

		libraryInfo.functions[722 - Lic2FuncsOffs].pFct(&params);

		AssignTo(fAngleDeg, params.fAngleDeg);

		return params.retVal;
	}

	/// <summary>
	/// Grades a 1D barcode according to ISO / IEC 15416:2016. Requires uniform illumination, good focus and the image sensor plane parallel to the code plane to achieve meaningful results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image, only containing the horizontally aligned barcode region (USINT, 1 channel, including quiet zones on left and right, excluding Text or empty space on more than 10% total height on top or bottom)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="stCodeGrades">Returns the code grades in the range from 0 (very bad) to 4 (very good)</param>
	/// <param name="eBarcodeType">Type of the barcode (supported: CODE39, CODE128, EAN8, EAN13, ITF, UPCA, UPCE)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GradeBarcode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGrades1D& stCodeGrades, ETcVnBarcodeType eBarcodeType)
	{
		Internal::GradeBarcode_Params params(ipSrcImage, ipDecodedData, stCodeGrades, eBarcodeType, BSD_ANY, nullptr, nullptr, nullptr, hrPrev);

		libraryInfo.functions[722 - Lic2FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GradeDataMatrixCode_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			TcVnCodeGradesDM& stCodeGrades;
			float fModuleWidth;
			ITcVnImage** pipResultVisualization;
			ITcVnContainer** pipMarginGrades;
			ITcVnContainer** pipContour;
			HRESULT hrPrev;
			HRESULT retVal;
			float fAngleDeg;

			GradeDataMatrixCode_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGradesDM& stCodeGrades, float fModuleWidth, ITcVnImage** pipResultVisualization, ITcVnContainer** pipMarginGrades, ITcVnContainer** pipContour, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), stCodeGrades(stCodeGrades), fModuleWidth(fModuleWidth), pipResultVisualization(pipResultVisualization), pipMarginGrades(pipMarginGrades), pipContour(pipContour), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Grades a Data Matrix code (ECC200) according to ISO / IEC 15415:2011. Requires uniform illumination, good focus and the image sensor plane parallel to the code plane to achieve meaningful results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image, only containing the Data Matrix code region (USINT, 1 channel, including quiet zone)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="stCodeGrades">Returns the code grades in the range from 0 (very bad) to 4 (very good)</param>
	/// <param name="fModuleWidth">Minimum module width of the code in the image (in pixels). Must be at least 3, preferably 5 - 8.</param>
	/// <param name="fAngleDeg">Returns the clockwise rotation angle in degree</param>
	/// <param name="pipResultVisualization">Returns a visualization of the scan grid (optional, set to 0 if not required). Module margin grades are color coded: &gt;= 3 as green, &gt;= 2 as light blue, &gt;= 1 as orange, &lt; 1 as red</param>
	/// <param name="pipMarginGrades">Returns the individual margin grade for each module, e.g. to create a custom visualization (optional, set to 0 if not required; ContainerType_Vector_TcVnVector3_REAL, containing [x-position, y-position, grade])</param>
	/// <param name="pipContour">Returns the 4 code corner points, excluding the quiet zone (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_DINT)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GradeDataMatrixCode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGradesDM& stCodeGrades, float fModuleWidth, float& fAngleDeg, ITcVnImage** pipResultVisualization = nullptr, ITcVnContainer** pipMarginGrades = nullptr, ITcVnContainer** pipContour = nullptr)
	{
		Internal::GradeDataMatrixCode_Params params(ipSrcImage, ipDecodedData, stCodeGrades, fModuleWidth, pipResultVisualization, pipMarginGrades, pipContour, hrPrev);

		libraryInfo.functions[723 - Lic2FuncsOffs].pFct(&params);

		AssignTo(fAngleDeg, params.fAngleDeg);

		return params.retVal;
	}

	/// <summary>
	/// Grades a Data Matrix code (ECC200) according to ISO / IEC 15415:2011. Requires uniform illumination, good focus and the image sensor plane parallel to the code plane to achieve meaningful results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image, only containing the Data Matrix code region (USINT, 1 channel, including quiet zone)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="stCodeGrades">Returns the code grades in the range from 0 (very bad) to 4 (very good)</param>
	/// <param name="fModuleWidth">Minimum module width of the code in the image (in pixels). Must be at least 3, preferably 5 - 8.</param>
	/// <returns>HRESULT</returns>
	static HRESULT GradeDataMatrixCode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGradesDM& stCodeGrades, float fModuleWidth)
	{
		Internal::GradeDataMatrixCode_Params params(ipSrcImage, ipDecodedData, stCodeGrades, fModuleWidth, nullptr, nullptr, nullptr, hrPrev);

		libraryInfo.functions[723 - Lic2FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GradeQRCode_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDecodedData;
			TcVnCodeGradesQR& stCodeGrades;
			float fModuleWidth;
			ITcVnImage** pipResultVisualization;
			ITcVnContainer** pipMarginGrades;
			ITcVnContainer** pipContour;
			HRESULT hrPrev;
			HRESULT retVal;
			float fAngleDeg;

			GradeQRCode_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGradesQR& stCodeGrades, float fModuleWidth, ITcVnImage** pipResultVisualization, ITcVnContainer** pipMarginGrades, ITcVnContainer** pipContour, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDecodedData(ipDecodedData), stCodeGrades(stCodeGrades), fModuleWidth(fModuleWidth), pipResultVisualization(pipResultVisualization), pipMarginGrades(pipMarginGrades), pipContour(pipContour), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Grades a QR code according to ISO / IEC 15415:2011. Requires uniform illumination, good focus and the image sensor plane parallel to the code plane to achieve meaningful results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image, only containing the QR code region (USINT, 1 channel, including quiet zone)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="stCodeGrades">Returns the code grades in the range from 0 (very bad) to 4 (very good)</param>
	/// <param name="fModuleWidth">Minimum module width of the code in the image (in pixels). Must be at least 3, preferably 5 - 8.</param>
	/// <param name="fAngleDeg">Returns the clockwise rotation angle in degree</param>
	/// <param name="pipResultVisualization">Returns a visualization of the scan grid (optional, set to 0 if not required). Module margin grades are color coded: &gt;= 3 as green, &gt;= 2 as light blue, &gt;= 1 as orange, &lt; 1 as red</param>
	/// <param name="pipMarginGrades">Returns the individual margin grade for each module, e.g. to create a custom visualization (optional, set to 0 if not required; ContainerType_Vector_TcVnVector3_REAL, containing [x-position, y-position, grade])</param>
	/// <param name="pipContour">Returns the 4 code corner points, excluding the quiet zone (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_DINT)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GradeQRCode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGradesQR& stCodeGrades, float fModuleWidth, float& fAngleDeg, ITcVnImage** pipResultVisualization = nullptr, ITcVnContainer** pipMarginGrades = nullptr, ITcVnContainer** pipContour = nullptr)
	{
		Internal::GradeQRCode_Params params(ipSrcImage, ipDecodedData, stCodeGrades, fModuleWidth, pipResultVisualization, pipMarginGrades, pipContour, hrPrev);

		libraryInfo.functions[724 - Lic2FuncsOffs].pFct(&params);

		AssignTo(fAngleDeg, params.fAngleDeg);

		return params.retVal;
	}

	/// <summary>
	/// Grades a QR code according to ISO / IEC 15415:2011. Requires uniform illumination, good focus and the image sensor plane parallel to the code plane to achieve meaningful results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image, only containing the QR code region (USINT, 1 channel, including quiet zone)</param>
	/// <param name="ipDecodedData">Returns the decoded data (ContainerType_String_SINT)</param>
	/// <param name="stCodeGrades">Returns the code grades in the range from 0 (very bad) to 4 (very good)</param>
	/// <param name="fModuleWidth">Minimum module width of the code in the image (in pixels). Must be at least 3, preferably 5 - 8.</param>
	/// <returns>HRESULT</returns>
	static HRESULT GradeQRCode(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDecodedData, TcVnCodeGradesQR& stCodeGrades, float fModuleWidth)
	{
		Internal::GradeQRCode_Params params(ipSrcImage, ipDecodedData, stCodeGrades, fModuleWidth, nullptr, nullptr, nullptr, hrPrev);

		libraryInfo.functions[724 - Lic2FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Vision_Metrology_2D

	namespace Internal
	{
		struct AdjustSearchWindowOrientationToLinearEdge_Params
		{
			ITcVnImage* ipSrcImage;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nMaxThickness;
			ULONG nSearchLines;
			HRESULT hrPrev;
			HRESULT retVal;

			AdjustSearchWindowOrientationToLinearEdge_Params(ITcVnImage* ipSrcImage, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nMaxThickness, ULONG nSearchLines, HRESULT hrPrev) : ipSrcImage(ipSrcImage), aStartPoint(aStartPoint), aEndPoint(aEndPoint), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nMaxThickness(nMaxThickness), nSearchLines(nSearchLines), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Adjust the search window to be orthogonal to a linear edge. Might be helpful before calling edge localization and distance measurement functions that rely on the search window.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="aStartPoint">Position from which to start the search process (in the direction of aEndPoint), which is not changed</param>
	/// <param name="aEndPoint">Position where the search process ends, which is adjusted by this function</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (3, 5, 7, ...), centered around the line specified by aStartPoint and aEndPoint</param>
	/// <returns>HRESULT</returns>
	static HRESULT AdjustSearchWindowOrientationToLinearEdge(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nMaxThickness, ULONG nSearchLines)
	{
		Internal::AdjustSearchWindowOrientationToLinearEdge_Params params(ipSrcImage, aStartPoint, aEndPoint, eEdgeDirection, fMinStrength, nMaxThickness, nSearchLines, hrPrev);

		libraryInfo.functions[725 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CalibrateCamera_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer* ipReferencePoints;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double& fReprojError;
			TcVnParamsBlobDetection& stBlobDetectionParams;
			TcVnCameraCalibrationOptions& stCalibrationOptions;
			HRESULT hrPrev;
			HRESULT retVal;

			CalibrateCamera_Params(ITcVnImage* ipSrcImage, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnParamsBlobDetection& stBlobDetectionParams, TcVnCameraCalibrationOptions& stCalibrationOptions, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipReferencePoints(ipReferencePoints), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fReprojError(fReprojError), stBlobDetectionParams(stBlobDetectionParams), stCalibrationOptions(stCalibrationOptions), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute the camera parameters (intrinsic + extrinsic) by evaluating an image containing a calibration pattern (circles).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image containing a calibration pattern (1 channel, USINT elements)</param>
	/// <param name="ipReferencePoints">Reference calibration pattern point positions (ContainerType_Vector_TcVnPoint3_REAL)</param>
	/// <param name="aCameraMatrix">Returns the camera matrix</param>
	/// <param name="aDistortionCoefficients">Returns the lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">Returns the rotation matrix</param>
	/// <param name="aTranslationVector">Returns the translation vector</param>
	/// <param name="fReprojError">Returns the reprojection error</param>
	/// <param name="stBlobDetectionParams">Parameters for the internally used F_VN_DetectBlobs function</param>
	/// <param name="stCalibrationOptions">Calibration options</param>
	/// <returns>HRESULT</returns>
	static HRESULT CalibrateCamera(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnParamsBlobDetection& stBlobDetectionParams, TcVnCameraCalibrationOptions& stCalibrationOptions)
	{
		Internal::CalibrateCamera_Params params(ipSrcImage, ipReferencePoints, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fReprojError, stBlobDetectionParams, stCalibrationOptions, hrPrev);

		libraryInfo.functions[726 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CalibrateCameraExp_Params
		{
			PVOID pSrcImages;
			USHORT nSrcArraySize;
			ITcVnContainer* ipReferencePoints;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double& fReprojError;
			TcVnParamsBlobDetection& stBlobDetectionParams;
			TcVnCameraCalibrationOptions& stCalibrationOptions;
			bool bSubpixelAccuracy;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nMaxThickness;
			ULONG nSubpixelsIterations;
			ULONG nSearchLines;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			ETcVnWorldCoordinateSystem eWorldSystem;
			HRESULT hrPrev;
			HRESULT retVal;

			CalibrateCameraExp_Params(PVOID pSrcImages, USHORT nSrcArraySize, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnParamsBlobDetection& stBlobDetectionParams, TcVnCameraCalibrationOptions& stCalibrationOptions, bool bSubpixelAccuracy, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nMaxThickness, ULONG nSubpixelsIterations, ULONG nSearchLines, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, ETcVnWorldCoordinateSystem eWorldSystem, HRESULT hrPrev) : pSrcImages(pSrcImages), nSrcArraySize(nSrcArraySize), ipReferencePoints(ipReferencePoints), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fReprojError(fReprojError), stBlobDetectionParams(stBlobDetectionParams), stCalibrationOptions(stCalibrationOptions), bSubpixelAccuracy(bSubpixelAccuracy), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nMaxThickness(nMaxThickness), nSubpixelsIterations(nSubpixelsIterations), nSearchLines(nSearchLines), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), eWorldSystem(eWorldSystem), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute the camera parameters (intrinsic + extrinsic) by evaluating images containing a calibration pattern (circles). The extrinsic parameters are computed for the first image in the array. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="pSrcImages">Pointer to an array of source images, each containing the same calibration pattern (1 channel, USINT elements)</param>
	/// <param name="nSrcArraySize">pSrcImages array size</param>
	/// <param name="ipReferencePoints">Reference calibration pattern point positions (ContainerType_Vector_TcVnPoint3_REAL)</param>
	/// <param name="aCameraMatrix">Returns the camera matrix</param>
	/// <param name="aDistortionCoefficients">Returns the lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">Returns the rotation matrix</param>
	/// <param name="aTranslationVector">Returns the translation vector</param>
	/// <param name="fReprojError">Returns the reprojection error</param>
	/// <param name="stBlobDetectionParams">Parameters for the internally used F_VN_DetectBlobs function</param>
	/// <param name="stCalibrationOptions">Calibration options</param>
	/// <param name="bSubpixelAccuracy">If true, the pattern points are detected with subpixel accuracy</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for (from center to outside ellipse)</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="nSearchLines">Specifies the amount of search lines, which are equally distributed in all directions (must be &gt;= 8 and a multiple of 4)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="eWorldSystem">World coordinate system orientation</param>
	/// <returns>HRESULT</returns>
	static HRESULT CalibrateCamera(HRESULT hrPrev, PVOID pSrcImages, USHORT nSrcArraySize, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnParamsBlobDetection& stBlobDetectionParams, TcVnCameraCalibrationOptions& stCalibrationOptions, bool bSubpixelAccuracy = false, ETcVnEdgeDirection eEdgeDirection = ED_DARK_TO_LIGHT, float fMinStrength = 50, ULONG nMaxThickness = 10, ULONG nSubpixelsIterations = 10, ULONG nSearchLines = 92, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, ETcVnWorldCoordinateSystem eWorldSystem = WCS_X_RIGHT_Y_DOWN)
	{
		Internal::CalibrateCameraExp_Params params(pSrcImages, nSrcArraySize, ipReferencePoints, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fReprojError, stBlobDetectionParams, stCalibrationOptions, bSubpixelAccuracy, eEdgeDirection, fMinStrength, nMaxThickness, nSubpixelsIterations, nSearchLines, fApproxPrecision, eAlgorithm, eWorldSystem, hrPrev);

		libraryInfo.functions[727 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CalibrateCameraManually_Params
		{
			ITcVnContainer* ipImagePoints;
			ULONG nImageWidth;
			ULONG nImageHeight;
			ITcVnContainer* ipReferencePoints;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double& fReprojError;
			TcVnCameraCalibrationOptions& stCalibrationOptions;
			ETcVnWorldCoordinateSystem eWorldSystem;
			HRESULT hrPrev;
			HRESULT retVal;

			CalibrateCameraManually_Params(ITcVnContainer* ipImagePoints, ULONG nImageWidth, ULONG nImageHeight, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnCameraCalibrationOptions& stCalibrationOptions, ETcVnWorldCoordinateSystem eWorldSystem, HRESULT hrPrev) : ipImagePoints(ipImagePoints), nImageWidth(nImageWidth), nImageHeight(nImageHeight), ipReferencePoints(ipReferencePoints), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fReprojError(fReprojError), stCalibrationOptions(stCalibrationOptions), eWorldSystem(eWorldSystem), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute the camera parameters (intrinsic + extrinsic). The extrinsic parameters are computed for the first inner container. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImagePoints">Provided image points of multiple images (ContainerType_Vector_Vector_TcVnPoint2_REAL, each inner container with at least 6 points). The container and point order must match ipReferencePoints.</param>
	/// <param name="nImageWidth">Image width</param>
	/// <param name="nImageHeight">Image height</param>
	/// <param name="ipReferencePoints">Reference world points (ContainerType_Vector_Vector_TcVnPoint3_REAL). The number of inner containers and their amount of points must match ipImagePoints.</param>
	/// <param name="aCameraMatrix">Returns the camera matrix</param>
	/// <param name="aDistortionCoefficients">Returns the lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">Returns the rotation matrix (for the first inner container)</param>
	/// <param name="aTranslationVector">Returns the translation vector (for the first inner container)</param>
	/// <param name="fReprojError">Returns the reprojection error</param>
	/// <param name="stCalibrationOptions">Calibration options</param>
	/// <param name="eWorldSystem">World coordinate system orientation</param>
	/// <returns>HRESULT</returns>
	static HRESULT CalibrateCameraManually(HRESULT hrPrev, ITcVnContainer* ipImagePoints, ULONG nImageWidth, ULONG nImageHeight, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnCameraCalibrationOptions& stCalibrationOptions, ETcVnWorldCoordinateSystem eWorldSystem = WCS_X_RIGHT_Y_DOWN)
	{
		Internal::CalibrateCameraManually_Params params(ipImagePoints, nImageWidth, nImageHeight, ipReferencePoints, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fReprojError, stCalibrationOptions, eWorldSystem, hrPrev);

		libraryInfo.functions[728 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CalibrateLinescanCamera_Params
		{
			PVOID pSrcImages;
			USHORT nSrcArraySize;
			ITcVnContainer* ipPatternLineOrigins;
			double fSlopeRad;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double& fReprojError;
			TcVnCameraCalibrationOptions& stCalibrationOptions;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nMaxSearchLines;
			ULONG nMaxThickness;
			ULONG nSubpixelsIterations;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			HRESULT hrPrev;
			HRESULT retVal;

			CalibrateLinescanCamera_Params(PVOID pSrcImages, USHORT nSrcArraySize, ITcVnContainer* ipPatternLineOrigins, double fSlopeRad, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnCameraCalibrationOptions& stCalibrationOptions, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nMaxSearchLines, ULONG nMaxThickness, ULONG nSubpixelsIterations, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, HRESULT hrPrev) : pSrcImages(pSrcImages), nSrcArraySize(nSrcArraySize), ipPatternLineOrigins(ipPatternLineOrigins), fSlopeRad(fSlopeRad), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fReprojError(fReprojError), stCalibrationOptions(stCalibrationOptions), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nMaxSearchLines(nMaxSearchLines), nMaxThickness(nMaxThickness), nSubpixelsIterations(nSubpixelsIterations), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute the camera parameters (intrinsic + extrinsic) by evaluating images containing a line calibration pattern. The pattern must consist of alternating vertical and diagonal lines, with each diagonal having the same constant slope: |\|\|...\|. The results are only valid for the x-direction of a line scan image. To get accurate x-values for a transformation into world coordinates, the y-coordinate must be set to half the sensor width and so equal to the cy-value of the camera matrix. For other y-values, the results are approximated and can be inaccurate. The extrinsic parameters are computed for the first image in the array. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="pSrcImages">Pointer to an array of 1 or more source images (1 channel). If the images have more than 1 row, each row must contain an image of the same pattern position.</param>
	/// <param name="nSrcArraySize">pSrcImages array size</param>
	/// <param name="ipPatternLineOrigins">X position of the pattern line origins (ContainerType_Vector_REAL, usually same origin for vertical and following diagonal line)</param>
	/// <param name="fSlopeRad">Slope of the diagonal line in rad (&gt; 0, &lt; PI/2), relative to the vertical line (i.e., 0 would be a vertical line, PI/2 a horizontal line)</param>
	/// <param name="aCameraMatrix">Returns the camera matrix</param>
	/// <param name="aDistortionCoefficients">Returns the lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">Returns the rotation matrix</param>
	/// <param name="aTranslationVector">Returns the translation vector</param>
	/// <param name="fReprojError">Returns the reprojection error</param>
	/// <param name="stCalibrationOptions">Calibration options (recommended to set bFixAspectRatio, bFixPrincipalPoint, bZeroTangentDist)</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nMaxSearchLines">Maximum number of search lines (equally distributed over the image height, at most 1 searchline per image row)</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <returns>HRESULT</returns>
	static HRESULT CalibrateLinescanCamera(HRESULT hrPrev, PVOID pSrcImages, USHORT nSrcArraySize, ITcVnContainer* ipPatternLineOrigins, double fSlopeRad, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, TcVnCameraCalibrationOptions& stCalibrationOptions, ETcVnEdgeDirection eEdgeDirection, float fMinStrength = 100, ULONG nMaxSearchLines = 11, ULONG nMaxThickness = 5, ULONG nSubpixelsIterations = 50, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_APPROX_ERF)
	{
		Internal::CalibrateLinescanCamera_Params params(pSrcImages, nSrcArraySize, ipPatternLineOrigins, fSlopeRad, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fReprojError, stCalibrationOptions, eEdgeDirection, fMinStrength, nMaxSearchLines, nMaxThickness, nSubpixelsIterations, fApproxPrecision, eAlgorithm, hrPrev);

		libraryInfo.functions[729 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ClosestPointsBF_Params
		{
			ITcVnContainer* ipPointSet1;
			ITcVnContainer* ipPointSet2;
			double& fMinDist;
			VN_TcVnPoint2_LREAL& aPoint1;
			VN_TcVnPoint2_LREAL& aPoint2;
			HRESULT hrPrev;
			HRESULT retVal;

			ClosestPointsBF_Params(ITcVnContainer* ipPointSet1, ITcVnContainer* ipPointSet2, double& fMinDist, TcVnPoint2_LREAL& aPoint1, TcVnPoint2_LREAL& aPoint2, HRESULT hrPrev) : ipPointSet1(ipPointSet1), ipPointSet2(ipPointSet2), fMinDist(fMinDist), aPoint1(aPoint1), aPoint2(aPoint2), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Find the closest distance between two 2d point sets of the same type, using a brute force approach.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipPointSet1">Container with 1st set of 2d points</param>
	/// <param name="ipPointSet2">Container with 2nd set of 2d points</param>
	/// <param name="fMinDist">Returns the minimum distance between 2 points of the different point sets</param>
	/// <param name="aPoint1">Returns the point out of ipPointSet1, for which fMinDist is achieved</param>
	/// <param name="aPoint2">Returns the point out of ipPointSet2, for which fMinDist is achieved</param>
	/// <returns>HRESULT</returns>
	static HRESULT ClosestPointsBF(HRESULT hrPrev, ITcVnContainer* ipPointSet1, ITcVnContainer* ipPointSet2, double& fMinDist, TcVnPoint2_LREAL& aPoint1, TcVnPoint2_LREAL& aPoint2)
	{
		Internal::ClosestPointsBF_Params params(ipPointSet1, ipPointSet2, fMinDist, aPoint1, aPoint2, hrPrev);

		libraryInfo.functions[730 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CompensateLensDistortion_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray4_LREAL& aDistortionCoefficients;
			HRESULT hrPrev;
			HRESULT retVal;

			CompensateLensDistortion_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray4_LREAL& aDistortionCoefficients, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transforms an image to compensate the lens distortion.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (Must be different from ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <param name="aCameraMatrix">Camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2]</param>
	/// <returns>HRESULT</returns>
	static HRESULT CompensateLensDistortion(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray4_LREAL& aDistortionCoefficients)
	{
		Internal::CompensateLensDistortion_Params params(ipSrcImage, ipDestImage, aCameraMatrix, aDistortionCoefficients, hrPrev);

		libraryInfo.functions[731 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CompensateLensDistortionExp1_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			HRESULT hrPrev;
			HRESULT retVal;

			CompensateLensDistortionExp1_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transforms an image to compensate the lens distortion. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (Must be different from ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <param name="aCameraMatrix">Camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <returns>HRESULT</returns>
	static HRESULT CompensateLensDistortion(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients)
	{
		Internal::CompensateLensDistortionExp1_Params params(ipSrcImage, ipDestImage, aCameraMatrix, aDistortionCoefficients, hrPrev);

		libraryInfo.functions[732 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CompensateLensDistortionExp2_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aNewCameraMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			CompensateLensDistortionExp2_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aNewCameraMatrix, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aNewCameraMatrix(aNewCameraMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transforms an image to compensate the lens distortion. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipDestImage">Destination image (Must be different from ipSrcImage! An appropriate destination image will be created if required.)</param>
	/// <param name="aCameraMatrix">Camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aNewCameraMatrix">Allows additional scaling and shifting of the result image</param>
	/// <returns>HRESULT</returns>
	static HRESULT CompensateLensDistortion(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aNewCameraMatrix)
	{
		Internal::CompensateLensDistortionExp2_Params params(ipSrcImage, ipDestImage, aCameraMatrix, aDistortionCoefficients, aNewCameraMatrix, hrPrev);

		libraryInfo.functions[733 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CompensateLensDistortionForPoints_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray4_LREAL& aDistortionCoefficients;
			HRESULT hrPrev;
			HRESULT retVal;

			CompensateLensDistortionForPoints_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray4_LREAL& aDistortionCoefficients, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transforms point coordinates to compensate the lens distortion.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Container with source point coordinates (ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_DINT)</param>
	/// <param name="ipDestPoints">Returns a container with the transformed point coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aCameraMatrix">Camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2]</param>
	/// <returns>HRESULT</returns>
	static HRESULT CompensateLensDistortionForPoints(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray4_LREAL& aDistortionCoefficients)
	{
		Internal::CompensateLensDistortionForPoints_Params params(ipSrcPoints, ipDestPoints, aCameraMatrix, aDistortionCoefficients, hrPrev);

		libraryInfo.functions[734 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CompensateLensDistortionForPointsExp1_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			HRESULT hrPrev;
			HRESULT retVal;

			CompensateLensDistortionForPointsExp1_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transforms point coordinates to compensate the lens distortion. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Container with source point coordinates (ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_DINT)</param>
	/// <param name="ipDestPoints">Returns a container with the transformed point coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aCameraMatrix">Camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <returns>HRESULT</returns>
	static HRESULT CompensateLensDistortionForPoints(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients)
	{
		Internal::CompensateLensDistortionForPointsExp1_Params params(ipSrcPoints, ipDestPoints, aCameraMatrix, aDistortionCoefficients, hrPrev);

		libraryInfo.functions[735 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CompensateLensDistortionForPointsExp2_Params
		{
			ITcVnContainer* ipSrcPoints;
			ITcVnContainer*& ipDestPoints;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aNewCameraMatrix;
			HRESULT hrPrev;
			HRESULT retVal;

			CompensateLensDistortionForPointsExp2_Params(ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aNewCameraMatrix, HRESULT hrPrev) : ipSrcPoints(ipSrcPoints), ipDestPoints(ipDestPoints), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aNewCameraMatrix(aNewCameraMatrix), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transforms point coordinates to compensate the lens distortion. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints">Container with source point coordinates (ContainerType_Vector_TcVnPoint2_REAL or ContainerType_Vector_TcVnPoint2_DINT)</param>
	/// <param name="ipDestPoints">Returns a container with the transformed point coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aCameraMatrix">Camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aNewCameraMatrix">Allows additional shifting of the result point coordinates</param>
	/// <returns>HRESULT</returns>
	static HRESULT CompensateLensDistortionForPoints(HRESULT hrPrev, ITcVnContainer* ipSrcPoints, ITcVnContainer*& ipDestPoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aNewCameraMatrix)
	{
		Internal::CompensateLensDistortionForPointsExp2_Params params(ipSrcPoints, ipDestPoints, aCameraMatrix, aDistortionCoefficients, aNewCameraMatrix, hrPrev);

		libraryInfo.functions[736 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct DetectPatternPoints_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipPatternPoints;
			TcVnParamsBlobDetection& stBlobDetectionParams;
			ULONG nNumberOfPoints;
			float fSizeDiffThresFactor;
			bool bSubpixelAccuracy;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nMaxThickness;
			ULONG nSubpixelsIterations;
			ULONG nSearchLines;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			HRESULT hrPrev;
			HRESULT retVal;

			DetectPatternPoints_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipPatternPoints, TcVnParamsBlobDetection& stBlobDetectionParams, ULONG nNumberOfPoints, float fSizeDiffThresFactor, bool bSubpixelAccuracy, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nMaxThickness, ULONG nSubpixelsIterations, ULONG nSearchLines, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipPatternPoints(ipPatternPoints), stBlobDetectionParams(stBlobDetectionParams), nNumberOfPoints(nNumberOfPoints), fSizeDiffThresFactor(fSizeDiffThresFactor), bSubpixelAccuracy(bSubpixelAccuracy), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nMaxThickness(nMaxThickness), nSubpixelsIterations(nSubpixelsIterations), nSearchLines(nSearchLines), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects calibration pattern points (circles) within the provided image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel)</param>
	/// <param name="ipPatternPoints">Returns the pattern point positions (ContainerType_Vector_TcVnPoint2_REAL; Non-zero interface pointers are reused.)</param>
	/// <param name="stBlobDetectionParams">Parameters to detect and filter contours.</param>
	/// <param name="nNumberOfPoints">Expected number of pattern points</param>
	/// <param name="fSizeDiffThresFactor">Threshold for filtering contours whose area differs from the average contour area by more than (average * fSizeDiffThresFactor)</param>
	/// <param name="bSubpixelAccuracy">If true, the pattern points are detected with subpixel accuracy</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for (from center to outside circle)</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="nSearchLines">Specifies the amount of search lines, which are equally distributed in all directions (must be &gt;= 8 and a multiple of 4)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <returns>HRESULT</returns>
	static HRESULT DetectPatternPoints(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipPatternPoints, TcVnParamsBlobDetection& stBlobDetectionParams, ULONG nNumberOfPoints, float fSizeDiffThresFactor = 0.3f, bool bSubpixelAccuracy = false, ETcVnEdgeDirection eEdgeDirection = ED_DARK_TO_LIGHT, float fMinStrength = 50, ULONG nMaxThickness = 10, ULONG nSubpixelsIterations = 10, ULONG nSearchLines = 92, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION)
	{
		Internal::DetectPatternPoints_Params params(ipSrcImage, ipPatternPoints, stBlobDetectionParams, nNumberOfPoints, fSizeDiffThresFactor, bSubpixelAccuracy, eEdgeDirection, fMinStrength, nMaxThickness, nSubpixelsIterations, nSearchLines, fApproxPrecision, eAlgorithm, hrPrev);

		libraryInfo.functions[737 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GenerateCalibrationPatternReferencePoints_Params
		{
			ITcVnContainer*& ipReferencePoints;
			ETcVnCalibrationPattern ePattern;
			ETcVnCalibrationPatternOrigin eOrigin;
			ULONG nWidth;
			ULONG nHeight;
			float fDistX;
			float fDistY;
			HRESULT hrPrev;
			HRESULT retVal;

			GenerateCalibrationPatternReferencePoints_Params(ITcVnContainer*& ipReferencePoints, ETcVnCalibrationPattern ePattern, ETcVnCalibrationPatternOrigin eOrigin, ULONG nWidth, ULONG nHeight, float fDistX, float fDistY, HRESULT hrPrev) : ipReferencePoints(ipReferencePoints), ePattern(ePattern), eOrigin(eOrigin), nWidth(nWidth), nHeight(nHeight), fDistX(fDistX), fDistY(fDistY), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Generate reference points for common calibration patterns.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipReferencePoints">Returns the generated reference points (ContainerType_Vector_TcVnPoint3_REAL)</param>
	/// <param name="ePattern">Calibration pattern type</param>
	/// <param name="eOrigin">Calibration pattern origin</param>
	/// <param name="nWidth">Pattern width, i.e. number of pattern points in x direction</param>
	/// <param name="nHeight">Pattern height, i.e. number of pattern points in y direction</param>
	/// <param name="fDistX">Distance between pattern points in x direction</param>
	/// <param name="fDistY">Distance between pattern points in y direction</param>
	/// <returns>HRESULT</returns>
	static HRESULT GenerateCalibrationPatternReferencePoints(HRESULT hrPrev, ITcVnContainer*& ipReferencePoints, ETcVnCalibrationPattern ePattern, ETcVnCalibrationPatternOrigin eOrigin, ULONG nWidth, ULONG nHeight, float fDistX, float fDistY)
	{
		Internal::GenerateCalibrationPatternReferencePoints_Params params(ipReferencePoints, ePattern, eOrigin, nWidth, nHeight, fDistX, fDistY, hrPrev);

		libraryInfo.functions[738 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ImagePointsWorldDistance_Params
		{
			VN_TcVnPoint2_REAL& aImagePoint1;
			VN_TcVnPoint2_REAL& aImagePoint2;
			double& fWorldDistance;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double fZ;
			HRESULT hrPrev;
			HRESULT retVal;

			ImagePointsWorldDistance_Params(TcVnPoint2_REAL& aImagePoint1, TcVnPoint2_REAL& aImagePoint2, double& fWorldDistance, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double fZ, HRESULT hrPrev) : aImagePoint1(aImagePoint1), aImagePoint2(aImagePoint2), fWorldDistance(fWorldDistance), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fZ(fZ), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the distance in the world coordinate system between two points (in the same world coordinate z layer) given in image coordinates.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aImagePoint1">First point in the image coordinate system</param>
	/// <param name="aImagePoint2">Second point in the image coordinate system</param>
	/// <param name="fWorldDistance">Returns the distance between aImagePoint1 and aImagePoint2 in the world coordinate system</param>
	/// <param name="aCameraMatrix">3x3 camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">3x3 rotation matrix</param>
	/// <param name="aTranslationVector">Translation vector</param>
	/// <param name="fZ">z coordinate (world coordinate system) of the given points (0 would be at (toplevel) calibration pattern)</param>
	/// <returns>HRESULT</returns>
	static HRESULT ImagePointsWorldDistance(HRESULT hrPrev, TcVnPoint2_REAL& aImagePoint1, TcVnPoint2_REAL& aImagePoint2, double& fWorldDistance, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double fZ)
	{
		Internal::ImagePointsWorldDistance_Params params(aImagePoint1, aImagePoint2, fWorldDistance, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fZ, hrPrev);

		libraryInfo.functions[739 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LocateCircularArc_Params
		{
			ITcVnImage* ipSrcImage;
			TcVnCircularArc& stCircularArc;
			VN_TcVnPoint2_REAL& aCenter;
			float fSearchRadius;
			double fArcDirectionRad;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			double fAngleStepRad;
			ULONG nMaxThickness;
			bool bInvertSearchDirection;
			ULONG nSubpixelsIterations;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			ITcVnContainer** pipContourPoints;
			float fRangeCutoffFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			LocateCircularArc_Params(ITcVnImage* ipSrcImage, TcVnCircularArc& stCircularArc, TcVnPoint2_REAL& aCenter, float fSearchRadius, double fArcDirectionRad, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, double fAngleStepRad, ULONG nMaxThickness, bool bInvertSearchDirection, ULONG nSubpixelsIterations, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, ITcVnContainer** pipContourPoints, float fRangeCutoffFactor, HRESULT hrPrev) : ipSrcImage(ipSrcImage), stCircularArc(stCircularArc), aCenter(aCenter), fSearchRadius(fSearchRadius), fArcDirectionRad(fArcDirectionRad), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), fAngleStepRad(fAngleStepRad), nMaxThickness(nMaxThickness), bInvertSearchDirection(bInvertSearchDirection), nSubpixelsIterations(nSubpixelsIterations), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), pipContourPoints(pipContourPoints), fRangeCutoffFactor(fRangeCutoffFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Locate a circular arc. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="stCircularArc">Returns the circular arc parameters</param>
	/// <param name="aCenter">Input estimated circle center (only used as a starting point to search for the circle contour, not used for the circle center estimation)</param>
	/// <param name="fSearchRadius">Input search radius (starting from aCenter, should be greater than the actual circle radius but aCenter + fSearchRadius should be within the image borders)</param>
	/// <param name="fArcDirectionRad">Input search starting direction in radian. Valid range is [-pi, +pi], where right is 0 rad, top is -pi/2 rad and bottom +pi/2 rad. The circular arc should at least be valid in range fArcDirectionRad +- 4 * fAngleStepRad)</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="fAngleStepRad">Search step in rad (should be chosen so that about 20 - 60 steps are available for the whole arc. In most cases 0.1 rad (5.7 deg) is a good value)</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="bInvertSearchDirection">If true, the search starts from outside the circular arc in direction of the center</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="pipContourPoints">Returns the subpixel accurate contour (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_REAL; Non-zero interface pointers are reused.)</param>
	/// <param name="fRangeCutoffFactor">Relative edge strength factor to cut off the range of pixels used for approximation. Negative numbers are valid to include noise, i.e. intensity differences in the other direction. At most nMaxThickness pixels are used in each direction.</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocateCircularArc(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnCircularArc& stCircularArc, TcVnPoint2_REAL& aCenter, float fSearchRadius, double fArcDirectionRad, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, double fAngleStepRad = 0.1, ULONG nMaxThickness = 10, bool bInvertSearchDirection = false, ULONG nSubpixelsIterations = 10, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, ITcVnContainer** pipContourPoints = nullptr, float fRangeCutoffFactor = 0.135f)
	{
		Internal::LocateCircularArc_Params params(ipSrcImage, stCircularArc, aCenter, fSearchRadius, fArcDirectionRad, eEdgeDirection, fMinStrength, fAngleStepRad, nMaxThickness, bInvertSearchDirection, nSubpixelsIterations, fApproxPrecision, eAlgorithm, pipContourPoints, fRangeCutoffFactor, hrPrev);

		libraryInfo.functions[740 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LocateEdge_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipEdgePoints;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nSearchLines;
			float fSearchLineDist;
			ULONG nMaxThickness;
			ULONG nSubpixelsIterations;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			float fRangeCutoffFactor;
			ITcVnContainer** pipEdgeStrengths;
			HRESULT hrPrev;
			HRESULT retVal;
			float fAvgStrength;

			LocateEdge_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipEdgePoints, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, float fSearchLineDist, ULONG nMaxThickness, ULONG nSubpixelsIterations, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, float fRangeCutoffFactor, ITcVnContainer** pipEdgeStrengths, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipEdgePoints(ipEdgePoints), aStartPoint(aStartPoint), aEndPoint(aEndPoint), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nSearchLines(nSearchLines), fSearchLineDist(fSearchLineDist), nMaxThickness(nMaxThickness), nSubpixelsIterations(nSubpixelsIterations), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), fRangeCutoffFactor(fRangeCutoffFactor), pipEdgeStrengths(pipEdgeStrengths), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Locate the points of the first occuring edge inside a specified search window with subpixel accuracy. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="ipEdgePoints">Returns the detected edge points (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aStartPoint">Position from which to start the search process (in the direction of aEndPoint)</param>
	/// <param name="aEndPoint">Position where the search process ends</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (1, 3, 5, 7, ...), centered around the line specified by aStartPoint and aEndPoint</param>
	/// <param name="fAvgStrength">Returns the average strength of the detected edge</param>
	/// <param name="fSearchLineDist">Distance between the search lines in pixels (&gt; 0)</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="fRangeCutoffFactor">Relative edge strength factor to cut off the range of pixels used for approximation. Negative numbers are valid to include noise, i.e. intensity differences in the other direction. At most nMaxThickness pixels are used in each direction.</param>
	/// <param name="pipEdgeStrengths">Returns the detected edge strengths (optional, set to 0 if not required; ContainerType_Vector_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocateEdge(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipEdgePoints, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, float& fAvgStrength, float fSearchLineDist = 1, ULONG nMaxThickness = 10, ULONG nSubpixelsIterations = 10, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, float fRangeCutoffFactor = 0.135f, ITcVnContainer** pipEdgeStrengths = nullptr)
	{
		Internal::LocateEdge_Params params(ipSrcImage, ipEdgePoints, aStartPoint, aEndPoint, eEdgeDirection, fMinStrength, nSearchLines, fSearchLineDist, nMaxThickness, nSubpixelsIterations, fApproxPrecision, eAlgorithm, fRangeCutoffFactor, pipEdgeStrengths, hrPrev);

		libraryInfo.functions[741 - Lic3FuncsOffs].pFct(&params);

		AssignTo(fAvgStrength, params.fAvgStrength);

		return params.retVal;
	}

	/// <summary>
	/// Locate the points of the first occuring edge inside a specified search window with subpixel accuracy. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="ipEdgePoints">Returns the detected edge points (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aStartPoint">Position from which to start the search process (in the direction of aEndPoint)</param>
	/// <param name="aEndPoint">Position where the search process ends</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (1, 3, 5, 7, ...), centered around the line specified by aStartPoint and aEndPoint</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocateEdge(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipEdgePoints, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines)
	{
		Internal::LocateEdge_Params params(ipSrcImage, ipEdgePoints, aStartPoint, aEndPoint, eEdgeDirection, fMinStrength, nSearchLines, 1, 10, 10, 0.001f, EDA_INTERPOLATION, 0.135f, nullptr, hrPrev);

		libraryInfo.functions[741 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LocateEdges_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipEdgePoints;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			ULONG nNumEdges;
			ETcVnEdgeDirection eEdgeDirection;
			bool bAlternateDirection;
			float fMinStrength;
			ULONG nSearchLines;
			float fSearchLineDist;
			ULONG nMaxThickness;
			ULONG nSubpixelsIterations;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			float fRangeCutoffFactor;
			ITcVnContainer** pipEdgeStrengths;
			bool bAvgEdgeStrengths;
			HRESULT hrPrev;
			HRESULT retVal;
			float fAvgStrength;

			LocateEdges_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipEdgePoints, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ULONG nNumEdges, ETcVnEdgeDirection eEdgeDirection, bool bAlternateDirection, float fMinStrength, ULONG nSearchLines, float fSearchLineDist, ULONG nMaxThickness, ULONG nSubpixelsIterations, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, float fRangeCutoffFactor, ITcVnContainer** pipEdgeStrengths, bool bAvgEdgeStrengths, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipEdgePoints(ipEdgePoints), aStartPoint(aStartPoint), aEndPoint(aEndPoint), nNumEdges(nNumEdges), eEdgeDirection(eEdgeDirection), bAlternateDirection(bAlternateDirection), fMinStrength(fMinStrength), nSearchLines(nSearchLines), fSearchLineDist(fSearchLineDist), nMaxThickness(nMaxThickness), nSubpixelsIterations(nSubpixelsIterations), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), fRangeCutoffFactor(fRangeCutoffFactor), pipEdgeStrengths(pipEdgeStrengths), bAvgEdgeStrengths(bAvgEdgeStrengths), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Locate the points of multiple occuring edges inside a specified search window with subpixel accuracy. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="ipEdgePoints">Returns the detected edge points (ContainerType_Vector_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aStartPoint">Position from which to start the search process (in the direction of aEndPoint)</param>
	/// <param name="aEndPoint">Position where the search process ends</param>
	/// <param name="nNumEdges">The (maximum) number of edges to search for</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for</param>
	/// <param name="bAlternateDirection">If true, eEdgeDirection is alternated after each detected edge. Else, only edges with eEdgeDirection are searched for.</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (1, 3, 5, 7, ...), centered around the line specified by aStartPoint and aEndPoint</param>
	/// <param name="fAvgStrength">Returns the average strength of the detected edges</param>
	/// <param name="fSearchLineDist">Distance between the search lines in pixels (&gt; 0)</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="fRangeCutoffFactor">Relative edge strength factor to cut off the range of pixels used for approximation. Negative numbers are valid to include noise, i.e. intensity differences in the other direction. At most nMaxThickness pixels are used in each direction.</param>
	/// <param name="pipEdgeStrengths">Returns the detected edge strengths (optional, set to 0 if not required; ContainerType_Vector_Vector_REAL or ContainerType_Vector_REAL, depending on bAvgEdgeStrengths)</param>
	/// <param name="bAvgEdgeStrengths">If true, ipEdgeStrengths returns the average strength per edge instead of individual strengths for each search line</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocateEdges(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipEdgePoints, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ULONG nNumEdges, ETcVnEdgeDirection eEdgeDirection, bool bAlternateDirection, float fMinStrength, ULONG nSearchLines, float& fAvgStrength, float fSearchLineDist = 1, ULONG nMaxThickness = 10, ULONG nSubpixelsIterations = 10, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, float fRangeCutoffFactor = 0.135f, ITcVnContainer** pipEdgeStrengths = nullptr, bool bAvgEdgeStrengths = false)
	{
		Internal::LocateEdges_Params params(ipSrcImage, ipEdgePoints, aStartPoint, aEndPoint, nNumEdges, eEdgeDirection, bAlternateDirection, fMinStrength, nSearchLines, fSearchLineDist, nMaxThickness, nSubpixelsIterations, fApproxPrecision, eAlgorithm, fRangeCutoffFactor, pipEdgeStrengths, bAvgEdgeStrengths, hrPrev);

		libraryInfo.functions[742 - Lic3FuncsOffs].pFct(&params);

		AssignTo(fAvgStrength, params.fAvgStrength);

		return params.retVal;
	}

	/// <summary>
	/// Locate the points of multiple occuring edges inside a specified search window with subpixel accuracy. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="ipEdgePoints">Returns the detected edge points (ContainerType_Vector_Vector_TcVnPoint2_REAL)</param>
	/// <param name="aStartPoint">Position from which to start the search process (in the direction of aEndPoint)</param>
	/// <param name="aEndPoint">Position where the search process ends</param>
	/// <param name="nNumEdges">The (maximum) number of edges to search for</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for</param>
	/// <param name="bAlternateDirection">If true, eEdgeDirection is alternated after each detected edge. Else, only edges with eEdgeDirection are searched for.</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (1, 3, 5, 7, ...), centered around the line specified by aStartPoint and aEndPoint</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocateEdges(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipEdgePoints, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ULONG nNumEdges, ETcVnEdgeDirection eEdgeDirection, bool bAlternateDirection, float fMinStrength, ULONG nSearchLines)
	{
		Internal::LocateEdges_Params params(ipSrcImage, ipEdgePoints, aStartPoint, aEndPoint, nNumEdges, eEdgeDirection, bAlternateDirection, fMinStrength, nSearchLines, 1, 10, 10, 0.001f, EDA_INTERPOLATION, 0.135f, nullptr, false, hrPrev);

		libraryInfo.functions[742 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct LocateEllipse_Params
		{
			ITcVnImage* ipSrcImage;
			TcVnRotatedRectangle& stEllipse;
			VN_TcVnPoint2_REAL& aCenter;
			float fSearchRadius;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nMaxThickness;
			bool bInvertSearchDirection;
			float fMinSearchRadius;
			ULONG nSubpixelsIterations;
			ULONG nSearchLines;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			ITcVnContainer** pipContourPoints;
			float fRangeCutoffFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			LocateEllipse_Params(ITcVnImage* ipSrcImage, TcVnRotatedRectangle& stEllipse, TcVnPoint2_REAL& aCenter, float fSearchRadius, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nMaxThickness, bool bInvertSearchDirection, float fMinSearchRadius, ULONG nSubpixelsIterations, ULONG nSearchLines, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, ITcVnContainer** pipContourPoints, float fRangeCutoffFactor, HRESULT hrPrev) : ipSrcImage(ipSrcImage), stEllipse(stEllipse), aCenter(aCenter), fSearchRadius(fSearchRadius), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nMaxThickness(nMaxThickness), bInvertSearchDirection(bInvertSearchDirection), fMinSearchRadius(fMinSearchRadius), nSubpixelsIterations(nSubpixelsIterations), nSearchLines(nSearchLines), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), pipContourPoints(pipContourPoints), fRangeCutoffFactor(fRangeCutoffFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Locate an ellipse. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="stEllipse">Returns the detected ellipse</param>
	/// <param name="aCenter">The expected ellipse center</param>
	/// <param name="fSearchRadius">Radius around aCenter to search for edges</param>
	/// <param name="eEdgeDirection">Specification of the edge direction to search for (from center to outside ellipse or other way round, if bInvertSearchDirection is true)</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="bInvertSearchDirection">If true, the search starts from outside the ellipse in direction of the center</param>
	/// <param name="fMinSearchRadius">Radius around aCenter to skip before starting to search for edges (e.g. to save time or if the center contains edges that should be ignored)</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="nSearchLines">Specifies the amount of search lines, which are equally distributed in all directions (must be &gt;= 8 and a multiple of 4)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="pipContourPoints">Returns the subpixel accurate ellipse contour (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_REAL; Non-zero interface pointers are reused.)</param>
	/// <param name="fRangeCutoffFactor">Relative edge strength factor to cut off the range of pixels used for approximation. Negative numbers are valid to include noise, i.e. intensity differences in the other direction. At most nMaxThickness pixels are used in each direction.</param>
	/// <returns>HRESULT</returns>
	static HRESULT LocateEllipse(HRESULT hrPrev, ITcVnImage* ipSrcImage, TcVnRotatedRectangle& stEllipse, TcVnPoint2_REAL& aCenter, float fSearchRadius, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nMaxThickness = 10, bool bInvertSearchDirection = false, float fMinSearchRadius = 0, ULONG nSubpixelsIterations = 10, ULONG nSearchLines = 92, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, ITcVnContainer** pipContourPoints = nullptr, float fRangeCutoffFactor = 0.135f)
	{
		Internal::LocateEllipse_Params params(ipSrcImage, stEllipse, aCenter, fSearchRadius, eEdgeDirection, fMinStrength, nMaxThickness, bInvertSearchDirection, fMinSearchRadius, nSubpixelsIterations, nSearchLines, fApproxPrecision, eAlgorithm, pipContourPoints, fRangeCutoffFactor, hrPrev);

		libraryInfo.functions[743 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MeasureAngleBetweenEdges_Params
		{
			ITcVnImage* ipSrcImage;
			float& fAngle;
			VN_TcVnPoint2_REAL& aInnerPoint;
			VN_TcVnPoint2_REAL& aOuterPoint1;
			VN_TcVnPoint2_REAL& aOuterPoint2;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nSearchLines;
			float fSearchLineDist;
			ULONG nMaxThickness;
			bool bInvertSearchDirection;
			ULONG nSubpixelsIterations;
			bool bAngleInDegrees;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			ITcVnContainer** pipEdgePoints1;
			ITcVnContainer** pipEdgePoints2;
			float fRangeCutoffFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			MeasureAngleBetweenEdges_Params(ITcVnImage* ipSrcImage, float& fAngle, TcVnPoint2_REAL& aInnerPoint, TcVnPoint2_REAL& aOuterPoint1, TcVnPoint2_REAL& aOuterPoint2, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, float fSearchLineDist, ULONG nMaxThickness, bool bInvertSearchDirection, ULONG nSubpixelsIterations, bool bAngleInDegrees, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, ITcVnContainer** pipEdgePoints1, ITcVnContainer** pipEdgePoints2, float fRangeCutoffFactor, HRESULT hrPrev) : ipSrcImage(ipSrcImage), fAngle(fAngle), aInnerPoint(aInnerPoint), aOuterPoint1(aOuterPoint1), aOuterPoint2(aOuterPoint2), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nSearchLines(nSearchLines), fSearchLineDist(fSearchLineDist), nMaxThickness(nMaxThickness), bInvertSearchDirection(bInvertSearchDirection), nSubpixelsIterations(nSubpixelsIterations), bAngleInDegrees(bAngleInDegrees), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), pipEdgePoints1(pipEdgePoints1), pipEdgePoints2(pipEdgePoints2), fRangeCutoffFactor(fRangeCutoffFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Measure the angle between 2 edges.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="fAngle">Returns the angle between the detected edges (radians or degrees, depending on bAngleInDegrees)</param>
	/// <param name="aInnerPoint">Position inside the angle to measure, from which to start the edge search process (in the direction of aOuterPoint1 and aOuterPoint2)</param>
	/// <param name="aOuterPoint1">Position where the search process for edge 1 ends</param>
	/// <param name="aOuterPoint2">Position where the search process for edge 2 ends</param>
	/// <param name="eEdgeDirection">Specification of the edge direction from aInnerPoint to aOuterPoint1 and aOuterPoint2 to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (3, 5, 7, ...), centered around the line specified by aInnerPoint and aOuterPoint1, aOuterPoint2</param>
	/// <param name="fSearchLineDist">Distance between the search lines in pixels (&gt; 0)</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="bInvertSearchDirection">If true, the search starts from each aOuterPoint in direction of aInnerPoint</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="bAngleInDegrees">fAngle is in degrees, if true</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="pipEdgePoints1">Returns the detected edge points between aInnerPoint and aOuterPoint1 (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="pipEdgePoints2">Returns the detected edge points between aInnerPoint and aOuterPoint2 (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fRangeCutoffFactor">Relative edge strength factor to cut off the range of pixels used for approximation. Negative numbers are valid to include noise, i.e. intensity differences in the other direction. At most nMaxThickness pixels are used in each direction.</param>
	/// <returns>HRESULT</returns>
	static HRESULT MeasureAngleBetweenEdges(HRESULT hrPrev, ITcVnImage* ipSrcImage, float& fAngle, TcVnPoint2_REAL& aInnerPoint, TcVnPoint2_REAL& aOuterPoint1, TcVnPoint2_REAL& aOuterPoint2, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, float fSearchLineDist = 1, ULONG nMaxThickness = 10, bool bInvertSearchDirection = false, ULONG nSubpixelsIterations = 10, bool bAngleInDegrees = false, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, ITcVnContainer** pipEdgePoints1 = nullptr, ITcVnContainer** pipEdgePoints2 = nullptr, float fRangeCutoffFactor = 0.135f)
	{
		Internal::MeasureAngleBetweenEdges_Params params(ipSrcImage, fAngle, aInnerPoint, aOuterPoint1, aOuterPoint2, eEdgeDirection, fMinStrength, nSearchLines, fSearchLineDist, nMaxThickness, bInvertSearchDirection, nSubpixelsIterations, bAngleInDegrees, fApproxPrecision, eAlgorithm, pipEdgePoints1, pipEdgePoints2, fRangeCutoffFactor, hrPrev);

		libraryInfo.functions[744 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MeasureEdgeDistance_Params
		{
			ITcVnImage* ipSrcImage;
			float& fAvgDistance;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nSearchLines;
			float fSearchLineDist;
			ULONG nMaxThickness;
			bool bInvertSearchDirection;
			float fSearchGap;
			ULONG nSubpixelsIterations;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			ITcVnContainer** pipEdgePoints1;
			ITcVnContainer** pipEdgePoints2;
			ITcVnContainer** pipDistances;
			float fRangeCutoffFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			MeasureEdgeDistance_Params(ITcVnImage* ipSrcImage, float& fAvgDistance, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, float fSearchLineDist, ULONG nMaxThickness, bool bInvertSearchDirection, float fSearchGap, ULONG nSubpixelsIterations, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, ITcVnContainer** pipEdgePoints1, ITcVnContainer** pipEdgePoints2, ITcVnContainer** pipDistances, float fRangeCutoffFactor, HRESULT hrPrev) : ipSrcImage(ipSrcImage), fAvgDistance(fAvgDistance), aStartPoint(aStartPoint), aEndPoint(aEndPoint), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nSearchLines(nSearchLines), fSearchLineDist(fSearchLineDist), nMaxThickness(nMaxThickness), bInvertSearchDirection(bInvertSearchDirection), fSearchGap(fSearchGap), nSubpixelsIterations(nSubpixelsIterations), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), pipEdgePoints1(pipEdgePoints1), pipEdgePoints2(pipEdgePoints2), pipDistances(pipDistances), fRangeCutoffFactor(fRangeCutoffFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Measure the distance between 2 parallel edges. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="fAvgDistance">Returns the average distance between the detected edges</param>
	/// <param name="aStartPoint">Position from which to start the search process (in the direction of aEndPoint)</param>
	/// <param name="aEndPoint">Position where the search process ends</param>
	/// <param name="eEdgeDirection">Specification of the edge direction from aStartPoint to aEndPoint to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (1, 3, 5, 7, ...), centered around the line specified by aStartPoint and aEndPoint</param>
	/// <param name="fSearchLineDist">Distance between the search lines in pixels (&gt; 0)</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="bInvertSearchDirection">If true, the search starts from the center point between aStartPoint and aEndPoint in both directions</param>
	/// <param name="fSearchGap">Optional width of a gap (&gt;= 0, centered between aStartPoint and aEndPoint), that is neglected for searching edges (can reduce execution time). The 2 edges to search for must be on different sides of the gap.</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="pipEdgePoints1">Returns the detected edge points of the edge near aStartPoint (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="pipEdgePoints2">Returns the detected edge points of the edge near aEndPoint (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="pipDistances">Returns the distances between the detected edge points (optional, set to 0 if not required; ContainerType_Vector_REAL)</param>
	/// <param name="fRangeCutoffFactor">Relative edge strength factor to cut off the range of pixels used for approximation. Negative numbers are valid to include noise, i.e. intensity differences in the other direction. At most nMaxThickness pixels are used in each direction.</param>
	/// <returns>HRESULT</returns>
	static HRESULT MeasureEdgeDistance(HRESULT hrPrev, ITcVnImage* ipSrcImage, float& fAvgDistance, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, float fSearchLineDist = 1, ULONG nMaxThickness = 10, bool bInvertSearchDirection = false, float fSearchGap = 0, ULONG nSubpixelsIterations = 10, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, ITcVnContainer** pipEdgePoints1 = nullptr, ITcVnContainer** pipEdgePoints2 = nullptr, ITcVnContainer** pipDistances = nullptr, float fRangeCutoffFactor = 0.135f)
	{
		Internal::MeasureEdgeDistance_Params params(ipSrcImage, fAvgDistance, aStartPoint, aEndPoint, eEdgeDirection, fMinStrength, nSearchLines, fSearchLineDist, nMaxThickness, bInvertSearchDirection, fSearchGap, nSubpixelsIterations, fApproxPrecision, eAlgorithm, pipEdgePoints1, pipEdgePoints2, pipDistances, fRangeCutoffFactor, hrPrev);

		libraryInfo.functions[745 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MeasureMinEdgeDistance_Params
		{
			ITcVnImage* ipSrcImage;
			float& fMinDistance;
			VN_TcVnPoint2_REAL& aStartPoint;
			VN_TcVnPoint2_REAL& aEndPoint;
			ETcVnEdgeDirection eEdgeDirection;
			float fMinStrength;
			ULONG nSearchLines;
			float fSearchLineDist;
			ULONG nMaxThickness;
			bool bInvertSearchDirection;
			float fSearchGap;
			ULONG nSubpixelsIterations;
			float fApproxPrecision;
			ETcVnEdgeDetectionAlgorithm eAlgorithm;
			ITcVnContainer** pipEdgePoints1;
			ITcVnContainer** pipEdgePoints2;
			VN_TcVnPoint2_REAL& aPoint1;
			VN_TcVnPoint2_REAL& aPoint2;
			float fRangeCutoffFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			MeasureMinEdgeDistance_Params(ITcVnImage* ipSrcImage, float& fMinDistance, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, float fSearchLineDist, ULONG nMaxThickness, bool bInvertSearchDirection, float fSearchGap, ULONG nSubpixelsIterations, float fApproxPrecision, ETcVnEdgeDetectionAlgorithm eAlgorithm, ITcVnContainer** pipEdgePoints1, ITcVnContainer** pipEdgePoints2, TcVnPoint2_REAL& aPoint1, TcVnPoint2_REAL& aPoint2, float fRangeCutoffFactor, HRESULT hrPrev) : ipSrcImage(ipSrcImage), fMinDistance(fMinDistance), aStartPoint(aStartPoint), aEndPoint(aEndPoint), eEdgeDirection(eEdgeDirection), fMinStrength(fMinStrength), nSearchLines(nSearchLines), fSearchLineDist(fSearchLineDist), nMaxThickness(nMaxThickness), bInvertSearchDirection(bInvertSearchDirection), fSearchGap(fSearchGap), nSubpixelsIterations(nSubpixelsIterations), fApproxPrecision(fApproxPrecision), eAlgorithm(eAlgorithm), pipEdgePoints1(pipEdgePoints1), pipEdgePoints2(pipEdgePoints2), aPoint1(aPoint1), aPoint2(aPoint2), fRangeCutoffFactor(fRangeCutoffFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Measure the minimum distance within the specified search window between 2 edges. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (1 channel)</param>
	/// <param name="fMinDistance">Returns the minimum distance between the detected edges</param>
	/// <param name="aStartPoint">Position from which to start the search process (in the direction of aEndPoint)</param>
	/// <param name="aEndPoint">Position where the search process ends</param>
	/// <param name="eEdgeDirection">Specification of the edge direction from aStartPoint to aEndPoint to search for</param>
	/// <param name="fMinStrength">Specification of the minimum strength (intensity difference) of the edge to search for</param>
	/// <param name="nSearchLines">Width of the search window, i.e. the number of search lines (1, 3, 5, 7, ...), centered around the line specified by aStartPoint and aEndPoint</param>
	/// <param name="aPoint1">Returns the point on the edge near aStartPoint, for which the minimum distance is achieved</param>
	/// <param name="aPoint2">Returns the point on the edge near aEndPoint, for which the minimum distance is achieved</param>
	/// <param name="fSearchLineDist">Distance between the search lines in pixels (&gt; 0)</param>
	/// <param name="nMaxThickness">Specification of the maximum thickness of the edge to search for, which means fMinStrength must be reached within nMaxThickness pixels</param>
	/// <param name="bInvertSearchDirection">If true, the search starts from the center point between aStartPoint and aEndPoint in both directions</param>
	/// <param name="fSearchGap">Optional width of a gap (&gt;= 0, centered between aStartPoint and aEndPoint), that is neglected for searching edges (can reduce execution time). The 2 edges to search for must be on different sides of the gap.</param>
	/// <param name="nSubpixelsIterations">Specifies the number of subpixels (for INTERPOLATION, 10 - 20 usually is sufficient) or maximum number of iterations for optimizing the parameters (for APPROX_ERF and APPROX_GAUSSIAN, 50 - 100 usually is sufficient)</param>
	/// <param name="fApproxPrecision">Specifies the approximation precision for APPROX_ERF and APPROX_GAUSSIAN (0.001 usually is sufficient, unused for INTERPOLATION)</param>
	/// <param name="eAlgorithm">Selection of the edge detection algorithm</param>
	/// <param name="pipEdgePoints1">Returns the detected edge points of the edge near aStartPoint (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="pipEdgePoints2">Returns the detected edge points of the edge near aEndPoint (optional, set to 0 if not required; ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fRangeCutoffFactor">Relative edge strength factor to cut off the range of pixels used for approximation. Negative numbers are valid to include noise, i.e. intensity differences in the other direction. At most nMaxThickness pixels are used in each direction.</param>
	/// <returns>HRESULT</returns>
	static HRESULT MeasureMinEdgeDistance(HRESULT hrPrev, ITcVnImage* ipSrcImage, float& fMinDistance, TcVnPoint2_REAL& aStartPoint, TcVnPoint2_REAL& aEndPoint, ETcVnEdgeDirection eEdgeDirection, float fMinStrength, ULONG nSearchLines, TcVnPoint2_REAL& aPoint1, TcVnPoint2_REAL& aPoint2, float fSearchLineDist = 1, ULONG nMaxThickness = 10, bool bInvertSearchDirection = false, float fSearchGap = 0, ULONG nSubpixelsIterations = 10, float fApproxPrecision = 0.001f, ETcVnEdgeDetectionAlgorithm eAlgorithm = EDA_INTERPOLATION, ITcVnContainer** pipEdgePoints1 = nullptr, ITcVnContainer** pipEdgePoints2 = nullptr, float fRangeCutoffFactor = 0.135f)
	{
		Internal::MeasureMinEdgeDistance_Params params(ipSrcImage, fMinDistance, aStartPoint, aEndPoint, eEdgeDirection, fMinStrength, nSearchLines, fSearchLineDist, nMaxThickness, bInvertSearchDirection, fSearchGap, nSubpixelsIterations, fApproxPrecision, eAlgorithm, pipEdgePoints1, pipEdgePoints2, aPoint1, aPoint2, fRangeCutoffFactor, hrPrev);

		libraryInfo.functions[746 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SolvePnP_Params
		{
			ITcVnContainer* ipImagePoints;
			ITcVnContainer* ipReferencePoints;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double& fReprojError;
			ETcVnSolvePnPMethod eMethod;
			bool bUseExtrinsicGuess;
			HRESULT hrPrev;
			HRESULT retVal;

			SolvePnP_Params(ITcVnContainer* ipImagePoints, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, ETcVnSolvePnPMethod eMethod, bool bUseExtrinsicGuess, HRESULT hrPrev) : ipImagePoints(ipImagePoints), ipReferencePoints(ipReferencePoints), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fReprojError(fReprojError), eMethod(eMethod), bUseExtrinsicGuess(bUseExtrinsicGuess), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the rotation matrix and translation vector from 3D-2D point correspondences. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImagePoints">Image points (ContainerType_Vector_TcVnPoint2_REAL, requires at least 4 points in the same order as in ipReferencePoints)</param>
	/// <param name="ipReferencePoints">Reference world points (ContainerType_Vector_TcVnPoint3_REAL, same number of points as in ipImagePoints)</param>
	/// <param name="aCameraMatrix">Camera matrix (e.g. computed with one of the CalibrateCamera functions)</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6] (e.g. computed with one of the CalibrateCamera functions)</param>
	/// <param name="aRotationMatrix">Returns the rotation matrix</param>
	/// <param name="aTranslationVector">Returns the translation vector</param>
	/// <param name="fReprojError">Returns the reprojection error</param>
	/// <param name="eMethod">Solve PnP method</param>
	/// <param name="bUseExtrinsicGuess">If true, the provided rotation matrix and translation vector are used as an initial guess for further optimization (only supported for the SPM_ITERATIVE method).</param>
	/// <returns>HRESULT</returns>
	static HRESULT SolvePnP(HRESULT hrPrev, ITcVnContainer* ipImagePoints, ITcVnContainer* ipReferencePoints, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double& fReprojError, ETcVnSolvePnPMethod eMethod = SPM_ITERATIVE, bool bUseExtrinsicGuess = false)
	{
		Internal::SolvePnP_Params params(ipImagePoints, ipReferencePoints, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fReprojError, eMethod, bUseExtrinsicGuess, hrPrev);

		libraryInfo.functions[747 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct SortDetectedPatternPoints_Params
		{
			ITcVnContainer* ipImagePoints;
			ITcVnContainer* ipPatternPoints;
			HRESULT hrPrev;
			HRESULT retVal;

			SortDetectedPatternPoints_Params(ITcVnContainer* ipImagePoints, ITcVnContainer* ipPatternPoints, HRESULT hrPrev) : ipImagePoints(ipImagePoints), ipPatternPoints(ipPatternPoints), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Sort the detected pattern points according to the relative positions of the calibration pattern points.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImagePoints">Detected pattern point positions in the image coordinate system (will be sorted by this function, ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="ipPatternPoints">The pattern points in the calibration pattern coordinate system, used as a reference to sort ipImagePoints (ContainerType_Vector_TcVnPoint3_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT SortDetectedPatternPoints(HRESULT hrPrev, ITcVnContainer* ipImagePoints, ITcVnContainer* ipPatternPoints)
	{
		Internal::SortDetectedPatternPoints_Params params(ipImagePoints, ipPatternPoints, hrPrev);

		libraryInfo.functions[748 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TransformCoordinatesImageToWorld_Container_Params
		{
			ITcVnContainer* ipSrcPoints2D;
			ITcVnContainer*& ipDestPoints3D;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double fZ;
			HRESULT hrPrev;
			HRESULT retVal;

			TransformCoordinatesImageToWorld_Container_Params(ITcVnContainer* ipSrcPoints2D, ITcVnContainer*& ipDestPoints3D, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double fZ, HRESULT hrPrev) : ipSrcPoints2D(ipSrcPoints2D), ipDestPoints3D(ipDestPoints3D), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fZ(fZ), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transform 2D image point coordinates to 3D world coordinates (using intrinsic + extrinsic calibration results).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints2D">Container with 2D source points (TcVnPoint2_DINT or TcVnPoint2_REAL or TcVnPoint2_LREAL)</param>
	/// <param name="ipDestPoints3D">Returns the transformed 3D points (TcVnPoint3_LREAL)</param>
	/// <param name="aCameraMatrix">3x3 camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">3x3 rotation matrix</param>
	/// <param name="aTranslationVector">Translation vector</param>
	/// <param name="fZ">z coordinate (world coordinate system) of the transformed points (0 would be at (toplevel) calibration pattern)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TransformCoordinatesImageToWorld(HRESULT hrPrev, ITcVnContainer* ipSrcPoints2D, ITcVnContainer*& ipDestPoints3D, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double fZ)
	{
		Internal::TransformCoordinatesImageToWorld_Container_Params params(ipSrcPoints2D, ipDestPoints3D, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fZ, hrPrev);

		libraryInfo.functions[749 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TransformCoordinatesImageToWorld_Point_Params
		{
			VN_TcVnPoint2_LREAL& aSrcPoint;
			VN_TcVnPoint3_LREAL& aDestPoint;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			double fZ;
			HRESULT hrPrev;
			HRESULT retVal;

			TransformCoordinatesImageToWorld_Point_Params(TcVnPoint2_LREAL& aSrcPoint, TcVnPoint3_LREAL& aDestPoint, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double fZ, HRESULT hrPrev) : aSrcPoint(aSrcPoint), aDestPoint(aDestPoint), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), fZ(fZ), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transform 2D image point coordinate to 3D world coordinate (using intrinsic + extrinsic calibration results).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcPoint">Point in the image coordinate system</param>
	/// <param name="aDestPoint">Returns the point in the world coordinate system</param>
	/// <param name="aCameraMatrix">3x3 camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">3x3 rotation matrix</param>
	/// <param name="aTranslationVector">Translation vector</param>
	/// <param name="fZ">z coordinate (world coordinate system) of the transformed points (0 would be at (toplevel) calibration pattern)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TransformCoordinatesImageToWorld(HRESULT hrPrev, TcVnPoint2_LREAL& aSrcPoint, TcVnPoint3_LREAL& aDestPoint, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, double fZ)
	{
		Internal::TransformCoordinatesImageToWorld_Point_Params params(aSrcPoint, aDestPoint, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, fZ, hrPrev);

		libraryInfo.functions[750 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TransformCoordinatesWorldToImage_Container_Params
		{
			ITcVnContainer* ipSrcPoints3D;
			ITcVnContainer*& ipDestPoints2D;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			bool bInteger;
			HRESULT hrPrev;
			HRESULT retVal;

			TransformCoordinatesWorldToImage_Container_Params(ITcVnContainer* ipSrcPoints3D, ITcVnContainer*& ipDestPoints2D, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, bool bInteger, HRESULT hrPrev) : ipSrcPoints3D(ipSrcPoints3D), ipDestPoints2D(ipDestPoints2D), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), bInteger(bInteger), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transform 3D world coordinates to 2D image coordinates (using intrinsic + extrinsic calibration results).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcPoints3D">Container with 3D source points (TcVnPoint3_LREAL)</param>
	/// <param name="ipDestPoints2D">Returns the transformed 2D points (TcVnPoint2_REAL or TcVnPoint2_DINT, depending on bInteger)</param>
	/// <param name="aCameraMatrix">3x3 camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">3x3 rotation matrix</param>
	/// <param name="aTranslationVector">Translation vector</param>
	/// <param name="bInteger">Selects whether the function returns a container of TcVnPoint2_DINT or TcVnPoint2_REAL</param>
	/// <returns>HRESULT</returns>
	static HRESULT TransformCoordinatesWorldToImage(HRESULT hrPrev, ITcVnContainer* ipSrcPoints3D, ITcVnContainer*& ipDestPoints2D, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, bool bInteger)
	{
		Internal::TransformCoordinatesWorldToImage_Container_Params params(ipSrcPoints3D, ipDestPoints2D, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, bInteger, hrPrev);

		libraryInfo.functions[751 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TransformCoordinatesWorldToImage_Point_Params
		{
			VN_TcVnPoint3_LREAL& aSrcPoint;
			VN_TcVnPoint2_REAL& aDestPoint;
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			TcVnArray8_LREAL& aDistortionCoefficients;
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			VN_TcVnVector3_LREAL& aTranslationVector;
			HRESULT hrPrev;
			HRESULT retVal;

			TransformCoordinatesWorldToImage_Point_Params(TcVnPoint3_LREAL& aSrcPoint, TcVnPoint2_REAL& aDestPoint, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector, HRESULT hrPrev) : aSrcPoint(aSrcPoint), aDestPoint(aDestPoint), aCameraMatrix(aCameraMatrix), aDistortionCoefficients(aDistortionCoefficients), aRotationMatrix(aRotationMatrix), aTranslationVector(aTranslationVector), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Transform 3D world coordinates to 2D image coordinates (using intrinsic + extrinsic calibration results).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="aSrcPoint">3D source point (world coordinate system)</param>
	/// <param name="aDestPoint">Returns the transformed 2D point (image coordinate system)</param>
	/// <param name="aCameraMatrix">3x3 camera matrix containing the intrinsic parameters</param>
	/// <param name="aDistortionCoefficients">Lens distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
	/// <param name="aRotationMatrix">3x3 rotation matrix</param>
	/// <param name="aTranslationVector">Translation vector</param>
	/// <returns>HRESULT</returns>
	static HRESULT TransformCoordinatesWorldToImage(HRESULT hrPrev, TcVnPoint3_LREAL& aSrcPoint, TcVnPoint2_REAL& aDestPoint, TcVnMatrix3x3_LREAL& aCameraMatrix, TcVnArray8_LREAL& aDistortionCoefficients, TcVnMatrix3x3_LREAL& aRotationMatrix, TcVnVector3_LREAL& aTranslationVector)
	{
		Internal::TransformCoordinatesWorldToImage_Point_Params params(aSrcPoint, aDestPoint, aCameraMatrix, aDistortionCoefficients, aRotationMatrix, aTranslationVector, hrPrev);

		libraryInfo.functions[752 - Lic3FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Vision_Matching

	namespace Internal
	{
		static TcVnVector4_LREAL DrawKeypoints_aColorDefault = {-1, -1, -1, -1};

		struct DrawKeypoints_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer* ipKeyPoints;
			ITcVnImage*& ipDestImage;
			VN_TcVnVector4_LREAL& aColor;
			ETcVnDrawMatchesFlags eFlags;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawKeypoints_Params(ITcVnImage* ipSrcImage, ITcVnContainer* ipKeyPoints, ITcVnImage*& ipDestImage, TcVnVector4_LREAL& aColor, ETcVnDrawMatchesFlags eFlags, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipDestImage(ipDestImage), aColor(aColor), eFlags(eFlags), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws the keypoints for visualization purpose. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (elements of type USINT)</param>
	/// <param name="ipKeyPoints">Container with the keypoints (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipDestImage">Destination image (An appropriate color image will be created if required.)</param>
	/// <param name="aColor">Color to draw the keypoints (for {-1, -1, -1, -1}, a random color is chosen for each point)</param>
	/// <param name="eFlags">A combination of flags to support overdrawing an existing destination image and/or drawing additional (Rich-)Keypoint information (size and orientation)</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawKeypoints(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipKeyPoints, ITcVnImage*& ipDestImage, TcVnVector4_LREAL& aColor = Internal::DrawKeypoints_aColorDefault, ETcVnDrawMatchesFlags eFlags = DMF_DEFAULT)
	{
		Internal::DrawKeypoints_Params params(ipSrcImage, ipKeyPoints, ipDestImage, aColor, eFlags, hrPrev);

		libraryInfo.functions[753 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnVector4_LREAL DrawMatches_aMatchColorDefault = {-1, -1, -1, -1};
		static TcVnVector4_LREAL DrawMatches_aSingleColorDefault = {-1, -1, -1, -1};

		struct DrawMatches_Params
		{
			ITcVnImage* ipSrcImage1;
			ITcVnContainer* ipKeyPoints1;
			ITcVnImage* ipSrcImage2;
			ITcVnContainer* ipKeyPoints2;
			ITcVnContainer* ipMatches1To2;
			ITcVnImage*& ipDestImage;
			VN_TcVnVector4_LREAL& aMatchColor;
			VN_TcVnVector4_LREAL& aSingleColor;
			ITcVnContainer* ipMatchesMask;
			ETcVnDrawMatchesFlags eFlags;
			HRESULT hrPrev;
			HRESULT retVal;

			DrawMatches_Params(ITcVnImage* ipSrcImage1, ITcVnContainer* ipKeyPoints1, ITcVnImage* ipSrcImage2, ITcVnContainer* ipKeyPoints2, ITcVnContainer* ipMatches1To2, ITcVnImage*& ipDestImage, TcVnVector4_LREAL& aMatchColor, TcVnVector4_LREAL& aSingleColor, ITcVnContainer* ipMatchesMask, ETcVnDrawMatchesFlags eFlags, HRESULT hrPrev) : ipSrcImage1(ipSrcImage1), ipKeyPoints1(ipKeyPoints1), ipSrcImage2(ipSrcImage2), ipKeyPoints2(ipKeyPoints2), ipMatches1To2(ipMatches1To2), ipDestImage(ipDestImage), aMatchColor(aMatchColor), aSingleColor(aSingleColor), ipMatchesMask(ipMatchesMask), eFlags(eFlags), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Draws the keypoints and matches for visualization purpose. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage1">Source image 1 (elements of type USINT)</param>
	/// <param name="ipKeyPoints1">Container with the keypoints 1 (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipSrcImage2">Source image 2 (elements of type USINT, must have the same number of channels as ipSrcImage1)</param>
	/// <param name="ipKeyPoints2">Container with the keypoints 2 (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipMatches1To2">Container with the descriptor matches (ContainerType_Vector_TcVnDMatch)</param>
	/// <param name="ipDestImage">Destination image (An appropriate color image will be created if required.)</param>
	/// <param name="aMatchColor">Color to draw the matches (for {-1, -1, -1, -1}, a random color is chosen for each point and line)</param>
	/// <param name="aSingleColor">Color to draw the single keypoints (for {-1, -1, -1, -1}, a random color is chosen for each point)</param>
	/// <param name="ipMatchesMask">Mask to select the matches to be drawn (ContainerType_Vector_SINT; Set to 0 if all matches should be drawn.)</param>
	/// <param name="eFlags">A combination of flags to support overdrawing an existing destination image and/or drawing additional (Rich-)Keypoint information (size and orientation) and/or skipping single keypoints</param>
	/// <returns>HRESULT</returns>
	static HRESULT DrawMatches(HRESULT hrPrev, ITcVnImage* ipSrcImage1, ITcVnContainer* ipKeyPoints1, ITcVnImage* ipSrcImage2, ITcVnContainer* ipKeyPoints2, ITcVnContainer* ipMatches1To2, ITcVnImage*& ipDestImage, TcVnVector4_LREAL& aMatchColor = Internal::DrawMatches_aMatchColorDefault, TcVnVector4_LREAL& aSingleColor = Internal::DrawMatches_aSingleColorDefault, ITcVnContainer* ipMatchesMask = nullptr, ETcVnDrawMatchesFlags eFlags = DMF_DEFAULT)
	{
		Internal::DrawMatches_Params params(ipSrcImage1, ipKeyPoints1, ipSrcImage2, ipKeyPoints2, ipMatches1To2, ipDestImage, aMatchColor, aSingleColor, ipMatchesMask, eFlags, hrPrev);

		libraryInfo.functions[754 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FilterGoodMatches_Params
		{
			ITcVnContainer* ipMatches;
			ITcVnContainer*& ipGoodMatches;
			float fMaxDist;
			float fMaxKnnRatio;
			HRESULT hrPrev;
			HRESULT retVal;

			FilterGoodMatches_Params(ITcVnContainer* ipMatches, ITcVnContainer*& ipGoodMatches, float fMaxDist, float fMaxKnnRatio, HRESULT hrPrev) : ipMatches(ipMatches), ipGoodMatches(ipGoodMatches), fMaxDist(fMaxDist), fMaxKnnRatio(fMaxKnnRatio), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Filter the descriptor matches and return only good ones.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMatches">Container with descriptor matches (ContainerType_Vector_TcVnDMatch or ContainerType_Vector_Vector_TcVnDMatch)</param>
	/// <param name="ipGoodMatches">Returns a container with good matches (ContainerType_Vector_TcVnDMatch)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], used for knn match results only, -1 disables this filter criterion)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FilterGoodMatches(HRESULT hrPrev, ITcVnContainer* ipMatches, ITcVnContainer*& ipGoodMatches, float fMaxDist, float fMaxKnnRatio)
	{
		Internal::FilterGoodMatches_Params params(ipMatches, ipGoodMatches, fMaxDist, fMaxKnnRatio, hrPrev);

		libraryInfo.functions[755 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FindReferenceKeyPointsInImage_Params
		{
			ITcVnContainer* ipSrcKeyPoints;
			ITcVnImage* ipSrcDescriptors;
			ITcVnContainer* ipRefKeyPoints;
			ITcVnImage* ipRefDescriptors;
			ULONG nRefImageWidth;
			ULONG nRefImageHeight;
			ITcVnContainer*& ipEdgePoints;
			float fMaxDist;
			float fMaxKnnRatio;
			ETcVnNormalizationType eNormType;
			ETcVnEstimationAlgorithm eAlgorithm;
			double fReprojThreshold;
			ULONG nMaxIterations;
			double fConfidence;
			ITcVnContainer** pipGoodMatches;
			ITcVnContainer** pipInlierMask;
			HRESULT hrPrev;
			HRESULT retVal;
			TcVnMatrix3x3_LREAL aPerspectiveTransform;
			ULONG nNumberOfGoodMatches;
			ULONG nNumberOfInliers;

			FindReferenceKeyPointsInImage_Params(ITcVnContainer* ipSrcKeyPoints, ITcVnImage* ipSrcDescriptors, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, ETcVnNormalizationType eNormType, ETcVnEstimationAlgorithm eAlgorithm, double fReprojThreshold, ULONG nMaxIterations, double fConfidence, ITcVnContainer** pipGoodMatches, ITcVnContainer** pipInlierMask, HRESULT hrPrev) : ipSrcKeyPoints(ipSrcKeyPoints), ipSrcDescriptors(ipSrcDescriptors), ipRefKeyPoints(ipRefKeyPoints), ipRefDescriptors(ipRefDescriptors), nRefImageWidth(nRefImageWidth), nRefImageHeight(nRefImageHeight), ipEdgePoints(ipEdgePoints), fMaxDist(fMaxDist), fMaxKnnRatio(fMaxKnnRatio), eNormType(eNormType), eAlgorithm(eAlgorithm), fReprojThreshold(fReprojThreshold), nMaxIterations(nMaxIterations), fConfidence(fConfidence), pipGoodMatches(pipGoodMatches), pipInlierMask(pipInlierMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Searches a reference image, represented by its keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcKeyPoints">KeyPoints of the source image, e.g. (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipSrcDescriptors">Descriptors of the source image KeyPoints</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into the coordinates of the source image (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <param name="eNormType">Normalization type used for descriptor matching (HAMMING recommended for AKAZE, ORB, and BRISK. HAMMING2 is recommended for ORB if the ORB nBriefPoints parameter is 3 or 4. )</param>
	/// <param name="aPerspectiveTransform">Returns the perspective transformation matrix, which transforms the reference points to the source points </param>
	/// <param name="nNumberOfGoodMatches">Return the number of good matches</param>
	/// <param name="nNumberOfInliers">Return the number of inlier matches</param>
	/// <param name="eAlgorithm">Estimation algorithm used for computing the perspective transformation between the two point sets</param>
	/// <param name="fReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (only used if eAlgorithm is RANSAC, RHO)</param>
	/// <param name="nMaxIterations">Maximum number of RANSAC iterations</param>
	/// <param name="fConfidence">Confidence (0..1)</param>
	/// <param name="pipGoodMatches">Returns a container with good matches (optional, set to 0 if not required; ContainerType_Vector_TcVnDMatch)</param>
	/// <param name="pipInlierMask">Returns a mask marking the inliers (optional, set to 0 if not required; ContainerType_Vector_SINT; only for RANSAC, LMEDS)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImage(HRESULT hrPrev, ITcVnContainer* ipSrcKeyPoints, ITcVnImage* ipSrcDescriptors, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, ETcVnNormalizationType eNormType, TcVnMatrix3x3_LREAL& aPerspectiveTransform, ULONG& nNumberOfGoodMatches, ULONG& nNumberOfInliers, ETcVnEstimationAlgorithm eAlgorithm = EA_RANSAC, double fReprojThreshold = 3, ULONG nMaxIterations = 2000, double fConfidence = 0.995, ITcVnContainer** pipGoodMatches = nullptr, ITcVnContainer** pipInlierMask = nullptr)
	{
		Internal::FindReferenceKeyPointsInImage_Params params(ipSrcKeyPoints, ipSrcDescriptors, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, eNormType, eAlgorithm, fReprojThreshold, nMaxIterations, fConfidence, pipGoodMatches, pipInlierMask, hrPrev);

		libraryInfo.functions[756 - Lic4FuncsOffs].pFct(&params);

		AssignTo(aPerspectiveTransform, params.aPerspectiveTransform);
		AssignTo(nNumberOfGoodMatches, params.nNumberOfGoodMatches);
		AssignTo(nNumberOfInliers, params.nNumberOfInliers);

		return params.retVal;
	}

	/// <summary>
	/// Searches a reference image, represented by its keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcKeyPoints">KeyPoints of the source image, e.g. (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipSrcDescriptors">Descriptors of the source image KeyPoints</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into the coordinates of the source image (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <param name="eNormType">Normalization type used for descriptor matching (HAMMING recommended for AKAZE, ORB, and BRISK. HAMMING2 is recommended for ORB if the ORB nBriefPoints parameter is 3 or 4. )</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImage(HRESULT hrPrev, ITcVnContainer* ipSrcKeyPoints, ITcVnImage* ipSrcDescriptors, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, ETcVnNormalizationType eNormType)
	{
		Internal::FindReferenceKeyPointsInImage_Params params(ipSrcKeyPoints, ipSrcDescriptors, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, eNormType, EA_RANSAC, 3, 2000, 0.995, nullptr, nullptr, hrPrev);

		libraryInfo.functions[756 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsAKAZE FindReferenceKeyPointsInImageAKAZE_stAkazeParamsDefault = {FDT_AKAZE_MLDB, 0, 3, 0.001f, 2, 1, DT1_KAZE_PM_G2};

		struct FindReferenceKeyPointsInImageAKAZE_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer* ipRefKeyPoints;
			ITcVnImage* ipRefDescriptors;
			ULONG nRefImageWidth;
			ULONG nRefImageHeight;
			ITcVnContainer*& ipEdgePoints;
			float fMaxDist;
			float fMaxKnnRatio;
			ETcVnNormalizationType eNormType;
			ITcVnImage* ipSrcImageMask;
			TcVnParamsAKAZE& stAkazeParams;
			ETcVnEstimationAlgorithm eAlgorithm;
			double fReprojThreshold;
			ULONG nMaxIterations;
			double fConfidence;
			HRESULT hrPrev;
			HRESULT retVal;
			TcVnMatrix3x3_LREAL aPerspectiveTransform;
			ULONG nNumberOfGoodMatches;
			ULONG nNumberOfInliers;

			FindReferenceKeyPointsInImageAKAZE_Params(ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, ETcVnNormalizationType eNormType, ITcVnImage* ipSrcImageMask, TcVnParamsAKAZE& stAkazeParams, ETcVnEstimationAlgorithm eAlgorithm, double fReprojThreshold, ULONG nMaxIterations, double fConfidence, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipRefKeyPoints(ipRefKeyPoints), ipRefDescriptors(ipRefDescriptors), nRefImageWidth(nRefImageWidth), nRefImageHeight(nRefImageHeight), ipEdgePoints(ipEdgePoints), fMaxDist(fMaxDist), fMaxKnnRatio(fMaxKnnRatio), eNormType(eNormType), ipSrcImageMask(ipSrcImageMask), stAkazeParams(stAkazeParams), eAlgorithm(eAlgorithm), fReprojThreshold(fReprojThreshold), nMaxIterations(nMaxIterations), fConfidence(fConfidence), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Searches a reference image, represented by its AKAZE keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image, e.g. computed with F_VN_KeyPointsAndDescriptorsAKAZE (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints, e.g. computed with F_VN_KeyPointsAndDescriptorsAKAZE</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into ipSrcImage coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <param name="aPerspectiveTransform">Returns the perspective transformation matrix, which transforms the reference points to the source points </param>
	/// <param name="nNumberOfGoodMatches">Return the number of good matches</param>
	/// <param name="nNumberOfInliers">Return the number of inlier matches</param>
	/// <param name="eNormType">Normalization type used for descriptor matching</param>
	/// <param name="ipSrcImageMask">Mask to specify, where to look for keypoints in ipSrcImage (set to 0 if no mask required)</param>
	/// <param name="stAkazeParams">Parameters to configure the keypoint and descriptor computation for ipSrcImage (resulting descriptors must be compatible to ipRefDescriptors!)</param>
	/// <param name="eAlgorithm">Estimation algorithm used for computing the perspective transformation between the two point sets</param>
	/// <param name="fReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (only used if eAlgorithm is RANSAC, RHO)</param>
	/// <param name="nMaxIterations">Maximum number of RANSAC iterations</param>
	/// <param name="fConfidence">Confidence (0..1)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImageAKAZE(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, TcVnMatrix3x3_LREAL& aPerspectiveTransform, ULONG& nNumberOfGoodMatches, ULONG& nNumberOfInliers, ETcVnNormalizationType eNormType = NT_HAMMING, ITcVnImage* ipSrcImageMask = nullptr, TcVnParamsAKAZE& stAkazeParams = Internal::FindReferenceKeyPointsInImageAKAZE_stAkazeParamsDefault, ETcVnEstimationAlgorithm eAlgorithm = EA_RANSAC, double fReprojThreshold = 3, ULONG nMaxIterations = 2000, double fConfidence = 0.995)
	{
		Internal::FindReferenceKeyPointsInImageAKAZE_Params params(ipSrcImage, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, eNormType, ipSrcImageMask, stAkazeParams, eAlgorithm, fReprojThreshold, nMaxIterations, fConfidence, hrPrev);

		libraryInfo.functions[757 - Lic4FuncsOffs].pFct(&params);

		AssignTo(aPerspectiveTransform, params.aPerspectiveTransform);
		AssignTo(nNumberOfGoodMatches, params.nNumberOfGoodMatches);
		AssignTo(nNumberOfInliers, params.nNumberOfInliers);

		return params.retVal;
	}

	/// <summary>
	/// Searches a reference image, represented by its AKAZE keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image, e.g. computed with F_VN_KeyPointsAndDescriptorsAKAZE (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints, e.g. computed with F_VN_KeyPointsAndDescriptorsAKAZE</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into ipSrcImage coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImageAKAZE(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio)
	{
		Internal::FindReferenceKeyPointsInImageAKAZE_Params params(ipSrcImage, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, NT_HAMMING, nullptr, Internal::FindReferenceKeyPointsInImageAKAZE_stAkazeParamsDefault, EA_RANSAC, 3, 2000, 0.995, hrPrev);

		libraryInfo.functions[757 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsBRISK FindReferenceKeyPointsInImageBRISK_stBriskParamsDefault = {30, 3, 1};

		struct FindReferenceKeyPointsInImageBRISK_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer* ipRefKeyPoints;
			ITcVnImage* ipRefDescriptors;
			ULONG nRefImageWidth;
			ULONG nRefImageHeight;
			ITcVnContainer*& ipEdgePoints;
			float fMaxDist;
			float fMaxKnnRatio;
			ETcVnNormalizationType eNormType;
			ITcVnImage* ipSrcImageMask;
			TcVnParamsBRISK& stBriskParams;
			ETcVnEstimationAlgorithm eAlgorithm;
			double fReprojThreshold;
			ULONG nMaxIterations;
			double fConfidence;
			HRESULT hrPrev;
			HRESULT retVal;
			TcVnMatrix3x3_LREAL aPerspectiveTransform;
			ULONG nNumberOfGoodMatches;
			ULONG nNumberOfInliers;

			FindReferenceKeyPointsInImageBRISK_Params(ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, ETcVnNormalizationType eNormType, ITcVnImage* ipSrcImageMask, TcVnParamsBRISK& stBriskParams, ETcVnEstimationAlgorithm eAlgorithm, double fReprojThreshold, ULONG nMaxIterations, double fConfidence, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipRefKeyPoints(ipRefKeyPoints), ipRefDescriptors(ipRefDescriptors), nRefImageWidth(nRefImageWidth), nRefImageHeight(nRefImageHeight), ipEdgePoints(ipEdgePoints), fMaxDist(fMaxDist), fMaxKnnRatio(fMaxKnnRatio), eNormType(eNormType), ipSrcImageMask(ipSrcImageMask), stBriskParams(stBriskParams), eAlgorithm(eAlgorithm), fReprojThreshold(fReprojThreshold), nMaxIterations(nMaxIterations), fConfidence(fConfidence), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Searches a reference image, represented by its BRISK keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image, e.g. computed with F_VN_KeyPointsAndDescriptorsBRISK (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints, e.g. computed with F_VN_KeyPointsAndDescriptorsBRISK</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into ipSrcImage coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <param name="aPerspectiveTransform">Returns the perspective transformation matrix, which transforms the reference points to the source points </param>
	/// <param name="nNumberOfGoodMatches">Return the number of good matches</param>
	/// <param name="nNumberOfInliers">Return the number of inlier matches</param>
	/// <param name="eNormType">Normalization type used for descriptor matching</param>
	/// <param name="ipSrcImageMask">Mask to specify, where to look for keypoints in ipSrcImage (set to 0 if no mask required)</param>
	/// <param name="stBriskParams">Parameters to configure the keypoint and descriptor computation for ipSrcImage (resulting descriptors must be compatible to ipRefDescriptors!)</param>
	/// <param name="eAlgorithm">Estimation algorithm used for computing the perspective transformation between the two point sets</param>
	/// <param name="fReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (only used if eAlgorithm is RANSAC, RHO)</param>
	/// <param name="nMaxIterations">Maximum number of RANSAC iterations</param>
	/// <param name="fConfidence">Confidence (0..1)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImageBRISK(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, TcVnMatrix3x3_LREAL& aPerspectiveTransform, ULONG& nNumberOfGoodMatches, ULONG& nNumberOfInliers, ETcVnNormalizationType eNormType = NT_HAMMING, ITcVnImage* ipSrcImageMask = nullptr, TcVnParamsBRISK& stBriskParams = Internal::FindReferenceKeyPointsInImageBRISK_stBriskParamsDefault, ETcVnEstimationAlgorithm eAlgorithm = EA_RANSAC, double fReprojThreshold = 3, ULONG nMaxIterations = 2000, double fConfidence = 0.995)
	{
		Internal::FindReferenceKeyPointsInImageBRISK_Params params(ipSrcImage, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, eNormType, ipSrcImageMask, stBriskParams, eAlgorithm, fReprojThreshold, nMaxIterations, fConfidence, hrPrev);

		libraryInfo.functions[758 - Lic4FuncsOffs].pFct(&params);

		AssignTo(aPerspectiveTransform, params.aPerspectiveTransform);
		AssignTo(nNumberOfGoodMatches, params.nNumberOfGoodMatches);
		AssignTo(nNumberOfInliers, params.nNumberOfInliers);

		return params.retVal;
	}

	/// <summary>
	/// Searches a reference image, represented by its BRISK keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image, e.g. computed with F_VN_KeyPointsAndDescriptorsBRISK (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints, e.g. computed with F_VN_KeyPointsAndDescriptorsBRISK</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into ipSrcImage coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImageBRISK(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio)
	{
		Internal::FindReferenceKeyPointsInImageBRISK_Params params(ipSrcImage, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, NT_HAMMING, nullptr, Internal::FindReferenceKeyPointsInImageBRISK_stBriskParamsDefault, EA_RANSAC, 3, 2000, 0.995, hrPrev);

		libraryInfo.functions[758 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsORB FindReferenceKeyPointsInImageORB_stOrbParamsDefault = {500, 1.2f, 8, 31, 0, 2, FST_ORB_HARRIS, 31, 20};

		struct FindReferenceKeyPointsInImageORB_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer* ipRefKeyPoints;
			ITcVnImage* ipRefDescriptors;
			ULONG nRefImageWidth;
			ULONG nRefImageHeight;
			ITcVnContainer*& ipEdgePoints;
			float fMaxDist;
			float fMaxKnnRatio;
			ETcVnNormalizationType eNormType;
			ITcVnImage* ipSrcImageMask;
			TcVnParamsORB& stOrbParams;
			ETcVnEstimationAlgorithm eAlgorithm;
			double fReprojThreshold;
			ULONG nMaxIterations;
			double fConfidence;
			HRESULT hrPrev;
			HRESULT retVal;
			TcVnMatrix3x3_LREAL aPerspectiveTransform;
			ULONG nNumberOfGoodMatches;
			ULONG nNumberOfInliers;

			FindReferenceKeyPointsInImageORB_Params(ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, ETcVnNormalizationType eNormType, ITcVnImage* ipSrcImageMask, TcVnParamsORB& stOrbParams, ETcVnEstimationAlgorithm eAlgorithm, double fReprojThreshold, ULONG nMaxIterations, double fConfidence, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipRefKeyPoints(ipRefKeyPoints), ipRefDescriptors(ipRefDescriptors), nRefImageWidth(nRefImageWidth), nRefImageHeight(nRefImageHeight), ipEdgePoints(ipEdgePoints), fMaxDist(fMaxDist), fMaxKnnRatio(fMaxKnnRatio), eNormType(eNormType), ipSrcImageMask(ipSrcImageMask), stOrbParams(stOrbParams), eAlgorithm(eAlgorithm), fReprojThreshold(fReprojThreshold), nMaxIterations(nMaxIterations), fConfidence(fConfidence), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Searches a reference image, represented by its ORB keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image, e.g. computed with F_VN_KeyPointsAndDescriptorsORB (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints, e.g. computed with F_VN_KeyPointsAndDescriptorsORB</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into ipSrcImage coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <param name="aPerspectiveTransform">Returns the perspective transformation matrix, which transforms the reference points to the source points </param>
	/// <param name="nNumberOfGoodMatches">Return the number of good matches</param>
	/// <param name="nNumberOfInliers">Return the number of inlier matches</param>
	/// <param name="eNormType">Normalization type used for descriptor matching (HAMMING recommended for ORB, HAMMING2 if the ORB nBriefPoints parameter is 3 or 4)</param>
	/// <param name="ipSrcImageMask">Mask to specify, where to look for keypoints in ipSrcImage (set to 0 if no mask required)</param>
	/// <param name="stOrbParams">Parameters to configure the keypoint and descriptor computation for ipSrcImage (resulting descriptors must be compatible to ipRefDescriptors!)</param>
	/// <param name="eAlgorithm">Estimation algorithm used for computing the perspective transformation between the two point sets</param>
	/// <param name="fReprojThreshold">Maximum allowed reprojection error to treat a point pair as an inlier (only used if eAlgorithm is RANSAC, RHO)</param>
	/// <param name="nMaxIterations">Maximum number of RANSAC iterations</param>
	/// <param name="fConfidence">Confidence (0..1)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImageORB(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio, TcVnMatrix3x3_LREAL& aPerspectiveTransform, ULONG& nNumberOfGoodMatches, ULONG& nNumberOfInliers, ETcVnNormalizationType eNormType = NT_HAMMING, ITcVnImage* ipSrcImageMask = nullptr, TcVnParamsORB& stOrbParams = Internal::FindReferenceKeyPointsInImageORB_stOrbParamsDefault, ETcVnEstimationAlgorithm eAlgorithm = EA_RANSAC, double fReprojThreshold = 3, ULONG nMaxIterations = 2000, double fConfidence = 0.995)
	{
		Internal::FindReferenceKeyPointsInImageORB_Params params(ipSrcImage, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, eNormType, ipSrcImageMask, stOrbParams, eAlgorithm, fReprojThreshold, nMaxIterations, fConfidence, hrPrev);

		libraryInfo.functions[759 - Lic4FuncsOffs].pFct(&params);

		AssignTo(aPerspectiveTransform, params.aPerspectiveTransform);
		AssignTo(nNumberOfGoodMatches, params.nNumberOfGoodMatches);
		AssignTo(nNumberOfInliers, params.nNumberOfInliers);

		return params.retVal;
	}

	/// <summary>
	/// Searches a reference image, represented by its ORB keypoints and corresponding descriptors, in a given source image. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipRefKeyPoints">KeyPoints of the reference image, e.g. computed with F_VN_KeyPointsAndDescriptorsORB (ContainerType_Vector_TcVnKeyPoint)</param>
	/// <param name="ipRefDescriptors">Descriptors of the reference image KeyPoints, e.g. computed with F_VN_KeyPointsAndDescriptorsORB</param>
	/// <param name="nRefImageWidth">Width of the reference image in pixels</param>
	/// <param name="nRefImageHeight">Height of the reference image in pixels</param>
	/// <param name="ipEdgePoints">Returns a container with the 4 edge points of the reference image transformed into ipSrcImage coordinates (ContainerType_Vector_TcVnPoint2_REAL)</param>
	/// <param name="fMaxDist">Maximum allowed descriptor distance (-1 disables this filter criterion)</param>
	/// <param name="fMaxKnnRatio">Maximum allowed distance ratio between first and second best match ([0..1], -1 disables this filter criterion)</param>
	/// <returns>HRESULT</returns>
	static HRESULT FindReferenceKeyPointsInImageORB(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer* ipRefKeyPoints, ITcVnImage* ipRefDescriptors, ULONG nRefImageWidth, ULONG nRefImageHeight, ITcVnContainer*& ipEdgePoints, float fMaxDist, float fMaxKnnRatio)
	{
		Internal::FindReferenceKeyPointsInImageORB_Params params(ipSrcImage, ipRefKeyPoints, ipRefDescriptors, nRefImageWidth, nRefImageHeight, ipEdgePoints, fMaxDist, fMaxKnnRatio, NT_HAMMING, nullptr, Internal::FindReferenceKeyPointsInImageORB_stOrbParamsDefault, EA_RANSAC, 3, 2000, 0.995, hrPrev);

		libraryInfo.functions[759 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetMatchCoordinates_Params
		{
			ITcVnContainer* ipQueryKeyPoints;
			ITcVnContainer* ipTrainKeyPoints;
			ITcVnContainer* ipMatches;
			ITcVnContainer*& ipQueryCoordinates;
			ITcVnContainer*& ipTrainCoordinates;
			HRESULT hrPrev;
			HRESULT retVal;

			GetMatchCoordinates_Params(ITcVnContainer* ipQueryKeyPoints, ITcVnContainer* ipTrainKeyPoints, ITcVnContainer* ipMatches, ITcVnContainer*& ipQueryCoordinates, ITcVnContainer*& ipTrainCoordinates, HRESULT hrPrev) : ipQueryKeyPoints(ipQueryKeyPoints), ipTrainKeyPoints(ipTrainKeyPoints), ipMatches(ipMatches), ipQueryCoordinates(ipQueryCoordinates), ipTrainCoordinates(ipTrainCoordinates), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Return the coordinates of keypoints that match each other.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipQueryKeyPoints">Container with query Keypoints (i.e. keypoints of a reference/template image) of type CTcVnContainer_Vector_TcVnKeyPoint</param>
	/// <param name="ipTrainKeyPoints">Container with training Keypoints (i.e. keypoints of a source/input image) of type CTcVnContainer_Vector_TcVnKeyPoint</param>
	/// <param name="ipMatches">Container with matches between query and train Keypoints (CTcVnContainer_Vector_TcVnDMatch).</param>
	/// <param name="ipQueryCoordinates">Returns a container with the coordinates of keypoints from the query Keypoints that exist in ipMatches (CTcVnContainer_Vector_TcVnPoint2_REAL)</param>
	/// <param name="ipTrainCoordinates">Returns a container with the coordinates of keypoints from the training Keypoints that exist in ipMatches (CTcVnContainer_Vector_TcVnPoint2_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetMatchCoordinates(HRESULT hrPrev, ITcVnContainer* ipQueryKeyPoints, ITcVnContainer* ipTrainKeyPoints, ITcVnContainer* ipMatches, ITcVnContainer*& ipQueryCoordinates, ITcVnContainer*& ipTrainCoordinates)
	{
		Internal::GetMatchCoordinates_Params params(ipQueryKeyPoints, ipTrainKeyPoints, ipMatches, ipQueryCoordinates, ipTrainCoordinates, hrPrev);

		libraryInfo.functions[760 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsAGAST KeyPointsAGAST_stParamsDefault = {10, true, KDT_AGAST_9_16};

		struct KeyPointsAGAST_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage* ipMask;
			TcVnParamsAGAST& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsAGAST_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask, TcVnParamsAGAST& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints using the AGAST method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsAGAST(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask = nullptr, TcVnParamsAGAST& stParams = Internal::KeyPointsAGAST_stParamsDefault)
	{
		Internal::KeyPointsAGAST_Params params(ipSrcImage, ipKeyPoints, ipMask, stParams, hrPrev);

		libraryInfo.functions[761 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsAKAZE KeyPointsAndDescriptorsAKAZE_stParamsDefault = {FDT_AKAZE_MLDB, 0, 3, 0.001f, 2, 1, DT1_KAZE_PM_G2};

		struct KeyPointsAndDescriptorsAKAZE_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage*& ipDescriptors;
			ITcVnImage* ipMask;
			TcVnParamsAKAZE& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsAndDescriptorsAKAZE_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask, TcVnParamsAKAZE& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipDescriptors(ipDescriptors), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints and compute descriptors using the AKAZE method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipDescriptors">Descriptor image (set to 0 if not required; 1 descriptor in each row; An appropriate image will be created if required.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsAndDescriptorsAKAZE(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask = nullptr, TcVnParamsAKAZE& stParams = Internal::KeyPointsAndDescriptorsAKAZE_stParamsDefault)
	{
		Internal::KeyPointsAndDescriptorsAKAZE_Params params(ipSrcImage, ipKeyPoints, ipDescriptors, ipMask, stParams, hrPrev);

		libraryInfo.functions[762 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsBRISK KeyPointsAndDescriptorsBRISK_stParamsDefault = {30, 3, 1};

		struct KeyPointsAndDescriptorsBRISK_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage*& ipDescriptors;
			ITcVnImage* ipMask;
			TcVnParamsBRISK& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsAndDescriptorsBRISK_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask, TcVnParamsBRISK& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipDescriptors(ipDescriptors), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints and compute descriptors using the BRISK method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipDescriptors">Descriptor image (set to 0 if not required; 1 descriptor in each row; An appropriate image will be created if required.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsAndDescriptorsBRISK(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask = nullptr, TcVnParamsBRISK& stParams = Internal::KeyPointsAndDescriptorsBRISK_stParamsDefault)
	{
		Internal::KeyPointsAndDescriptorsBRISK_Params params(ipSrcImage, ipKeyPoints, ipDescriptors, ipMask, stParams, hrPrev);

		libraryInfo.functions[763 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsKAZE KeyPointsAndDescriptorsKAZE_stParamsDefault = {false, false, 0.001f, 4, 2, DT1_KAZE_PM_G2};

		struct KeyPointsAndDescriptorsKAZE_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage*& ipDescriptors;
			ITcVnImage* ipMask;
			TcVnParamsKAZE& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsAndDescriptorsKAZE_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask, TcVnParamsKAZE& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipDescriptors(ipDescriptors), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints and compute descriptors using the KAZE method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipDescriptors">Descriptor image (set to 0 if not required; 1 descriptor in each row; An appropriate image will be created if required.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsAndDescriptorsKAZE(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask = nullptr, TcVnParamsKAZE& stParams = Internal::KeyPointsAndDescriptorsKAZE_stParamsDefault)
	{
		Internal::KeyPointsAndDescriptorsKAZE_Params params(ipSrcImage, ipKeyPoints, ipDescriptors, ipMask, stParams, hrPrev);

		libraryInfo.functions[764 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsORB KeyPointsAndDescriptorsORB_stParamsDefault = {500, 1.2f, 8, 31, 0, 2, FST_ORB_HARRIS, 31, 20};

		struct KeyPointsAndDescriptorsORB_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage*& ipDescriptors;
			ITcVnImage* ipMask;
			TcVnParamsORB& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsAndDescriptorsORB_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask, TcVnParamsORB& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipDescriptors(ipDescriptors), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detect keypoints and compute descriptors using the ORB method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipDescriptors">Descriptor image (set to 0 if not required; 1 descriptor in each row; An appropriate image will be created if required.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsAndDescriptorsORB(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage*& ipDescriptors, ITcVnImage* ipMask = nullptr, TcVnParamsORB& stParams = Internal::KeyPointsAndDescriptorsORB_stParamsDefault)
	{
		Internal::KeyPointsAndDescriptorsORB_Params params(ipSrcImage, ipKeyPoints, ipDescriptors, ipMask, stParams, hrPrev);

		libraryInfo.functions[765 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsFAST KeyPointsFAST_stParamsDefault = {10, true, KDT_FAST_9_16};

		struct KeyPointsFAST_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage* ipMask;
			TcVnParamsFAST& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsFAST_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask, TcVnParamsFAST& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints using the FAST method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsFAST(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask = nullptr, TcVnParamsFAST& stParams = Internal::KeyPointsFAST_stParamsDefault)
	{
		Internal::KeyPointsFAST_Params params(ipSrcImage, ipKeyPoints, ipMask, stParams, hrPrev);

		libraryInfo.functions[766 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsGFTT KeyPointsGFTT_stParamsDefault = {1000, 0.01, 1, 3, false, 0.04};

		struct KeyPointsGFTT_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage* ipMask;
			TcVnParamsGFTT& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsGFTT_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask, TcVnParamsGFTT& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints using the GFTT method, which detects strong corners. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsGFTT(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask = nullptr, TcVnParamsGFTT& stParams = Internal::KeyPointsGFTT_stParamsDefault)
	{
		Internal::KeyPointsGFTT_Params params(ipSrcImage, ipKeyPoints, ipMask, stParams, hrPrev);

		libraryInfo.functions[767 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsMSER KeyPointsMSER_stParamsDefault = {5, 60, 14400, 0.25, 0.2, 200, 1.01, 0.003, 5};

		struct KeyPointsMSER_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage* ipMask;
			TcVnParamsMSER& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsMSER_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask, TcVnParamsMSER& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints using the MSER method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (set to 0 if no mask required)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsMSER(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask = nullptr, TcVnParamsMSER& stParams = Internal::KeyPointsMSER_stParamsDefault)
	{
		Internal::KeyPointsMSER_Params params(ipSrcImage, ipKeyPoints, ipMask, stParams, hrPrev);

		libraryInfo.functions[768 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsSB KeyPointsSB_stParamsDefault = {true, false, false, false, false, 25, 15000, 0, 1, 255, 0, 1, 0, 1, 5, 2, 30, 225, 10};

		struct KeyPointsSB_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipKeyPoints;
			ITcVnImage* ipMask;
			TcVnParamsSB& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			KeyPointsSB_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask, TcVnParamsSB& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipKeyPoints(ipKeyPoints), ipMask(ipMask), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects keypoints using a Simple Blob method - several iterations apply different thresholds to source image - connected components (blobs) are detected - the center and radius of the blobs are returned as keypoints
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipKeyPoints">Returns a container which is filled with the keypoints (ContainerType_Vector_TcVnKeyPoint; Non-zero interface pointers are reused.)</param>
	/// <param name="ipMask">Mask to specify, where to look for keypoints (optional, set to 0 if not required)</param>
	/// <param name="stParams">Several parameters to filter the detected blobs</param>
	/// <returns>HRESULT</returns>
	static HRESULT KeyPointsSB(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipKeyPoints, ITcVnImage* ipMask = nullptr, TcVnParamsSB& stParams = Internal::KeyPointsSB_stParamsDefault)
	{
		Internal::KeyPointsSB_Params params(ipSrcImage, ipKeyPoints, ipMask, stParams, hrPrev);

		libraryInfo.functions[769 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchContours_Params
		{
			ITcVnContainer* ipContour1;
			ITcVnContainer* ipContour2;
			ETcVnContoursMatchComparisonMethod eComparisonMethod;
			double& fDissimilarity;
			double fAreaFactor;
			double fAbsPositionFactor;
			double fRelPositionFactor;
			double fNumDiffFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchContours_Params(ITcVnContainer* ipContour1, ITcVnContainer* ipContour2, ETcVnContoursMatchComparisonMethod eComparisonMethod, double& fDissimilarity, double fAreaFactor, double fAbsPositionFactor, double fRelPositionFactor, double fNumDiffFactor, HRESULT hrPrev) : ipContour1(ipContour1), ipContour2(ipContour2), eComparisonMethod(eComparisonMethod), fDissimilarity(fDissimilarity), fAreaFactor(fAreaFactor), fAbsPositionFactor(fAbsPositionFactor), fRelPositionFactor(fRelPositionFactor), fNumDiffFactor(fNumDiffFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compare contours using the Hu moment invariants (and optionally further aspects). In case of multiple contours in each container, the best matches are found and the average dissimilarity over all matched contours is returned. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipContour1">First contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour) or collection of multiple contours (ContainerType_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="ipContour2">Second contour (same type as ipContour1)</param>
	/// <param name="eComparisonMethod">Method used for comparing the Hu moment invariants of the contours</param>
	/// <param name="fDissimilarity">Returns the dissimilarity of the contours depending on the chosen comparison method</param>
	/// <param name="fAreaFactor">If &gt; 0, the relative area difference between contours is scaled by this factor and added to the computed dissimilarity</param>
	/// <param name="fAbsPositionFactor">If &gt; 0, the absolute position difference between contours (i.e. the coordinates of the geometric contour centers) is scaled by this factor and added to the computed dissimilarity</param>
	/// <param name="fRelPositionFactor">If &gt; 0, the relative position difference between contours is scaled by this factor and added to the computed dissimilarity (only used if matching multiple contours)</param>
	/// <param name="fNumDiffFactor">If &gt; 0, the difference between the number of contours in both containers is scaled by this factor and added to the computed dissimilarity (only used if matching multiple contours)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchContours(HRESULT hrPrev, ITcVnContainer* ipContour1, ITcVnContainer* ipContour2, ETcVnContoursMatchComparisonMethod eComparisonMethod, double& fDissimilarity, double fAreaFactor = 0, double fAbsPositionFactor = 0, double fRelPositionFactor = 0, double fNumDiffFactor = 0)
	{
		Internal::MatchContours_Params params(ipContour1, ipContour2, eComparisonMethod, fDissimilarity, fAreaFactor, fAbsPositionFactor, fRelPositionFactor, fNumDiffFactor, hrPrev);

		libraryInfo.functions[770 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchContours1vsN_Params
		{
			ITcVnContainer* ipRefContour;
			ITcVnContainer* ipContours;
			ITcVnContainer*& ipMatchIndexes;
			ITcVnContainer*& ipDissimilarities;
			double fDissimilarityThreshold;
			ETcVnContoursMatchComparisonMethod eComparisonMethod;
			double fAreaFactor;
			double fAbsPositionFactor;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchContours1vsN_Params(ITcVnContainer* ipRefContour, ITcVnContainer* ipContours, ITcVnContainer*& ipMatchIndexes, ITcVnContainer*& ipDissimilarities, double fDissimilarityThreshold, ETcVnContoursMatchComparisonMethod eComparisonMethod, double fAreaFactor, double fAbsPositionFactor, HRESULT hrPrev) : ipRefContour(ipRefContour), ipContours(ipContours), ipMatchIndexes(ipMatchIndexes), ipDissimilarities(ipDissimilarities), fDissimilarityThreshold(fDissimilarityThreshold), eComparisonMethod(eComparisonMethod), fAreaFactor(fAreaFactor), fAbsPositionFactor(fAbsPositionFactor), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compare a reference contour with multiple other contours using the Hu moment invariants (and optionally further aspects). Returns a sorted list of best matches. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipRefContour">Reference contour (ContainerType_Vector_TcVnPoint2_DINT or ContainerType_Vector_TcVnPoint2_REAL; The elements of this container are the points of the contour)</param>
	/// <param name="ipContours">Collection of multiple contours (CTcVnContainer_Vector_Vector_TcVnPoint2_DINT)</param>
	/// <param name="ipMatchIndexes">Returns the indexes of the best matches (CTcVnContainer_Vector_ULINT; sorted, first element is best match, i.e. has lowest dissimilarity)</param>
	/// <param name="ipDissimilarities">Returns the computed dissimilarities of the best matches (CTcVnContainer_Vector_LREAL; Optional, set to 0 if not required; sorted corresponding to ipMatchIndexes)</param>
	/// <param name="fDissimilarityThreshold">Neglect irrelevant matches, i.e. dissimilarity &gt; fDissimilarityThreshold</param>
	/// <param name="eComparisonMethod">Method used for comparing the Hu moment invariants of the contours</param>
	/// <param name="fAreaFactor">If &gt; 0, the relative area difference between contours is scaled by this factor and added to the computed dissimilarity</param>
	/// <param name="fAbsPositionFactor">If &gt; 0, the absolute position difference between contours (i.e. the coordinates of the geometric contour centers) is scaled by this factor and added to the computed dissimilarity</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchContours1vsN(HRESULT hrPrev, ITcVnContainer* ipRefContour, ITcVnContainer* ipContours, ITcVnContainer*& ipMatchIndexes, ITcVnContainer*& ipDissimilarities, double fDissimilarityThreshold, ETcVnContoursMatchComparisonMethod eComparisonMethod, double fAreaFactor = 0, double fAbsPositionFactor = 0)
	{
		Internal::MatchContours1vsN_Params params(ipRefContour, ipContours, ipMatchIndexes, ipDissimilarities, fDissimilarityThreshold, eComparisonMethod, fAreaFactor, fAbsPositionFactor, hrPrev);

		libraryInfo.functions[771 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchDescriptorsBF_Params
		{
			ITcVnImage* ipQueryDescriptors;
			ITcVnImage* ipTrainDescriptors;
			ITcVnContainer*& ipMatches;
			ITcVnImage* ipMask;
			ETcVnNormalizationType eNormType;
			bool bCrossCheck;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchDescriptorsBF_Params(ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ITcVnImage* ipMask, ETcVnNormalizationType eNormType, bool bCrossCheck, HRESULT hrPrev) : ipQueryDescriptors(ipQueryDescriptors), ipTrainDescriptors(ipTrainDescriptors), ipMatches(ipMatches), ipMask(ipMask), eNormType(eNormType), bCrossCheck(bCrossCheck), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Match descriptors using a brute force approach. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipQueryDescriptors">Query descriptors (i.e. descriptors of a reference/template image)</param>
	/// <param name="ipTrainDescriptors">Training descriptors (i.e. descriptors of a source/input image)</param>
	/// <param name="ipMatches">Returns a container which is filled with the descriptor matches (ContainerType_Vector_TcVnDMatch; Non-zero interface pointers are reused.)</param>
	/// <param name="ipMask">Mask to specify permissable matches, i.e. query[i] can be matched with train[j] only if mask[i][j] != 0 (set to 0 if no mask required)</param>
	/// <param name="eNormType">Normalization type (only L1, L2, L2SQR, HAMMING, HAMMING2 supported). HAMMING2 should be used for ORB descriptors if the ORB nBriefPoints parameter is 3 or 4)</param>
	/// <param name="bCrossCheck">If true, only consistent matches are returned, i.e. query-&gt;train and train-&gt;query detect the same match</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchDescriptorsBF(HRESULT hrPrev, ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ITcVnImage* ipMask = nullptr, ETcVnNormalizationType eNormType = NT_L2, bool bCrossCheck = false)
	{
		Internal::MatchDescriptorsBF_Params params(ipQueryDescriptors, ipTrainDescriptors, ipMatches, ipMask, eNormType, bCrossCheck, hrPrev);

		libraryInfo.functions[772 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchDescriptorsFlannLsh_Params
		{
			ITcVnImage* ipQueryDescriptors;
			ITcVnImage* ipTrainDescriptors;
			ITcVnContainer*& ipMatches;
			ULONG nTableNumber;
			ULONG nKeySize;
			ULONG nMultiProbeLevel;
			ULONG nChecks;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchDescriptorsFlannLsh_Params(ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ULONG nTableNumber, ULONG nKeySize, ULONG nMultiProbeLevel, ULONG nChecks, HRESULT hrPrev) : ipQueryDescriptors(ipQueryDescriptors), ipTrainDescriptors(ipTrainDescriptors), ipMatches(ipMatches), nTableNumber(nTableNumber), nKeySize(nKeySize), nMultiProbeLevel(nMultiProbeLevel), nChecks(nChecks), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Match descriptors using a FLANN based approach with LSH index. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipQueryDescriptors">Query descriptors (i.e. descriptors of a reference/template image)</param>
	/// <param name="ipTrainDescriptors">Training descriptors (i.e. descriptors of a source/input image)</param>
	/// <param name="ipMatches">Returns a container which is filled with the descriptor matches (ContainerType_Vector_TcVnDMatch; Non-zero interface pointers are reused.)</param>
	/// <param name="nTableNumber">Number of tables</param>
	/// <param name="nKeySize">Key size</param>
	/// <param name="nMultiProbeLevel">Multi-probe level</param>
	/// <param name="nChecks">Maximum number of visited leafs when searching for neighbors</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchDescriptorsFlannLsh(HRESULT hrPrev, ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ULONG nTableNumber = 12, ULONG nKeySize = 20, ULONG nMultiProbeLevel = 2, ULONG nChecks = 32)
	{
		Internal::MatchDescriptorsFlannLsh_Params params(ipQueryDescriptors, ipTrainDescriptors, ipMatches, nTableNumber, nKeySize, nMultiProbeLevel, nChecks, hrPrev);

		libraryInfo.functions[773 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchDescriptorsKnnBF_Params
		{
			ITcVnImage* ipQueryDescriptors;
			ITcVnImage* ipTrainDescriptors;
			ITcVnContainer*& ipMatches;
			ULONG nK;
			ITcVnImage* ipMask;
			bool bCompactResult;
			ETcVnNormalizationType eNormType;
			bool bCrossCheck;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchDescriptorsKnnBF_Params(ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ULONG nK, ITcVnImage* ipMask, bool bCompactResult, ETcVnNormalizationType eNormType, bool bCrossCheck, HRESULT hrPrev) : ipQueryDescriptors(ipQueryDescriptors), ipTrainDescriptors(ipTrainDescriptors), ipMatches(ipMatches), nK(nK), ipMask(ipMask), bCompactResult(bCompactResult), eNormType(eNormType), bCrossCheck(bCrossCheck), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Match descriptors (k nearest neighbors) using a brute force approach. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipQueryDescriptors">Query descriptors (i.e. descriptors of a reference/template image)</param>
	/// <param name="ipTrainDescriptors">Training descriptors (i.e. descriptors of a source/input image)</param>
	/// <param name="ipMatches">Returns a container which is filled with the descriptor matches (ContainerType_Vector_Vector_TcVnDMatch; Non-zero interface pointers are reused.)</param>
	/// <param name="nK">Number of required best train matches for each query descriptor (i.e. nk := 2)</param>
	/// <param name="ipMask">Mask to specify permissable matches, i.e. query[i] can be matched with train[j] only if mask[i][j] != 0 (set to 0 if no mask required)</param>
	/// <param name="bCompactResult">If true, matches vector does not contain entries for fully masked-out query descriptors</param>
	/// <param name="eNormType">Normalization type (only L1, L2, L2SQR, HAMMING, HAMMING2 supported). HAMMING2 should be used for ORB descriptors if the ORB nBriefPoints parameter is 3 or 4)</param>
	/// <param name="bCrossCheck">If true, only consistent matches are returned, i.e. query-&gt;train and train-&gt;query detect the same match (only used if nK = 1)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchDescriptorsKnnBF(HRESULT hrPrev, ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ULONG nK, ITcVnImage* ipMask = nullptr, bool bCompactResult = false, ETcVnNormalizationType eNormType = NT_L2, bool bCrossCheck = false)
	{
		Internal::MatchDescriptorsKnnBF_Params params(ipQueryDescriptors, ipTrainDescriptors, ipMatches, nK, ipMask, bCompactResult, eNormType, bCrossCheck, hrPrev);

		libraryInfo.functions[774 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchDescriptorsKnnFlannLsh_Params
		{
			ITcVnImage* ipQueryDescriptors;
			ITcVnImage* ipTrainDescriptors;
			ITcVnContainer*& ipMatches;
			ULONG nK;
			ULONG nTableNumber;
			ULONG nKeySize;
			ULONG nMultiProbeLevel;
			ULONG nChecks;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchDescriptorsKnnFlannLsh_Params(ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ULONG nK, ULONG nTableNumber, ULONG nKeySize, ULONG nMultiProbeLevel, ULONG nChecks, HRESULT hrPrev) : ipQueryDescriptors(ipQueryDescriptors), ipTrainDescriptors(ipTrainDescriptors), ipMatches(ipMatches), nK(nK), nTableNumber(nTableNumber), nKeySize(nKeySize), nMultiProbeLevel(nMultiProbeLevel), nChecks(nChecks), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Match descriptors (k nearest neighbors) using a FLANN based approach with LSH index. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipQueryDescriptors">Query descriptors (i.e. descriptors of a reference/template image)</param>
	/// <param name="ipTrainDescriptors">Training descriptors (i.e. descriptors of a source/input image)</param>
	/// <param name="ipMatches">Returns a container which is filled with the descriptor matches (ContainerType_Vector_Vector_TcVnDMatch; Non-zero interface pointers are reused.)</param>
	/// <param name="nK">Number of required best train matches for each query descriptor (i.e. nk := 2)</param>
	/// <param name="nTableNumber">Number of tables</param>
	/// <param name="nKeySize">Key size</param>
	/// <param name="nMultiProbeLevel">Multi-probe level</param>
	/// <param name="nChecks">Maximum number of visited leafs when searching for neighbors</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchDescriptorsKnnFlannLsh(HRESULT hrPrev, ITcVnImage* ipQueryDescriptors, ITcVnImage* ipTrainDescriptors, ITcVnContainer*& ipMatches, ULONG nK, ULONG nTableNumber = 12, ULONG nKeySize = 20, ULONG nMultiProbeLevel = 2, ULONG nChecks = 32)
	{
		Internal::MatchDescriptorsKnnFlannLsh_Params params(ipQueryDescriptors, ipTrainDescriptors, ipMatches, nK, nTableNumber, nKeySize, nMultiProbeLevel, nChecks, hrPrev);

		libraryInfo.functions[775 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchImageHuMoments_Params
		{
			ITcVnImage* ipImage1;
			ITcVnImage* ipImage2;
			ETcVnContoursMatchComparisonMethod eComparisonMethod;
			double& fDissimilarity;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchImageHuMoments_Params(ITcVnImage* ipImage1, ITcVnImage* ipImage2, ETcVnContoursMatchComparisonMethod eComparisonMethod, double& fDissimilarity, HRESULT hrPrev) : ipImage1(ipImage1), ipImage2(ipImage2), eComparisonMethod(eComparisonMethod), fDissimilarity(fDissimilarity), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compare two images using the Hu moment invariants.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage1">First image (1 channel)</param>
	/// <param name="ipImage2">Second image (1 channel)</param>
	/// <param name="eComparisonMethod">Method used for comparing the Hu moment invariants of the images</param>
	/// <param name="fDissimilarity">Returns the dissimilarity of the image Hu moment invariants depending on the chosen comparison method</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchImageHuMoments(HRESULT hrPrev, ITcVnImage* ipImage1, ITcVnImage* ipImage2, ETcVnContoursMatchComparisonMethod eComparisonMethod, double& fDissimilarity)
	{
		Internal::MatchImageHuMoments_Params params(ipImage1, ipImage2, eComparisonMethod, fDissimilarity, hrPrev);

		libraryInfo.functions[776 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchTemplate_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage* ipTemplateImage;
			ITcVnImage*& ipResultImage;
			ETcVnTemplateMatchMethod eMatchMethod;
			ITcVnImage* ipTemplateMask;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchTemplate_Params(ITcVnImage* ipSrcImage, ITcVnImage* ipTemplateImage, ITcVnImage*& ipResultImage, ETcVnTemplateMatchMethod eMatchMethod, ITcVnImage* ipTemplateMask, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipTemplateImage(ipTemplateImage), ipResultImage(ipResultImage), eMatchMethod(eMatchMethod), ipTemplateMask(ipTemplateMask), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Match a template image with every location in the source image and save the comparison results. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT or REAL, 1 or 3 channels)</param>
	/// <param name="ipTemplateImage">Template image (same type as ipSrcImage, smaller width and height)</param>
	/// <param name="ipResultImage">Returns the result image (REAL, 1 channel, dimensions: (ipSrcImage.width - ipTemplateImage.width + 1) x (ipSrcImage.height - ipTemplateImage.height + 1). The best match is the global minimum (SQDIFF(_NORMED)) or maximum (CCORR(_NORMED), CCOEFF(_NORMED)). The position in ipResultImage is the top-left corner of ipTemplateImage position in ipSrcImage)</param>
	/// <param name="eMatchMethod">Specifies the template match method</param>
	/// <param name="ipTemplateMask">Optional mask for ipTemplateImage (same type and size as ipTemplateImage)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchTemplate(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage* ipTemplateImage, ITcVnImage*& ipResultImage, ETcVnTemplateMatchMethod eMatchMethod = TMM_CCORR_NORMED, ITcVnImage* ipTemplateMask = nullptr)
	{
		Internal::MatchTemplate_Params params(ipSrcImage, ipTemplateImage, ipResultImage, eMatchMethod, ipTemplateMask, hrPrev);

		libraryInfo.functions[777 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct MatchTemplateAndEvaluate_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage* ipTemplateImage;
			ITcVnContainer*& ipMatches;
			float fMatchThreshold;
			ETcVnTemplateMatchMethod eMatchMethod;
			ITcVnImage* ipTemplateMask;
			float fScaleFactor;
			ETcVnInterpolationType eInterpolationType;
			ITcVnContainer** pipMatchValues;
			HRESULT hrPrev;
			HRESULT retVal;

			MatchTemplateAndEvaluate_Params(ITcVnImage* ipSrcImage, ITcVnImage* ipTemplateImage, ITcVnContainer*& ipMatches, float fMatchThreshold, ETcVnTemplateMatchMethod eMatchMethod, ITcVnImage* ipTemplateMask, float fScaleFactor, ETcVnInterpolationType eInterpolationType, ITcVnContainer** pipMatchValues, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipTemplateImage(ipTemplateImage), ipMatches(ipMatches), fMatchThreshold(fMatchThreshold), eMatchMethod(eMatchMethod), ipTemplateMask(ipTemplateMask), fScaleFactor(fScaleFactor), eInterpolationType(eInterpolationType), pipMatchValues(pipMatchValues), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Match a template image with every location in the source image and evaluate the comparison results. Returns a sorted list of possible matches (best match first). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT or REAL, 1 or 3 channels)</param>
	/// <param name="ipTemplateImage">Template image (same type as ipSrcImage, smaller width and height)</param>
	/// <param name="ipMatches">Returns the matching positions (ContainerType_Vector_TcVnPoint2_DINT, where each element represents the top-left corner of ipTemplateImage) in ipSrcImage, sorted by relevance (best match first)</param>
	/// <param name="fMatchThreshold">Threshold to separate relevant from irrelevant matches (0..1 for NORMED methods, otherwise dependent on template size and content. To find a suitable value, you could evaluate some sample result images of F_VN_MatchTemplateExp.)</param>
	/// <param name="eMatchMethod">Specifies the template match method</param>
	/// <param name="ipTemplateMask">Optional mask for ipTemplateImage (same type and size as ipTemplateImage)</param>
	/// <param name="fScaleFactor">Factor (0..1] to reduce source and template image width and height for better performance (but less accuracy!)</param>
	/// <param name="eInterpolationType">Image resize interpolation type (only used if fScaleFactor != 1, TCVN_IT_BILINEAR recommended for most cases)</param>
	/// <param name="pipMatchValues">Optionally returns the matching values (ContainerType_Vector_REAL, same size and sort order as ipMatches. Set to 0 if not required.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT MatchTemplateAndEvaluate(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnImage* ipTemplateImage, ITcVnContainer*& ipMatches, float fMatchThreshold, ETcVnTemplateMatchMethod eMatchMethod = TMM_CCORR_NORMED, ITcVnImage* ipTemplateMask = nullptr, float fScaleFactor = 1, ETcVnInterpolationType eInterpolationType = IT_BILINEAR, ITcVnContainer** pipMatchValues = nullptr)
	{
		Internal::MatchTemplateAndEvaluate_Params params(ipSrcImage, ipTemplateImage, ipMatches, fMatchThreshold, eMatchMethod, ipTemplateMask, fScaleFactor, eInterpolationType, pipMatchValues, hrPrev);

		libraryInfo.functions[778 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		static TcVnParamsMSER RegionsMSER_stParamsDefault = {5, 60, 14400, 0.25, 0.2, 200, 1.01, 0.003, 5};

		struct RegionsMSER_Params
		{
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipRegions;
			ITcVnContainer*& ipBoundingBoxes;
			TcVnParamsMSER& stParams;
			HRESULT hrPrev;
			HRESULT retVal;

			RegionsMSER_Params(ITcVnImage* ipSrcImage, ITcVnContainer*& ipRegions, ITcVnContainer*& ipBoundingBoxes, TcVnParamsMSER& stParams, HRESULT hrPrev) : ipSrcImage(ipSrcImage), ipRegions(ipRegions), ipBoundingBoxes(ipBoundingBoxes), stParams(stParams), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects regions using the MSER method. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image</param>
	/// <param name="ipRegions">Returns a container which is filled with the region points (ContainerType_Vector_Vector_TcVnPoint2_DINT; Non-zero interface pointers are reused.)</param>
	/// <param name="ipBoundingBoxes">Returns a container which is filled with the region bounding boxes (ContainerType_Vector_TcVnRectangle_DINT; Non-zero interface pointers are reused.)</param>
	/// <param name="stParams">Additional expert parameters</param>
	/// <returns>HRESULT</returns>
	static HRESULT RegionsMSER(HRESULT hrPrev, ITcVnImage* ipSrcImage, ITcVnContainer*& ipRegions, ITcVnContainer*& ipBoundingBoxes, TcVnParamsMSER& stParams = Internal::RegionsMSER_stParamsDefault)
	{
		Internal::RegionsMSER_Params params(ipSrcImage, ipRegions, ipBoundingBoxes, stParams, hrPrev);

		libraryInfo.functions[779 - Lic4FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Vision_OCR

	namespace Internal
	{
		struct OCR_Params
		{
			ITcVnImage* ipSrcImage;
			ULONGLONG eModel;
			ITcVnContainer*& ipCharacters;
			PCCH sPattern;
			ULONG eOcrOptions;
			ITcVnContainer** pipBoundingBoxes;
			ITcVnContainer** pipConfidences;
			HRESULT hrPrev;
			HRESULT retVal;
			float fMinConfidence;

			OCR_Params(ITcVnImage* ipSrcImage, ULONGLONG eModel, ITcVnContainer*& ipCharacters, PCCH sPattern, ULONG eOcrOptions, ITcVnContainer** pipBoundingBoxes, ITcVnContainer** pipConfidences, HRESULT hrPrev) : ipSrcImage(ipSrcImage), eModel(eModel), ipCharacters(ipCharacters), sPattern(sPattern), eOcrOptions(eOcrOptions), pipBoundingBoxes(pipBoundingBoxes), pipConfidences(pipConfidences), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Detects and recognizes characters in a binary image (white characters on black background). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, binary)</param>
	/// <param name="eModel">Selection of OCR model types (ETcVnOcrModelType)</param>
	/// <param name="ipCharacters">Returns the recognized characters (ContainerType_Vector_String_SINT)</param>
	/// <param name="fMinConfidence">Returns the minimum value of the confidences</param>
	/// <param name="sPattern">String pattern containing the format in which characters are presented</param>
	/// <param name="eOcrOptions">Specifies which options must be applied to the function (ETcVnOcrOptions)</param>
	/// <param name="pipBoundingBoxes">Returns the corresponding bounding boxes of the recognized characters (ContainerType_Vector_TcVnRectangle_DINT, optional, set to 0 if not required)</param>
	/// <param name="pipConfidences">Returns the corresponding classification confidences of the recognized characters (ContainerType_Vector_REAL, optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT OCR(HRESULT hrPrev, ITcVnImage* ipSrcImage, ULONGLONG eModel, ITcVnContainer*& ipCharacters, float& fMinConfidence, PCCH sPattern = "", ULONG eOcrOptions = OO_NONE, ITcVnContainer** pipBoundingBoxes = nullptr, ITcVnContainer** pipConfidences = nullptr)
	{
		Internal::OCR_Params params(ipSrcImage, eModel, ipCharacters, sPattern, eOcrOptions, pipBoundingBoxes, pipConfidences, hrPrev);

		libraryInfo.functions[780 - Lic5FuncsOffs].pFct(&params);

		AssignTo(fMinConfidence, params.fMinConfidence);

		return params.retVal;
	}

	/// <summary>
	/// Detects and recognizes characters in a binary image (white characters on black background). 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSrcImage">Source image (USINT, 1 channel, binary)</param>
	/// <param name="eModel">Selection of OCR model types (ETcVnOcrModelType)</param>
	/// <param name="ipCharacters">Returns the recognized characters (ContainerType_Vector_String_SINT)</param>
	/// <returns>HRESULT</returns>
	static HRESULT OCR(HRESULT hrPrev, ITcVnImage* ipSrcImage, ULONGLONG eModel, ITcVnContainer*& ipCharacters)
	{
		Internal::OCR_Params params(ipSrcImage, eModel, ipCharacters, "", OO_NONE, nullptr, nullptr, hrPrev);

		libraryInfo.functions[780 - Lic5FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Machine_Learning_Realtime_Inference

	namespace Internal
	{
		struct CreateBoostClassifier_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnBoostClassifierType eType;
			ULONG nMaxDepth;
			ULONG nMinSamples;
			ULONG nWeakClassifiers;
			double fWeightTrimRate;
			ITcVnContainer* ipClassPriors;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateBoostClassifier_Params(ITcVnMlModel*& ipMlModel, ETcVnBoostClassifierType eType, ULONG nMaxDepth, ULONG nMinSamples, ULONG nWeakClassifiers, double fWeightTrimRate, ITcVnContainer* ipClassPriors, HRESULT hrPrev) : ipMlModel(ipMlModel), eType(eType), nMaxDepth(nMaxDepth), nMinSamples(nMinSamples), nWeakClassifiers(nWeakClassifiers), fWeightTrimRate(fWeightTrimRate), ipClassPriors(ipClassPriors), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a Boost classifier. The initial reference count is set to one if a new model is created and kept, otherwise. The Boost classifier is only applicable to binary classification problems. It learns to distinguish between samples labelled with two user-defined class labels by incrementally adding weak classifiers to improve the classification results. Models of this type neither support on-line training (sample by sample) nor retraining. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eType">Learning algorithm type (default: TCVN_BCT_REAL)</param>
	/// <param name="nMaxDepth">Maximum tree depth (default: 1)</param>
	/// <param name="nMinSamples">Minimum number of samples within a node required for splitting (default: 10)</param>
	/// <param name="nWeakClassifiers">Number of weak classifiers (default: 100)</param>
	/// <param name="fWeightTrimRate">Weight threshold used during training (off: 0; default: 0.95).</param>
	/// <param name="ipClassPriors">Class priors (ContainerType_Vector_REAL or ContainerType_Vector_LREAL; only for classifiers; optional, set to 0 if not required or not allowed; default: 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateBoostClassifier(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnBoostClassifierType eType = BCT_REAL, ULONG nMaxDepth = 1, ULONG nMinSamples = 10, ULONG nWeakClassifiers = 100, double fWeightTrimRate = 0.95, ITcVnContainer* ipClassPriors = nullptr)
	{
		Internal::CreateBoostClassifier_Params params(ipMlModel, eType, nMaxDepth, nMinSamples, nWeakClassifiers, fWeightTrimRate, ipClassPriors, hrPrev);

		libraryInfo.functions[781 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateKmppModel_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnPrototypeClusterer eKmppType;
			ULONG nK;
			bool bDoublePrecision;
			ULONG nMaxIterations;
			double fEpsilon;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateKmppModel_Params(ITcVnMlModel*& ipMlModel, ETcVnPrototypeClusterer eKmppType, ULONG nK, bool bDoublePrecision, ULONG nMaxIterations, double fEpsilon, HRESULT hrPrev) : ipMlModel(ipMlModel), eKmppType(eKmppType), nK(nK), bDoublePrecision(bDoublePrecision), nMaxIterations(nMaxIterations), fEpsilon(fEpsilon), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a k-means++ model of the specified type. The initial reference count is set to one if a new model is created and kept, otherwise. Models of this type neither support on-line training (sample by sample) nor retraining. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eKmppType">k-means++ model type</param>
	/// <param name="nK">Parameter k (number of clusters)</param>
	/// <param name="bDoublePrecision">If true, the model is generated with double precision (LREAL) instead of single precision (REAL). (default: FALSE)</param>
	/// <param name="nMaxIterations">Maximum number of iterations (triggers the usage of the default value of 10 if it equals 0)</param>
	/// <param name="fEpsilon">Maximum allowed difference of the error between two successive iterations (triggers the usage of the default value of 0.001 if it equals 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateKmppModel(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnPrototypeClusterer eKmppType, ULONG nK, bool bDoublePrecision = false, ULONG nMaxIterations = 0, double fEpsilon = 0.0)
	{
		Internal::CreateKmppModel_Params params(ipMlModel, eKmppType, nK, bDoublePrecision, nMaxIterations, fEpsilon, hrPrev);

		libraryInfo.functions[782 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateKnnModel_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnKnn eKnnType;
			ULONG nK;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateKnnModel_Params(ITcVnMlModel*& ipMlModel, ETcVnKnn eKnnType, ULONG nK, HRESULT hrPrev) : ipMlModel(ipMlModel), eKnnType(eKnnType), nK(nK), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a k-nearest neighbors model of the specified type. The initial reference count is set to one if a new model is created and kept, otherwise. Models of this type support on-line training (sample by sample) and retraining. Predictions can only be scalar.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eKnnType">k-nearest neighbors model type</param>
	/// <param name="nK">Parameter k used for prediction (number of considered neighbors)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateKnnModel(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnKnn eKnnType, ULONG nK)
	{
		Internal::CreateKnnModel_Params params(ipMlModel, eKnnType, nK, hrPrev);

		libraryInfo.functions[783 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateLbgModel_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnPrototypeClusterer eLbgType;
			ULONG nMaxClusters;
			double fMaxClusterRadius;
			bool bSingleSplitSteps;
			bool bDoublePrecision;
			ULONG nMaxIterations;
			double fEpsilon;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateLbgModel_Params(ITcVnMlModel*& ipMlModel, ETcVnPrototypeClusterer eLbgType, ULONG nMaxClusters, double fMaxClusterRadius, bool bSingleSplitSteps, bool bDoublePrecision, ULONG nMaxIterations, double fEpsilon, HRESULT hrPrev) : ipMlModel(ipMlModel), eLbgType(eLbgType), nMaxClusters(nMaxClusters), fMaxClusterRadius(fMaxClusterRadius), bSingleSplitSteps(bSingleSplitSteps), bDoublePrecision(bDoublePrecision), nMaxIterations(nMaxIterations), fEpsilon(fEpsilon), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a LBG model of the specified type. The initial reference count is set to one if a new model is created and kept, otherwise. Models of this type neither support on-line training (sample by sample) nor retraining. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eLbgType">LBG model type</param>
	/// <param name="nMaxClusters">Maximum number of clusters</param>
	/// <param name="fMaxClusterRadius">Maximum allowed radius (L2 norm) of a single cluster, i.e. clusters with a higher radius will be split into smaller ones, until a global number of nMaxClusters is reached.</param>
	/// <param name="bSingleSplitSteps">If true, the global optimization is always run after a single cluster has been split. If false, several clusters are split within the same step before applying the global optimization. Applying the global optimization less often is faster, but can lead to less optimal results, especially having 2 nearby clusters that could be represented by 1.</param>
	/// <param name="bDoublePrecision">If true, the model is generated with double precision (LREAL) instead of single precision (REAL). (default: FALSE)</param>
	/// <param name="nMaxIterations">Maximum number of iterations (triggers the usage of the default value of 10 if it equals 0)</param>
	/// <param name="fEpsilon">Maximum allowed difference of the error between two successive iterations (triggers the usage of the default value of 0.001 if it equals 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateLbgModel(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnPrototypeClusterer eLbgType, ULONG nMaxClusters, double fMaxClusterRadius, bool bSingleSplitSteps, bool bDoublePrecision = false, ULONG nMaxIterations = 0, double fEpsilon = 0.0)
	{
		Internal::CreateLbgModel_Params params(ipMlModel, eLbgType, nMaxClusters, fMaxClusterRadius, bSingleSplitSteps, bDoublePrecision, nMaxIterations, fEpsilon, hrPrev);

		libraryInfo.functions[784 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateLdaTransform_Params
		{
			ITcVnMlModel*& ipMlModel;
			ITcUnknown* ipSamples;
			ITcVnContainer* ipClasses;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateLdaTransform_Params(ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, ITcVnContainer* ipClasses, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSamples(ipSamples), ipClasses(ipClasses), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create an LDA-based feature transform from the provided data. The number of samples must be &gt;= the number of features and the number of classes must be &gt;= 2. The initial reference count is set to one if a new model is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created feature transform (Non-zero interface pointers are reused.)</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipClasses">Class labels corresponding to the input samples (ContainerType_Vector_DINT)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateLdaTransform(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, ITcVnContainer* ipClasses)
	{
		Internal::CreateLdaTransform_Params params(ipMlModel, ipSamples, ipClasses, hrPrev);

		libraryInfo.functions[785 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateLdaTransformViaComponentNum_Params
		{
			ITcVnMlModel*& ipMlModel;
			ITcUnknown* ipSamples;
			ITcVnContainer* ipClasses;
			ULONG nComponentNum;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateLdaTransformViaComponentNum_Params(ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, ITcVnContainer* ipClasses, ULONG nComponentNum, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSamples(ipSamples), ipClasses(ipClasses), nComponentNum(nComponentNum), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create an LDA-based feature transform from the provided data where the number of components to be used is predefined. The number of samples must be &gt;= the number of features and the number of classes must be &gt;= 2. The initial reference count is set to one if a new model is created and kept, otherwise. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created feature transform (Non-zero interface pointers are reused.)</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipClasses">Class labels corresponding to the input samples (ContainerType_Vector_DINT)</param>
	/// <param name="nComponentNum">Number of components (nComponentNum must be smaller than the number of classes. A value of 0 results in the automatic computation of the maximum number of components.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateLdaTransformViaComponentNum(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, ITcVnContainer* ipClasses, ULONG nComponentNum)
	{
		Internal::CreateLdaTransformViaComponentNum_Params params(ipMlModel, ipSamples, ipClasses, nComponentNum, hrPrev);

		libraryInfo.functions[786 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateNbcModel_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnNbc eNbcType;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateNbcModel_Params(ITcVnMlModel*& ipMlModel, ETcVnNbc eNbcType, HRESULT hrPrev) : ipMlModel(ipMlModel), eNbcType(eNbcType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a normal Bayes classifier of the specified type. The initial reference count is set to one if a new model is created and kept, otherwise. In order to train normal Bayes classifiers, a sufficiently high number of samples is required for each class. It depends on the number of features and the distribution of the data. Hence, it needs to be tested for each application. Models of this type do not support on-line training (sample by sample). For the retraining of such classifier models, the set of presented classes must be identical to the previous learning steps. Otherwise, an exception is raised.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eNbcType">Normal Bayes classifier type</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateNbcModel(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnNbc eNbcType)
	{
		Internal::CreateNbcModel_Params params(ipMlModel, eNbcType, hrPrev);

		libraryInfo.functions[787 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreatePcaTransform_Params
		{
			ITcVnMlModel*& ipMlModel;
			ITcUnknown* ipSamples;
			HRESULT hrPrev;
			HRESULT retVal;

			CreatePcaTransform_Params(ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSamples(ipSamples), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a PCA-based feature transform from the provided data. The maximum number of principal components that can be computed equals the minimum of the number of samples and the number of features. The initial reference count is set to one if a new model is created and kept, otherwise.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created feature transform (Non-zero interface pointers are reused.)</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreatePcaTransform(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples)
	{
		Internal::CreatePcaTransform_Params params(ipMlModel, ipSamples, hrPrev);

		libraryInfo.functions[788 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreatePcaTransformViaComponentNum_Params
		{
			ITcVnMlModel*& ipMlModel;
			ITcUnknown* ipSamples;
			ULONG nComponentNum;
			HRESULT hrPrev;
			HRESULT retVal;

			CreatePcaTransformViaComponentNum_Params(ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, ULONG nComponentNum, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSamples(ipSamples), nComponentNum(nComponentNum), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a PCA-based feature transform from the provided data where the number of prinicpal components to be used is predefined. The maximum number of principal components that can be computed equals the minimum of the number of samples and the number of features. The initial reference count is set to one if a new model is created and kept, otherwise. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created feature transform (Non-zero interface pointers are reused.)</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="nComponentNum">Number of principal components (A value of 0 results in the automatic computation of the maximum number of components.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreatePcaTransformViaComponentNum(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, ULONG nComponentNum)
	{
		Internal::CreatePcaTransformViaComponentNum_Params params(ipMlModel, ipSamples, nComponentNum, hrPrev);

		libraryInfo.functions[789 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreatePcaTransformViaVariance_Params
		{
			ITcVnMlModel*& ipMlModel;
			ITcUnknown* ipSamples;
			double fRetainedVariance;
			HRESULT hrPrev;
			HRESULT retVal;

			CreatePcaTransformViaVariance_Params(ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, double fRetainedVariance, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSamples(ipSamples), fRetainedVariance(fRetainedVariance), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a PCA-based feature transform from the provided data based on a given fraction of variance to be retained. The maximum number of principal components that can be computed equals the minimum of the number of samples and the number of features. The initial reference count is set to one if a new model is created and kept, otherwise. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created feature transform (Non-zero interface pointers are reused.)</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="fRetainedVariance">Fraction of variance that is to be retained by the PCA (A value of 1.0 signifies 100%.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreatePcaTransformViaVariance(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ITcUnknown* ipSamples, double fRetainedVariance)
	{
		Internal::CreatePcaTransformViaVariance_Params params(ipMlModel, ipSamples, fRetainedVariance, hrPrev);

		libraryInfo.functions[790 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateRTreesModel_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnRTrees eRTreesType;
			ULONG nMaxDepth;
			ULONG nMinSamples;
			ULONG nActiveVariables;
			ULONG nMaxIterations;
			double fEpsilon;
			float fRegressionAccuracy;
			ITcVnContainer* ipClassPriors;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateRTreesModel_Params(ITcVnMlModel*& ipMlModel, ETcVnRTrees eRTreesType, ULONG nMaxDepth, ULONG nMinSamples, ULONG nActiveVariables, ULONG nMaxIterations, double fEpsilon, float fRegressionAccuracy, ITcVnContainer* ipClassPriors, HRESULT hrPrev) : ipMlModel(ipMlModel), eRTreesType(eRTreesType), nMaxDepth(nMaxDepth), nMinSamples(nMinSamples), nActiveVariables(nActiveVariables), nMaxIterations(nMaxIterations), fEpsilon(fEpsilon), fRegressionAccuracy(fRegressionAccuracy), ipClassPriors(ipClassPriors), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a random trees model of the specified type. The initial reference count is set to one if a new model is created and kept, otherwise. Models of this type neither support on-line training (sample by sample) nor retraining. Predictions can only be scalar. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eRTreesType">Random trees model type</param>
	/// <param name="nMaxDepth">Maximum tree depth (default: 5)</param>
	/// <param name="nMinSamples">Minimum number of samples within a node required for splitting (default: 10)</param>
	/// <param name="nActiveVariables">Number of variables considered for splitting (0 means sqrt(total number of variables); default: 0)</param>
	/// <param name="nMaxIterations">Maximum number of iterations (disabled if it equals 0 and fEpsilon is different from 0.0; triggers the usage of the default value of 50 if nMaxIterations and fEpsilon equal 0)</param>
	/// <param name="fEpsilon">Maximum allowed difference of the error between two successive iterations (disabled if it equals 0.0 and nMaxIterations is different from 0; triggers the usage of the default value of 0.1 if nMaxIterations and fEpsilon equal 0)</param>
	/// <param name="fRegressionAccuracy">Termination criterion for regressors (only for regressors; set to default if not allowed; default: 0.0)</param>
	/// <param name="ipClassPriors">Class priors (ContainerType_Vector_REAL or ContainerType_Vector_LREAL; only for classifiers; optional, set to 0 if not required or not allowed; default: 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateRTreesModel(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnRTrees eRTreesType, ULONG nMaxDepth = 5, ULONG nMinSamples = 10, ULONG nActiveVariables = 0, ULONG nMaxIterations = 0, double fEpsilon = 0.0, float fRegressionAccuracy = 0, ITcVnContainer* ipClassPriors = nullptr)
	{
		Internal::CreateRTreesModel_Params params(ipMlModel, eRTreesType, nMaxDepth, nMinSamples, nActiveVariables, nMaxIterations, fEpsilon, fRegressionAccuracy, ipClassPriors, hrPrev);

		libraryInfo.functions[791 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateStaModel_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnSta eStaType;
			double fRho;
			ULONG nNu;
			bool bDoublePrecision;
			double fBetaSbm;
			ULONG nPhi;
			ULONG nTau;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateStaModel_Params(ITcVnMlModel*& ipMlModel, ETcVnSta eStaType, double fRho, ULONG nNu, bool bDoublePrecision, double fBetaSbm, ULONG nPhi, ULONG nTau, HRESULT hrPrev) : ipMlModel(ipMlModel), eStaType(eStaType), fRho(fRho), nNu(nNu), bDoublePrecision(bDoublePrecision), fBetaSbm(fBetaSbm), nPhi(nPhi), nTau(nTau), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a Simplified TopoART neural network of the specified type. The initial reference count is set to one if a new model is created and kept, otherwise. Models of this type support on-line training (sample by sample), retraining, as well as scalar and vectorial predictions. It requires all input except class labels (i.e., samples and training outputs/predictions) to lie in the interval [0.0, 1.0]. The predictions of regressors need to be rescaled from the interval [0.0, 1.0] to their respective value range before usage. Depending on the parameter settings and the number of available training samples, repeated training with the same data may improve the results. Like other neural networks based on the Adaptive Resonance Theory (ART), Simplified TopoART neural networks are not prone to catastrophic inference and patricularly well-suited to incremental learning tasks. (additional expert function providing parameters for fine-tuning and noise reduction)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eStaType">Simpified TopoART model type</param>
	/// <param name="fRho">Vigilance parameter (controls the number of neurons that are inserted and the maximum size of the formed categories; valid range: [0.0, 1.0]; suggested range: [0.8, 1.0))</param>
	/// <param name="nNu">Number of neurons used for classification and prediction (must be larger than or equal to 1; suggested range: [1, 10); default: 3)</param>
	/// <param name="bDoublePrecision">If true, the model is generated with double precision (LREAL) instead of single precision (REAL). (default: FALSE)</param>
	/// <param name="fBetaSbm">Learning rate of the second best-matching neuron (learning the second best-matching neuron keeps related categories closer together and might improve the results but may require a higher number of neurons and training runs; a value of 0.0 disables learning of the second best-matching neuron; valid range: [0.0, 1.0]; suggested range: [0.0, 0.5]); default: 0.0</param>
	/// <param name="nPhi">Number of samples a neuron must have learnt to become permanent (required for noise reduction; works in conjunction with nTau; must be larger than or equal to 1; higher values intensify noise reduction; a value of 1 disables removal of neuron candidates; default: 1)</param>
	/// <param name="nTau">Number of learning steps after which node removal is performed (required for noise reduction; works in conjunction with nPhi; must be large enough to allow neuron candidates representing non-noise samples to become the best-matching neuron at least nPhi times before node removal; default: 100)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateStaModel(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnSta eStaType, double fRho, ULONG nNu = 3, bool bDoublePrecision = false, double fBetaSbm = 0.0, ULONG nPhi = 1, ULONG nTau = 100)
	{
		Internal::CreateStaModel_Params params(ipMlModel, eStaType, fRho, nNu, bDoublePrecision, fBetaSbm, nPhi, nTau, hrPrev);

		libraryInfo.functions[792 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateSvmModel_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnSvm eSvmType;
			double fC;
			double fNu;
			double fP;
			ETcVnSvmKernelType eKernelType;
			double fGamma;
			double fCoef0;
			double fDegree;
			ULONG nMaxIterations;
			double fEpsilon;
			ITcVnContainer* ipClassWeights;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateSvmModel_Params(ITcVnMlModel*& ipMlModel, ETcVnSvm eSvmType, double fC, double fNu, double fP, ETcVnSvmKernelType eKernelType, double fGamma, double fCoef0, double fDegree, ULONG nMaxIterations, double fEpsilon, ITcVnContainer* ipClassWeights, HRESULT hrPrev) : ipMlModel(ipMlModel), eSvmType(eSvmType), fC(fC), fNu(fNu), fP(fP), eKernelType(eKernelType), fGamma(fGamma), fCoef0(fCoef0), fDegree(fDegree), nMaxIterations(nMaxIterations), fEpsilon(fEpsilon), ipClassWeights(ipClassWeights), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create an SVM model of the specified type. The initial reference count is set to one if a new model is created and kept, otherwise. Models of this type neither support on-line training (sample by sample) nor retraining. Predictions can only be scalar. (additional expert function for C support vector classifiers)
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eSvmType">SVM model type</param>
	/// <param name="fC">Parameter C (required for TCVN_SVM_C_CLASSIFIER, TCVN_SVM_EPS_REGRESSOR, and TCVN_SVM_NU_REGRESSOR; ignored otherwise)</param>
	/// <param name="fNu">Parameter nu (required for TCVN_SVM_NU_CLASSIFIER, TCVN_SVM_NOVELTY_DETECTOR, and TCVN_SVM_NU_REGRESSOR; ignored otherwise)</param>
	/// <param name="fP">Parameter p (required for TCVN_SVM_EPS_REGRESSOR; ignored otherwise)</param>
	/// <param name="eKernelType">Kernel type</param>
	/// <param name="fGamma">Parameter gamma (used by polynomial, RBF, sigmoid, and chi-squared kernels; ignored otherwise)</param>
	/// <param name="fCoef0">Parameter coef0 (used by polynomial and sigmoid kernels; ignored otherwise)</param>
	/// <param name="fDegree">Degree (used by polynomial kernels; ignored otherwise)</param>
	/// <param name="nMaxIterations">Maximum number of iterations (disabled if it equals 0 and fEpsilon is different from 0.0; triggers the usage of the default value of 100000 if nMaxIterations and fEpsilon equal 0)</param>
	/// <param name="fEpsilon">Maximum allowed difference of the error between two successive iterations (disabled if it equals 0.0 and nMaxIterations is different from 0; triggers the usage of the default value of 0.00001 if nMaxIterations and fEpsilon equal 0)</param>
	/// <param name="ipClassWeights">Class weights (ContainerType_Vector_REAL or ContainerType_Vector_LREAL; only valid if eSvmType equals TCVN_SVM_C_CLASSIFIER; optional, set to 0 if not required or not allowed; default: 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateSvmModel(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnSvm eSvmType, double fC, double fNu, double fP, ETcVnSvmKernelType eKernelType, double fGamma, double fCoef0, double fDegree, ULONG nMaxIterations = 0, double fEpsilon = 0.0, ITcVnContainer* ipClassWeights = nullptr)
	{
		Internal::CreateSvmModel_Params params(ipMlModel, eSvmType, fC, fNu, fP, eKernelType, fGamma, fCoef0, fDegree, nMaxIterations, fEpsilon, ipClassWeights, hrPrev);

		libraryInfo.functions[793 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct CreateSvmSgdClassifier_Params
		{
			ITcVnMlModel*& ipMlModel;
			ETcVnSvmSgdClassifierType eType;
			ETcVnSvmSgdClassifierMarginType eMarginType;
			float fMarginRegularization;
			float fInitialStepSize;
			float fStepDecreasingPower;
			ULONG nMaxIterations;
			double fEpsilon;
			HRESULT hrPrev;
			HRESULT retVal;

			CreateSvmSgdClassifier_Params(ITcVnMlModel*& ipMlModel, ETcVnSvmSgdClassifierType eType, ETcVnSvmSgdClassifierMarginType eMarginType, float fMarginRegularization, float fInitialStepSize, float fStepDecreasingPower, ULONG nMaxIterations, double fEpsilon, HRESULT hrPrev) : ipMlModel(ipMlModel), eType(eType), eMarginType(eMarginType), fMarginRegularization(fMarginRegularization), fInitialStepSize(fInitialStepSize), fStepDecreasingPower(fStepDecreasingPower), nMaxIterations(nMaxIterations), fEpsilon(fEpsilon), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Create a linear SVM classifier using stochastic gradient descent for training. The initial reference count is set to one if a new model is created and kept, otherwise. This SVM classifier is only applicable to binary classification problems. It learns a separating hyperplane between a class with label -1 and a class with label 1. These class labels are predefined. For training, any positive class labels are mapped to 1 and any negative class labels are mapped to -1. Models of this type neither support on-line training (sample by sample) nor retraining. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Returns the created model (Non-zero interface pointers are reused.)</param>
	/// <param name="eType">Learning algorithm type (default: TCVN_SSCT_ASGD)</param>
	/// <param name="eMarginType">Margin type (default: TCVN_SSCMT_SOFT_MARGIN)</param>
	/// <param name="fMarginRegularization">Margin regularization parameter (default: 0.00001)</param>
	/// <param name="fInitialStepSize">Initial step size (default: 0.05)</param>
	/// <param name="fStepDecreasingPower">Power parameter (default: 0.75)</param>
	/// <param name="nMaxIterations">Maximum number of iterations (disabled if it equals 0 and fEpsilon is different from 0.0; triggers the usage of the default value of 100000 if nMaxIterations and fEpsilon equal 0)</param>
	/// <param name="fEpsilon">Maximum allowed difference of the error between two successive iterations (disabled if it equals 0.0 and nMaxIterations is different from 0; triggers the usage of the default value of 0.00001 if nMaxIterations and fEpsilon equal 0)</param>
	/// <returns>HRESULT</returns>
	static HRESULT CreateSvmSgdClassifier(HRESULT hrPrev, ITcVnMlModel*& ipMlModel, ETcVnSvmSgdClassifierType eType = SSCT_ASGD, ETcVnSvmSgdClassifierMarginType eMarginType = SSCMT_SOFT_MARGIN, float fMarginRegularization = 0.00001f, float fInitialStepSize = 0.05f, float fStepDecreasingPower = 0.75f, ULONG nMaxIterations = 0, double fEpsilon = 0.0)
	{
		Internal::CreateSvmSgdClassifier_Params params(ipMlModel, eType, eMarginType, fMarginRegularization, fInitialStepSize, fStepDecreasingPower, nMaxIterations, fEpsilon, hrPrev);

		libraryInfo.functions[794 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FeatureScaling_Params
		{
			ITcVnContainer* ipSamples;
			ITcVnContainer* ipScales;
			ITcVnContainer*& ipScaledSamples;
			double fA;
			double fB;
			HRESULT hrPrev;
			HRESULT retVal;

			FeatureScaling_Params(ITcVnContainer* ipSamples, ITcVnContainer* ipScales, ITcVnContainer*& ipScaledSamples, double fA, double fB, HRESULT hrPrev) : ipSamples(ipSamples), ipScales(ipScales), ipScaledSamples(ipScaledSamples), fA(fA), fB(fB), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a feature scaling to one or more sample(s) and get output range between [fA, fB] in the case of TCVN_FST1_MINMAX. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSamples">Container holding one or more input sample(s) (ContainerType_Vector_REAL, ContainerType_Vector_LREAL, ContainerType_Vector_Vector_REAL, or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipScales">Container with the scaling parameters of each feature (type ContainerType_Vector_REAL or ContainerType_Vector_LREAL).</param>
	/// <param name="ipScaledSamples">Returns the scaled sample(s) using the same type like ipSamples. If the same container ipSamples is uesd, the source data will be replaced.</param>
	/// <param name="fA">represents the lower bound of the range for TCVN_FST1_MINMAX</param>
	/// <param name="fB">represents the upper bound of the range for TCVN_FST1_MINMAX</param>
	/// <returns>HRESULT</returns>
	static HRESULT FeatureScaling(HRESULT hrPrev, ITcVnContainer* ipSamples, ITcVnContainer* ipScales, ITcVnContainer*& ipScaledSamples, double fA = 0.0, double fB = 1.0)
	{
		Internal::FeatureScaling_Params params(ipSamples, ipScales, ipScaledSamples, fA, fB, hrPrev);

		libraryInfo.functions[795 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct FeatureTransform_Params
		{
			ITcVnMlModel* ipFeatureTransform;
			ITcUnknown* ipSamples;
			ITcUnknown** pipTransformed;
			HRESULT hrPrev;
			HRESULT retVal;

			FeatureTransform_Params(ITcVnMlModel* ipFeatureTransform, ITcUnknown* ipSamples, ITcUnknown** pipTransformed, HRESULT hrPrev) : ipFeatureTransform(ipFeatureTransform), ipSamples(ipSamples), pipTransformed(pipTransformed), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply a feature transform to one or more sample(s).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFeatureTransform">Feature transform instance to be used</param>
	/// <param name="ipSamples">Container holding one or more of input sample(s) (ContainerType_Vector_REAL, ContainerType_Vector_LREAL, ContainerType_Vector_Vector_REAL, or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="pipTransformed">Returns the transformed sample(s) using the same type like ipSamples</param>
	/// <returns>HRESULT</returns>
	static HRESULT FeatureTransform(HRESULT hrPrev, ITcVnMlModel* ipFeatureTransform, ITcUnknown* ipSamples, ITcUnknown** pipTransformed)
	{
		Internal::FeatureTransform_Params params(ipFeatureTransform, ipSamples, pipTransformed, hrPrev);

		libraryInfo.functions[796 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetBatchClusters_Params
		{
			ITcVnMlModel* ipClusterer;
			ITcUnknown* ipSamples;
			ITcVnContainer*& ipClusters;
			ITcVnContainer** pipNovelties;
			HRESULT hrPrev;
			HRESULT retVal;

			GetBatchClusters_Params(ITcVnMlModel* ipClusterer, ITcUnknown* ipSamples, ITcVnContainer*& ipClusters, ITcVnContainer** pipNovelties, HRESULT hrPrev) : ipClusterer(ipClusterer), ipSamples(ipSamples), ipClusters(ipClusters), pipNovelties(pipNovelties), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the IDs of the best-matching clusters of a batch of samples.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClusterer">Clusterer to be used</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipClusters">Returns the cluster IDs (ContainerType_Vector_DINT)</param>
	/// <param name="pipNovelties">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of each sample (ContainerType_Vector_REAL; optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetBatchClusters(HRESULT hrPrev, ITcVnMlModel* ipClusterer, ITcUnknown* ipSamples, ITcVnContainer*& ipClusters, ITcVnContainer** pipNovelties = nullptr)
	{
		Internal::GetBatchClusters_Params params(ipClusterer, ipSamples, ipClusters, pipNovelties, hrPrev);

		libraryInfo.functions[797 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetBatchNovelties_Params
		{
			ITcVnMlModel* ipNoveltyDetector;
			ITcUnknown* ipSamples;
			ITcVnContainer*& ipNovelties;
			HRESULT hrPrev;
			HRESULT retVal;

			GetBatchNovelties_Params(ITcVnMlModel* ipNoveltyDetector, ITcUnknown* ipSamples, ITcVnContainer*& ipNovelties, HRESULT hrPrev) : ipNoveltyDetector(ipNoveltyDetector), ipSamples(ipSamples), ipNovelties(ipNovelties), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the degree of novelty of multiple samples.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNoveltyDetector">Novelty detector to be used</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipNovelties">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of each sample (ContainerType_Vector_REAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetBatchNovelties(HRESULT hrPrev, ITcVnMlModel* ipNoveltyDetector, ITcUnknown* ipSamples, ITcVnContainer*& ipNovelties)
	{
		Internal::GetBatchNovelties_Params params(ipNoveltyDetector, ipSamples, ipNovelties, hrPrev);

		libraryInfo.functions[798 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetClusterCenter_Params
		{
			ITcVnMlModel* ipClusterer;
			LONG nCluster;
			ITcVnContainer*& ipCenter;
			HRESULT hrPrev;
			HRESULT retVal;

			GetClusterCenter_Params(ITcVnMlModel* ipClusterer, LONG nCluster, ITcVnContainer*& ipCenter, HRESULT hrPrev) : ipClusterer(ipClusterer), nCluster(nCluster), ipCenter(ipCenter), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the center of a cluster.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClusterer">Clusterer to be used</param>
	/// <param name="nCluster">Cluster ID of the cluster the center of which is requested</param>
	/// <param name="ipCenter">Returns the cluster center (ContainerType_Vector_REAL or ContainerType_Vector_LREAL depending on the floating point type internally used by the clusterer)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetClusterCenter(HRESULT hrPrev, ITcVnMlModel* ipClusterer, LONG nCluster, ITcVnContainer*& ipCenter)
	{
		Internal::GetClusterCenter_Params params(ipClusterer, nCluster, ipCenter, hrPrev);

		libraryInfo.functions[799 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetClusterNum_Params
		{
			ITcVnMlModel* ipClusterer;
			ULONGLONG& nClusterNum;
			HRESULT hrPrev;
			HRESULT retVal;

			GetClusterNum_Params(ITcVnMlModel* ipClusterer, ULONGLONG& nClusterNum, HRESULT hrPrev) : ipClusterer(ipClusterer), nClusterNum(nClusterNum), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the number of clusters used by this clusterer.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClusterer">Clusterer to be used</param>
	/// <param name="nClusterNum">Returns the number of clusters</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetClusterNum(HRESULT hrPrev, ITcVnMlModel* ipClusterer, ULONGLONG& nClusterNum)
	{
		Internal::GetClusterNum_Params params(ipClusterer, nClusterNum, hrPrev);

		libraryInfo.functions[800 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetFeatureScales_Params
		{
			ITcVnContainer* ipSamples;
			ITcVnContainer*& ipScales;
			ETcVnFeatureScalingType eFeatureScalingType;
			HRESULT hrPrev;
			HRESULT retVal;

			GetFeatureScales_Params(ITcVnContainer* ipSamples, ITcVnContainer*& ipScales, ETcVnFeatureScalingType eFeatureScalingType, HRESULT hrPrev) : ipSamples(ipSamples), ipScales(ipScales), eFeatureScalingType(eFeatureScalingType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Calculate the scaling parameters for each feature in the input samples based on the scaling type.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSamples">Container holding input sample(s) (ContainerType_Vector_REAL, ContainerType_Vector_LREAL, ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipScales">Returns a container with the scaling parameters for each feature (Vector_REAL or Vector_LREAL depending on the type of ipSamples).</param>
	/// <param name="eFeatureScalingType">Feature scaling type</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetFeatureScales(HRESULT hrPrev, ITcVnContainer* ipSamples, ITcVnContainer*& ipScales, ETcVnFeatureScalingType eFeatureScalingType)
	{
		Internal::GetFeatureScales_Params params(ipSamples, ipScales, eFeatureScalingType, hrPrev);

		libraryInfo.functions[801 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetSampleCluster_Params
		{
			ITcVnMlModel* ipClusterer;
			ITcUnknown* ipSample;
			LONG& nCluster;
			float* pNovelty;
			HRESULT hrPrev;
			HRESULT retVal;

			GetSampleCluster_Params(ITcVnMlModel* ipClusterer, ITcUnknown* ipSample, LONG& nCluster, float* pNovelty, HRESULT hrPrev) : ipClusterer(ipClusterer), ipSample(ipSample), nCluster(nCluster), pNovelty(pNovelty), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the ID of the best-matching cluster of a single sample. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClusterer">Clusterer to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="nCluster">Returns the ID of the cluster the sample has been assigned to</param>
	/// <param name="pNovelty">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of the presented sample (optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetSampleCluster(HRESULT hrPrev, ITcVnMlModel* ipClusterer, ITcUnknown* ipSample, LONG& nCluster, float* pNovelty = nullptr)
	{
		Internal::GetSampleCluster_Params params(ipClusterer, ipSample, nCluster, pNovelty, hrPrev);

		libraryInfo.functions[802 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetSampleNovelty_Params
		{
			ITcVnMlModel* ipNoveltyDetector;
			ITcUnknown* ipSample;
			float& fNovelty;
			HRESULT hrPrev;
			HRESULT retVal;

			GetSampleNovelty_Params(ITcVnMlModel* ipNoveltyDetector, ITcUnknown* ipSample, float& fNovelty, HRESULT hrPrev) : ipNoveltyDetector(ipNoveltyDetector), ipSample(ipSample), fNovelty(fNovelty), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the degree of novelty of a single sample.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNoveltyDetector">Novelty detector to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="fNovelty">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of the presented sample</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetSampleNovelty(HRESULT hrPrev, ITcVnMlModel* ipNoveltyDetector, ITcUnknown* ipSample, float& fNovelty)
	{
		Internal::GetSampleNovelty_Params params(ipNoveltyDetector, ipSample, fNovelty, hrPrev);

		libraryInfo.functions[803 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct Granulometry_Params
		{
			ITcVnImage* ipImage;
			ITcVnContainer*& ipIntensityDiffs;
			ETcVnMorphologicalOperator eMorphType;
			ULONG nMinSize;
			ULONG nMaxSize;
			ULONG nStep;
			HRESULT hrPrev;
			HRESULT retVal;

			Granulometry_Params(ITcVnImage* ipImage, ITcVnContainer*& ipIntensityDiffs, ETcVnMorphologicalOperator eMorphType, ULONG nMinSize, ULONG nMaxSize, ULONG nStep, HRESULT hrPrev) : ipImage(ipImage), ipIntensityDiffs(ipIntensityDiffs), eMorphType(eMorphType), nMinSize(nMinSize), nMaxSize(nMaxSize), nStep(nStep), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the granulometry of a textured image using morphological operations.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image (1 channel)</param>
	/// <param name="ipIntensityDiffs">Returns the intensity differences between successive structuring element sizes (CTcVnContainer_Vector_LREAL), which can be used as features for texture description.</param>
	/// <param name="eMorphType">Only opening or closing are supported.</param>
	/// <param name="nMinSize">Min structuring element size (odd, &gt;= 3)</param>
	/// <param name="nMaxSize">Max structuring element size (&gt;= nMinSize)</param>
	/// <param name="nStep">Step, by which nMinSize is incremented until nMaxSize is exceeded (even, &gt;= 2).</param>
	/// <returns>HRESULT</returns>
	static HRESULT Granulometry(HRESULT hrPrev, ITcVnImage* ipImage, ITcVnContainer*& ipIntensityDiffs, ETcVnMorphologicalOperator eMorphType, ULONG nMinSize, ULONG nMaxSize, ULONG nStep)
	{
		Internal::Granulometry_Params params(ipImage, ipIntensityDiffs, eMorphType, nMinSize, nMaxSize, nStep, hrPrev);

		libraryInfo.functions[804 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct HaralickFeatures_Params
		{
			ITcVnImage* ipImage;
			ITcVnContainer*& ipFeatures;
			ULONG nDist;
			HRESULT hrPrev;
			HRESULT retVal;

			HaralickFeatures_Params(ITcVnImage* ipImage, ITcVnContainer*& ipFeatures, ULONG nDist, HRESULT hrPrev) : ipImage(ipImage), ipFeatures(ipFeatures), nDist(nDist), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Computes the Haralick features of a graylevel image, which describe the texture.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipImage">Source image (1 channel, USINT)</param>
	/// <param name="ipFeatures">Returns the computed Haralick features (CTcVnContainer_Vector_LREAL). The returned feature set contains the mean and standard deviation for each of the first 13 Haralick features, computed for 0, 45, 90, 135 degrees. So there will be 26 features in total (f1 mean, f1 stdDev, f2 mean, f2 stdDev, ..., f13 mean, f13 stdDev).</param>
	/// <param name="nDist">Distance</param>
	/// <returns>HRESULT</returns>
	static HRESULT HaralickFeatures(HRESULT hrPrev, ITcVnImage* ipImage, ITcVnContainer*& ipFeatures, ULONG nDist)
	{
		Internal::HaralickFeatures_Params params(ipImage, ipFeatures, nDist, hrPrev);

		libraryInfo.functions[805 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InverseFeatureScaling_Params
		{
			ITcVnContainer* ipSamples;
			ITcVnContainer* ipScales;
			ITcVnContainer*& ipInverseSamples;
			double fA;
			double fB;
			HRESULT hrPrev;
			HRESULT retVal;

			InverseFeatureScaling_Params(ITcVnContainer* ipSamples, ITcVnContainer* ipScales, ITcVnContainer*& ipInverseSamples, double fA, double fB, HRESULT hrPrev) : ipSamples(ipSamples), ipScales(ipScales), ipInverseSamples(ipInverseSamples), fA(fA), fB(fB), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply the inverse of feature scaling to one or more sample(s). [fA, fB] should be used if the scaling has been performed using TCVN_FST1_MINMAX with a predetermined output range.. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipSamples">Container holding one or more input sample(s) (ContainerType_Vector_REAL, ContainerType_Vector_LREAL, ContainerType_Vector_Vector_REAL, or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipScales">Container with the scaling parameters of each feature (type ContainerType_Vector_REAL or ContainerType_Vector_LREAL).</param>
	/// <param name="ipInverseSamples">Returns the inversed sample(s) using the scaling type and parameters of ipScales. It has the same type of ipSamples. If the same container ipSamples is used, the source data will be replaced.</param>
	/// <param name="fA">represents the lower bound of the range for TCVN_FST1_MINMAX</param>
	/// <param name="fB">represents the upper bound of the range for TCVN_FST1_MINMAX</param>
	/// <returns>HRESULT</returns>
	static HRESULT InverseFeatureScaling(HRESULT hrPrev, ITcVnContainer* ipSamples, ITcVnContainer* ipScales, ITcVnContainer*& ipInverseSamples, double fA = 0.0, double fB = 1.0)
	{
		Internal::InverseFeatureScaling_Params params(ipSamples, ipScales, ipInverseSamples, fA, fB, hrPrev);

		libraryInfo.functions[806 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InverseFeatureScaling_REAL_Params
		{
			float fSample;
			ITcVnContainer* ipScales;
			float& fInverseSample;
			double fA;
			double fB;
			HRESULT hrPrev;
			HRESULT retVal;

			InverseFeatureScaling_REAL_Params(float fSample, ITcVnContainer* ipScales, float& fInverseSample, double fA, double fB, HRESULT hrPrev) : fSample(fSample), ipScales(ipScales), fInverseSample(fInverseSample), fA(fA), fB(fB), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply the inverse of feature scaling to a single value. [fA, fB] should be used if the scaling has been performed using TCVN_FST1_MINMAX with a predetermined output range.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="fSample">Sample value</param>
	/// <param name="ipScales">Container with the scaling parameters of each feature (type ContainerType_Vector_REAL or ContainerType_Vector_LREAL).</param>
	/// <param name="fInverseSample">Returns the inversed sample.</param>
	/// <param name="fA">represents the lower bound of the range for TCVN_FST1_MINMAX</param>
	/// <param name="fB">represents the upper bound of the range for TCVN_FST1_MINMAX</param>
	/// <returns>HRESULT</returns>
	static HRESULT InverseFeatureScaling(HRESULT hrPrev, float fSample, ITcVnContainer* ipScales, float& fInverseSample, double fA = 0.0, double fB = 1.0)
	{
		Internal::InverseFeatureScaling_REAL_Params params(fSample, ipScales, fInverseSample, fA, fB, hrPrev);

		libraryInfo.functions[807 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct InverseFeatureTransform_Params
		{
			ITcVnMlModel* ipFeatureTransform;
			ITcUnknown* ipSamples;
			ITcUnknown** pipTransformed;
			HRESULT hrPrev;
			HRESULT retVal;

			InverseFeatureTransform_Params(ITcVnMlModel* ipFeatureTransform, ITcUnknown* ipSamples, ITcUnknown** pipTransformed, HRESULT hrPrev) : ipFeatureTransform(ipFeatureTransform), ipSamples(ipSamples), pipTransformed(pipTransformed), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Apply an inverse feature transform to one or more sample(s).
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipFeatureTransform">Feature transform instance to be used</param>
	/// <param name="ipSamples">Container holding one or more of input sample(s) (ContainerType_Vector_REAL, ContainerType_Vector_LREAL, ContainerType_Vector_Vector_REAL, or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="pipTransformed">Returns the transformed sample(s) using the same type like ipSamples</param>
	/// <returns>HRESULT</returns>
	static HRESULT InverseFeatureTransform(HRESULT hrPrev, ITcVnMlModel* ipFeatureTransform, ITcUnknown* ipSamples, ITcUnknown** pipTransformed)
	{
		Internal::InverseFeatureTransform_Params params(ipFeatureTransform, ipSamples, pipTransformed, hrPrev);

		libraryInfo.functions[808 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PredictBatch_Params
		{
			ITcVnMlModel* ipMlModel;
			ITcUnknown* ipSamples;
			ITcVnContainer*& ipPredictions;
			ITcVnContainer** pipNovelties;
			HRESULT hrPrev;
			HRESULT retVal;

			PredictBatch_Params(ITcVnMlModel* ipMlModel, ITcUnknown* ipSamples, ITcVnContainer*& ipPredictions, ITcVnContainer** pipNovelties, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSamples(ipSamples), ipPredictions(ipPredictions), pipNovelties(pipNovelties), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute predictions for a batch of samples. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Classifier or regressor to be used</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipPredictions">Returns the predicted outputs (depending on ipSamples; class labels (for classification, ContainerType_Vector_DINT) or real-valued predictions (for regression with scalar output, ContainerType_Vector_REAL or ContainerType_Vector_LREAL; for regression with vectorial output, ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL))</param>
	/// <param name="pipNovelties">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of each sample (ContainerType_Vector_REAL; optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT PredictBatch(HRESULT hrPrev, ITcVnMlModel* ipMlModel, ITcUnknown* ipSamples, ITcVnContainer*& ipPredictions, ITcVnContainer** pipNovelties = nullptr)
	{
		Internal::PredictBatch_Params params(ipMlModel, ipSamples, ipPredictions, pipNovelties, hrPrev);

		libraryInfo.functions[809 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PredictSampleClass_Params
		{
			ITcVnMlModel* ipClassifier;
			ITcUnknown* ipSample;
			LONG& nClass;
			float* pNovelty;
			HRESULT hrPrev;
			HRESULT retVal;

			PredictSampleClass_Params(ITcVnMlModel* ipClassifier, ITcUnknown* ipSample, LONG& nClass, float* pNovelty, HRESULT hrPrev) : ipClassifier(ipClassifier), ipSample(ipSample), nClass(nClass), pNovelty(pNovelty), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Classify a single sample. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClassifier">Classifier to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="nClass">Returns the classification result</param>
	/// <param name="pNovelty">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of the presented sample (optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT PredictSampleClass(HRESULT hrPrev, ITcVnMlModel* ipClassifier, ITcUnknown* ipSample, LONG& nClass, float* pNovelty = nullptr)
	{
		Internal::PredictSampleClass_Params params(ipClassifier, ipSample, nClass, pNovelty, hrPrev);

		libraryInfo.functions[810 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PredictSampleScalar_Params
		{
			ITcVnMlModel* ipRegressor;
			ITcUnknown* ipSample;
			float& fPrediction;
			float* pNovelty;
			HRESULT hrPrev;
			HRESULT retVal;

			PredictSampleScalar_Params(ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, float& fPrediction, float* pNovelty, HRESULT hrPrev) : ipRegressor(ipRegressor), ipSample(ipSample), fPrediction(fPrediction), pNovelty(pNovelty), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute a scalar prediction for a single sample. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipRegressor">Regressor to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="fPrediction">Returns the predicted output</param>
	/// <param name="pNovelty">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of the presented sample (optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT PredictSampleScalar(HRESULT hrPrev, ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, float& fPrediction, float* pNovelty = nullptr)
	{
		Internal::PredictSampleScalar_Params params(ipRegressor, ipSample, fPrediction, pNovelty, hrPrev);

		libraryInfo.functions[811 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct PredictSampleVector_Params
		{
			ITcVnMlModel* ipRegressor;
			ITcUnknown* ipSample;
			ITcVnContainer*& ipPrediction;
			float* pNovelty;
			HRESULT hrPrev;
			HRESULT retVal;

			PredictSampleVector_Params(ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, ITcVnContainer*& ipPrediction, float* pNovelty, HRESULT hrPrev) : ipRegressor(ipRegressor), ipSample(ipSample), ipPrediction(ipPrediction), pNovelty(pNovelty), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Compute a vectorial prediction for a single sample. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipRegressor">Regressor to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="ipPrediction">Returns the predicted output (ContainerType_Vector_REAL or ContainerType_Vector_LREAL, depending on ipSample)</param>
	/// <param name="pNovelty">Returns the degree of novelty (0.0 if a sample is completely known; &gt; 0.0 otherwise) of the presented sample (optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT PredictSampleVector(HRESULT hrPrev, ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, ITcVnContainer*& ipPrediction, float* pNovelty = nullptr)
	{
		Internal::PredictSampleVector_Params params(ipRegressor, ipSample, ipPrediction, pNovelty, hrPrev);

		libraryInfo.functions[812 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainBatch_Params
		{
			ITcVnMlModel* ipMlModel;
			ITcUnknown* ipSamples;
			ITcVnContainer* ipOutputs;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainBatch_Params(ITcVnMlModel* ipMlModel, ITcUnknown* ipSamples, ITcVnContainer* ipOutputs, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSamples(ipSamples), ipOutputs(ipOutputs), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Train a classifier, a clusterer, a novelty detector, or a regressor with a batch of samples. On-line trainable models are trained once with each sample. Depending on the application and the number of available training samples, repeated training of such models with the same data may improve the results.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Classifier, clusterer, novelty detector, or regressor to be used</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipOutputs">Class labels (for classification, ContainerType_Vector_DINT) or target outputs (for regression with scalar output, ContainerType_Vector_REAL or ContainerType_Vector_LREAL; for regression with vectorial output, ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL) to be learnt (must be 0 for clusterers and for novelty detectors)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainBatch(HRESULT hrPrev, ITcVnMlModel* ipMlModel, ITcUnknown* ipSamples, ITcVnContainer* ipOutputs)
	{
		Internal::TrainBatch_Params params(ipMlModel, ipSamples, ipOutputs, hrPrev);

		libraryInfo.functions[813 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainBatchClusters_Params
		{
			ITcVnMlModel* ipClusterer;
			ITcUnknown* ipSamples;
			ITcVnContainer*& ipClusters;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainBatchClusters_Params(ITcVnMlModel* ipClusterer, ITcUnknown* ipSamples, ITcVnContainer*& ipClusters, HRESULT hrPrev) : ipClusterer(ipClusterer), ipSamples(ipSamples), ipClusters(ipClusters), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Train a clusterer with a batch of samples and return the IDs of the clusters the samples have been assigned to, if requested. On-line trainable clusterers are trained once with each sample. Depending on the application and the number of available training samples, repeated training of such models with the same data may improve the results.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClusterer">Clusterer to be used</param>
	/// <param name="ipSamples">Container holding a batch of input samples (ContainerType_Vector_Vector_REAL or ContainerType_Vector_Vector_LREAL)</param>
	/// <param name="ipClusters">Returns the IDs of the clusters the samples have been assigned to (ContainerType_Vector_DINT; optional, set to 0 if not required)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainBatchClusters(HRESULT hrPrev, ITcVnMlModel* ipClusterer, ITcUnknown* ipSamples, ITcVnContainer*& ipClusters)
	{
		Internal::TrainBatchClusters_Params params(ipClusterer, ipSamples, ipClusters, hrPrev);

		libraryInfo.functions[814 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainSample_Params
		{
			ITcVnMlModel* ipMlModel;
			ITcUnknown* ipSample;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainSample_Params(ITcVnMlModel* ipMlModel, ITcUnknown* ipSample, HRESULT hrPrev) : ipMlModel(ipMlModel), ipSample(ipSample), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Train a clusterer or a novelty detector with a single sample.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipMlModel">Clusterer or novelty detector to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainSample(HRESULT hrPrev, ITcVnMlModel* ipMlModel, ITcUnknown* ipSample)
	{
		Internal::TrainSample_Params params(ipMlModel, ipSample, hrPrev);

		libraryInfo.functions[815 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainSampleClass_Params
		{
			ITcVnMlModel* ipClassifier;
			ITcUnknown* ipSample;
			LONG nClass;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainSampleClass_Params(ITcVnMlModel* ipClassifier, ITcUnknown* ipSample, LONG nClass, HRESULT hrPrev) : ipClassifier(ipClassifier), ipSample(ipSample), nClass(nClass), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Train a classifier with a single sample.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClassifier">Classifier to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="nClass">Class label to be learnt</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainSampleClass(HRESULT hrPrev, ITcVnMlModel* ipClassifier, ITcUnknown* ipSample, LONG nClass)
	{
		Internal::TrainSampleClass_Params params(ipClassifier, ipSample, nClass, hrPrev);

		libraryInfo.functions[816 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainSampleCluster_Params
		{
			ITcVnMlModel* ipClusterer;
			ITcUnknown* ipSample;
			LONG* pCluster;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainSampleCluster_Params(ITcVnMlModel* ipClusterer, ITcUnknown* ipSample, LONG* pCluster, HRESULT hrPrev) : ipClusterer(ipClusterer), ipSample(ipSample), pCluster(pCluster), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Train a clusterer with a single sample and return the ID of the cluster the sample has been assigned to, if requested. The clusterer must be online trainable.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipClusterer">Clusterer to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="pCluster">Returns the ID of the cluster the sample has been assigned to (If the pointer is 0, no cluster ID is requested.)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainSampleCluster(HRESULT hrPrev, ITcVnMlModel* ipClusterer, ITcUnknown* ipSample, LONG* pCluster)
	{
		Internal::TrainSampleCluster_Params params(ipClusterer, ipSample, pCluster, hrPrev);

		libraryInfo.functions[817 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainSampleScalar_Params
		{
			ITcVnMlModel* ipRegressor;
			ITcUnknown* ipSample;
			float fOutput;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainSampleScalar_Params(ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, float fOutput, HRESULT hrPrev) : ipRegressor(ipRegressor), ipSample(ipSample), fOutput(fOutput), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Train a regressor with a single sample and scalar output.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipRegressor">Regressor to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="fOutput">Scalar output to be learnt</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainSampleScalar(HRESULT hrPrev, ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, float fOutput)
	{
		Internal::TrainSampleScalar_Params params(ipRegressor, ipSample, fOutput, hrPrev);

		libraryInfo.functions[818 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct TrainSampleVector_Params
		{
			ITcVnMlModel* ipRegressor;
			ITcUnknown* ipSample;
			ITcVnContainer* ipOutput;
			HRESULT hrPrev;
			HRESULT retVal;

			TrainSampleVector_Params(ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, ITcVnContainer* ipOutput, HRESULT hrPrev) : ipRegressor(ipRegressor), ipSample(ipSample), ipOutput(ipOutput), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Train a regressor with a single sample and vectorial output.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipRegressor">Regressor to be used</param>
	/// <param name="ipSample">Container holding a single input sample (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <param name="ipOutput">Vectorial output to be learnt (ContainerType_Vector_REAL or ContainerType_Vector_LREAL)</param>
	/// <returns>HRESULT</returns>
	static HRESULT TrainSampleVector(HRESULT hrPrev, ITcVnMlModel* ipRegressor, ITcUnknown* ipSample, ITcVnContainer* ipOutput)
	{
		Internal::TrainSampleVector_Params params(ipRegressor, ipSample, ipOutput, hrPrev);

		libraryInfo.functions[819 - Lic6FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Neural_Network_Realtime_Inference

	namespace Internal
	{
		struct ExecuteNeuralNetwork_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_Params(ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Execute a neural network using the provided image as input and provide the output of one output layer. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image based on the output layer is created. To process the destination image, use e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage if necessary.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage)
	{
		Internal::ExecuteNeuralNetwork_Params params(ipNeuralNetwork, ipSrcImage, ipDestImage, hrPrev);

		libraryInfo.functions[820 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExecuteNeuralNetwork_MI_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			PVOID pSrcImages;
			USHORT nSrcArraySize;
			PCCH sInputNames;
			ITcVnImage*& ipDestImage;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_MI_Params(ITcVnNeuralNetwork* ipNeuralNetwork, PVOID pSrcImages, USHORT nSrcArraySize, PCCH sInputNames, ITcVnImage*& ipDestImage, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), pSrcImages(pSrcImages), nSrcArraySize(nSrcArraySize), sInputNames(sInputNames), ipDestImage(ipDestImage), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Execute a neural network with multiple inputs (MI) using the provided images. Ensure all model input names are listed in sInputNames and that the images and names are in the same order. The result of one output layer is returned. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="pSrcImages">Pointer to an array of source input images</param>
	/// <param name="nSrcArraySize">The size of the array referenced by pSrcImages. pSrcImages must reference an array with a size equal to the number of model inputs.</param>
	/// <param name="sInputNames">Input names separated by ";"</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image based on the output layer is created. To process the destination image, use e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage if necessary.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, PVOID pSrcImages, USHORT nSrcArraySize, PCCH sInputNames, ITcVnImage*& ipDestImage)
	{
		Internal::ExecuteNeuralNetwork_MI_Params params(ipNeuralNetwork, pSrcImages, nSrcArraySize, sInputNames, ipDestImage, hrPrev);

		libraryInfo.functions[821 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExecuteNeuralNetwork_MIMO_String_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			PVOID pSrcImages;
			USHORT nSrcArraySize;
			PCCH sInputNames;
			ITcVnContainer*& ipDestImages;
			PCCH sOutputNames;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_MIMO_String_Params(ITcVnNeuralNetwork* ipNeuralNetwork, PVOID pSrcImages, USHORT nSrcArraySize, PCCH sInputNames, ITcVnContainer*& ipDestImages, PCCH sOutputNames, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), pSrcImages(pSrcImages), nSrcArraySize(nSrcArraySize), sInputNames(sInputNames), ipDestImages(ipDestImages), sOutputNames(sOutputNames), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Execute a neural network with multiple inputs and multiple outputs (MIMO) using the provided images. Ensure all model input names are listed in sInputNames and that the images and names are in the same order. The result of the specified output layers are returned. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="pSrcImages">Pointer to an array of source input images</param>
	/// <param name="nSrcArraySize">The size of the array referenced by pSrcImages. pSrcImages must reference an array with a size equal to the number of model inputs.</param>
	/// <param name="sInputNames">Input names separated by ";"</param>
	/// <param name="ipDestImages">Container of images containing the output from the specified layers.</param>
	/// <param name="sOutputNames">Names of output layers whose outputs are required separated by ";". If empty, the outputs of all unconnected output layers are provided.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, PVOID pSrcImages, USHORT nSrcArraySize, PCCH sInputNames, ITcVnContainer*& ipDestImages, PCCH sOutputNames)
	{
		Internal::ExecuteNeuralNetwork_MIMO_String_Params params(ipNeuralNetwork, pSrcImages, nSrcArraySize, sInputNames, ipDestImages, sOutputNames, hrPrev);

		libraryInfo.functions[822 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExecuteNeuralNetwork_MISO_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			PVOID pSrcImages;
			USHORT nSrcArraySize;
			PCCH sInputNames;
			ITcVnImage*& ipDestImage;
			PCCH sOutputName;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_MISO_Params(ITcVnNeuralNetwork* ipNeuralNetwork, PVOID pSrcImages, USHORT nSrcArraySize, PCCH sInputNames, ITcVnImage*& ipDestImage, PCCH sOutputName, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), pSrcImages(pSrcImages), nSrcArraySize(nSrcArraySize), sInputNames(sInputNames), ipDestImage(ipDestImage), sOutputName(sOutputName), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Execute a neural network with multiple inputs and single output (MISO) using the provided images. Ensure all model input names are listed in sInputNames and that the images and names are in the same order. The result of the specified output layer is returned. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="pSrcImages">Pointer to an array of source input images</param>
	/// <param name="nSrcArraySize">The size of the array referenced by pSrcImages. pSrcImages must reference an array with a size equal to the number of model inputs.</param>
	/// <param name="sInputNames">Input names separated by ";"</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image based on the output layer is created. To process the destination image, use e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage if necessary.</param>
	/// <param name="sOutputName">Specify the name of the layer for which the output is required. If empty, the output of one output layer is provided.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, PVOID pSrcImages, USHORT nSrcArraySize, PCCH sInputNames, ITcVnImage*& ipDestImage, PCCH sOutputName)
	{
		Internal::ExecuteNeuralNetwork_MISO_Params params(ipNeuralNetwork, pSrcImages, nSrcArraySize, sInputNames, ipDestImage, sOutputName, hrPrev);

		libraryInfo.functions[823 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExecuteNeuralNetwork_MO_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDestImages;
			ITcVnContainer* ipOutputNames;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_MO_Params(ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDestImages, ITcVnContainer* ipOutputNames, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), ipSrcImage(ipSrcImage), ipDestImages(ipDestImages), ipOutputNames(ipOutputNames), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Execute a neural network using the provided image as input and provide the output of the specified output layers. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="ipDestImages">Container of images containing the output from the specified layers.</param>
	/// <param name="ipOutputNames">Container of layer names whose outputs to be returned (ContainerType_Vector_String_SINT). If set to zero, the outputs of all unconnected output layers will be returned..</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDestImages, ITcVnContainer* ipOutputNames)
	{
		Internal::ExecuteNeuralNetwork_MO_Params params(ipNeuralNetwork, ipSrcImage, ipDestImages, ipOutputNames, hrPrev);

		libraryInfo.functions[824 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExecuteNeuralNetwork_MultiLayerOutput_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			ITcVnImage* ipSrcImage;
			ITcVnContainer*& ipDestImages;
			ITcVnContainer* ipLayerNames;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_MultiLayerOutput_Params(ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDestImages, ITcVnContainer* ipLayerNames, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), ipSrcImage(ipSrcImage), ipDestImages(ipDestImages), ipLayerNames(ipLayerNames), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// This function is deprecated, please use F_VN_ExecuteNeuralNetwork_MO. Execute a neural network using the provided image as input and provide the output of the specified output layers. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="ipDestImages">Container of images containing the output from the specified layers.</param>
	/// <param name="ipLayerNames">Container of layer names whose outputs to be returned (ContainerType_Vector_String_SINT). If set to zero, the outputs of all unconnected output layers will be returned..</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork_MultiLayerOutput(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnContainer*& ipDestImages, ITcVnContainer* ipLayerNames)
	{
		Internal::ExecuteNeuralNetwork_MultiLayerOutput_Params params(ipNeuralNetwork, ipSrcImage, ipDestImages, ipLayerNames, hrPrev);

		libraryInfo.functions[825 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExecuteNeuralNetwork_SingleLayerOutput_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			PCCH sLayerName;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_SingleLayerOutput_Params(ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, PCCH sLayerName, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), sLayerName(sLayerName), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// This function is deprecated, please use F_VN_ExecuteNeuralNetwork_SO. Execute a neural network using the provided image as input and provide the output of the specified output layer. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image based on the output layer is created. To process the destination image, use e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage if necessary.</param>
	/// <param name="sLayerName">Specify the name of the layer for which the output is required. If empty, the output of one output layer is provided.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork_SingleLayerOutput(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, PCCH sLayerName)
	{
		Internal::ExecuteNeuralNetwork_SingleLayerOutput_Params params(ipNeuralNetwork, ipSrcImage, ipDestImage, sLayerName, hrPrev);

		libraryInfo.functions[826 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct ExecuteNeuralNetwork_SO_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipDestImage;
			PCCH sOutputName;
			HRESULT hrPrev;
			HRESULT retVal;

			ExecuteNeuralNetwork_SO_Params(ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, PCCH sOutputName, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), ipSrcImage(ipSrcImage), ipDestImage(ipDestImage), sOutputName(sOutputName), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Execute a neural network using the provided image as input and provide the output of the specified output layer. The function doesn't perform any pre-processing or transformation.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="ipSrcImage">Source image (The image layout must be adapted to match the model's expected input format using e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage functions if necessary.)</param>
	/// <param name="ipDestImage">Destination image (An appropriate destination image based on the output layer is created. To process the destination image, use e.g. F_VN_ConvertDataLayout or F_VN_ReshapeImage if necessary.</param>
	/// <param name="sOutputName">Specify the name of the layer for which the output is required. If empty, the output of one output layer is provided.</param>
	/// <returns>HRESULT</returns>
	static HRESULT ExecuteNeuralNetwork(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnImage* ipSrcImage, ITcVnImage*& ipDestImage, PCCH sOutputName)
	{
		Internal::ExecuteNeuralNetwork_SO_Params params(ipNeuralNetwork, ipSrcImage, ipDestImage, sOutputName, hrPrev);

		libraryInfo.functions[827 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetNeuralNetworkLayerNames_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			ITcVnContainer*& ipLayerNames;
			bool bOnlyOutputs;
			HRESULT hrPrev;
			HRESULT retVal;

			GetNeuralNetworkLayerNames_Params(ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnContainer*& ipLayerNames, bool bOnlyOutputs, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), ipLayerNames(ipLayerNames), bOnlyOutputs(bOnlyOutputs), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the name of all layers in the neural network model. If the bOnlyOuput flag is set to true, only the unconnected output layer names are returned.
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="ipLayerNames">Container with the layers names (ContainerType_Vector_String_SINT) </param>
	/// <param name="bOnlyOutputs">If true, only the unconnected output layer names are returned.</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetNeuralNetworkLayerNames(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnContainer*& ipLayerNames, bool bOnlyOutputs)
	{
		Internal::GetNeuralNetworkLayerNames_Params params(ipNeuralNetwork, ipLayerNames, bOnlyOutputs, hrPrev);

		libraryInfo.functions[828 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetNeuralNetworkLayerNamesExp_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			ITcVnContainer*& ipLayerNames;
			ETcVnLayerNameType eLayerNameType;
			HRESULT hrPrev;
			HRESULT retVal;

			GetNeuralNetworkLayerNamesExp_Params(ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnContainer*& ipLayerNames, ETcVnLayerNameType eLayerNameType, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), ipLayerNames(ipLayerNames), eLayerNameType(eLayerNameType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the name of model layers in the neural network model. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="ipLayerNames">Container with the layers names (ContainerType_Vector_String_SINT)</param>
	/// <param name="eLayerNameType">Layer name type</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetNeuralNetworkLayerNames(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, ITcVnContainer*& ipLayerNames, ETcVnLayerNameType eLayerNameType)
	{
		Internal::GetNeuralNetworkLayerNamesExp_Params params(ipNeuralNetwork, ipLayerNames, eLayerNameType, hrPrev);

		libraryInfo.functions[829 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}

	namespace Internal
	{
		struct GetNeuralNetworkLayerNamesExp_String_Params
		{
			ITcVnNeuralNetwork* ipNeuralNetwork;
			PCCH sLayerNames;
			ULONGLONG nMaxLength;
			ETcVnLayerNameType eLayerNameType;
			HRESULT hrPrev;
			HRESULT retVal;

			GetNeuralNetworkLayerNamesExp_String_Params(ITcVnNeuralNetwork* ipNeuralNetwork, PCCH sLayerNames, ULONGLONG nMaxLength, ETcVnLayerNameType eLayerNameType, HRESULT hrPrev) : ipNeuralNetwork(ipNeuralNetwork), sLayerNames(sLayerNames), nMaxLength(nMaxLength), eLayerNameType(eLayerNameType), hrPrev(hrPrev) { }
		};
	}

	/// <summary>
	/// Get the name of model layers in the neural network model. 
	/// </summary>
	/// <param name="hrPrev">HRESULT indicating the result of previous operations (If SUCCEEDED(hrPrev) equals false, no operation is executed.)</param>
	/// <param name="ipNeuralNetwork">Neural network model</param>
	/// <param name="sLayerNames">Layer names separated by ";". Make sure to choose a sufficient STRING size!</param>
	/// <param name="nMaxLength">Maximum string length to export (including 0 termination). If the container content is longer, the string is cut off at nMaxLength - 1 and 0 termination is appended. In this case, S_FALSE is returned.</param>
	/// <param name="eLayerNameType">Layer name type</param>
	/// <returns>HRESULT</returns>
	static HRESULT GetNeuralNetworkLayerNames(HRESULT hrPrev, ITcVnNeuralNetwork* ipNeuralNetwork, PCCH sLayerNames, ULONGLONG nMaxLength, ETcVnLayerNameType eLayerNameType)
	{
		Internal::GetNeuralNetworkLayerNamesExp_String_Params params(ipNeuralNetwork, sLayerNames, nMaxLength, eLayerNameType, hrPrev);

		libraryInfo.functions[830 - Lic7FuncsOffs].pFct(&params);

		return params.retVal;
	}
#endif

#ifdef LIC_TC3_Vision_Base

	/// <summary>
	/// This FB provides access to the images send by a File Source instance.
	/// </summary>
	struct FileSourceControl final : _FB_BASE
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnFileImageProvider">Internal reference to the corresponding TcVnFileImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		FileSourceControl(OTCID oidITcVnFileImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnFileImageProvider = oidITcVnFileImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~FileSourceControl()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

	private:
		struct GetCurrentImage_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			HRESULT retVal;

			GetCurrentImage_Params(ITcVnImage*& ipImage) : ipImage(ipImage) { }
		};

	public:
		/// <summary>
		/// Gets the current available image (if any).
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImage(ITcVnImage*& ipImage)
		{
			GetCurrentImage_Params params(ipImage);
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[3](&params);

			return params.retVal;
		}

	private:
		struct GetCurrentImageAndFileName_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			PCHAR sFileName;
			USHORT nMaxLen;
			HRESULT retVal;

			GetCurrentImageAndFileName_Params(ITcVnImage*& ipImage, PCHAR sFileName, USHORT nMaxLen) : ipImage(ipImage), sFileName(sFileName), nMaxLen(nMaxLen) { }
		};

	public:
		/// <summary>
		/// Gets the current available image (if any) and the corresponding file name.
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <param name="sFileName">Returns the file name</param>
		/// <param name="nMaxLen">Define the maximum allowed length for the file name</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImageAndFileName(ITcVnImage*& ipImage, PCHAR sFileName, USHORT nMaxLen)
		{
			GetCurrentImageAndFileName_Params params(ipImage, sFileName, nMaxLen);
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[4](&params);

			return params.retVal;
		}

	private:
		struct StartAcquisition_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Activates the File Source. If not in trigger mode, it will start sending images.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT StartAcquisition()
		{
			StartAcquisition_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[5](&params);

			return params.retVal;
		}

	private:
		struct StopAcquisition_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Deactivates the File Source. It will stop sending images.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT StopAcquisition()
		{
			StopAcquisition_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[6](&params);

			return params.retVal;
		}

	private:
		struct Reset_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Reset the controller to initial state (might require multiple calls depending on current state, until S_OK is returned)
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT Reset()
		{
			Reset_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[7](&params);

			return params.retVal;
		}

	private:
		struct GetState_Params : PLC_PARAM_Main
		{
			ETcVnCameraState retVal;
		};

	public:
		/// <summary>
		/// Gets the current state of the internal camera control state machine.
		/// </summary>
		/// <returns>ETcVnCameraState</returns>
		ETcVnCameraState GetState()
		{
			GetState_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[8](&params);

			return params.retVal;
		}

	private:
		struct TriggerImage_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// If in trigger mode, this function triggers the next image in the list.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT TriggerImage()
		{
			TriggerImage_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[9](&params);

			return params.retVal;
		}

	private:
		struct TriggerImageExp_Params : PLC_PARAM_Main
		{
			LONG nSkipImages;
			HRESULT retVal;

			TriggerImageExp_Params(LONG nSkipImages) : nSkipImages(nSkipImages) { }
		};

	public:
		/// <summary>
		/// If in trigger mode, this function triggers a specific image in the list.
		/// </summary>
		/// <param name="nSkipImages">Amount of images to skip, relative to current</param>
		/// <returns>HRESULT</returns>
		HRESULT TriggerImage(LONG nSkipImages)
		{
			TriggerImageExp_Params params(nSkipImages);
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[10](&params);

			return params.retVal;
		}

	private:
		struct TriggerImageByName_Params : PLC_PARAM_Main
		{
			PCCH sImageName;
			HRESULT retVal;

			TriggerImageByName_Params(PCCH sImageName) : sImageName(sImageName) { }
		};

	public:
		/// <summary>
		/// If in trigger mode, this function triggers a specific image in the list by name.
		/// </summary>
		/// <param name="sImageName">Name of the image to trigger</param>
		/// <returns>HRESULT</returns>
		HRESULT TriggerImageByName(PCCH sImageName)
		{
			TriggerImageByName_Params params(sImageName);
			params.pInstance = this;

			libraryInfo.functionBlocks[0 - Lic0FBsOffs].pFcts[11](&params);

			return params.retVal;
		}

#ifdef _X86_
		OTCID oidITcVnFileImageProvider; // Internal reference to the corresponding TcVnFileImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		PVOID pPriv; // Internal reference to private data.
#else
		OTCID oidITcVnFileImageProvider; // Internal reference to the corresponding TcVnFileImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved1[4];
	public:
	private:
		PVOID pPriv; // Internal reference to private data.
#endif
	};

#ifdef _X86_
	static_assert(sizeof(FileSourceControl) == 12);
#else
	static_assert(sizeof(FileSourceControl) == 24);
#endif

	/// <summary>
	/// This FB provides the basic functionality to control a GigE Vision camera and access its calibration data.
	/// </summary>
	struct GevCameraControl final : _FB_BASE
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		GevCameraControl(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[4](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~GevCameraControl()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[3](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

	private:
		struct ClearImageQueue_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Delete all images contained in the TcVnGevImageProvider TcCOM module receive queue and reset the corresponding omitted images counter.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT ClearImageQueue()
		{
			ClearImageQueue_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[1](&params);

			return params.retVal;
		}

	private:
		struct CloseCamera_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Close the control channel to the camera.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT CloseCamera()
		{
			CloseCamera_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[2](&params);

			return params.retVal;
		}

	private:
		struct GetCalibPatternRef_Params : PLC_PARAM_Main
		{
			ITcVnContainer*& ipCalibPatternRef;
			HRESULT retVal;

			GetCalibPatternRef_Params(ITcVnContainer*& ipCalibPatternRef) : ipCalibPatternRef(ipCalibPatternRef) { }
		};

	public:
		/// <summary>
		/// Gets the reference calibration pattern points from the TcVnGevImageProvider TcCOM module (Can be set from the calibration assistant)
		/// </summary>
		/// <param name="ipCalibPatternRef">Returns the reference calibration pattern points (ContainerType_Vector_TcVnPoint3_REAL)</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCalibPatternRef(ITcVnContainer*& ipCalibPatternRef)
		{
			GetCalibPatternRef_Params params(ipCalibPatternRef);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[5](&params);

			return params.retVal;
		}

	private:
		struct GetCameraMatrix_Params : PLC_PARAM_Main
		{
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			HRESULT retVal;

			GetCameraMatrix_Params(TcVnMatrix3x3_LREAL& aCameraMatrix) : aCameraMatrix(aCameraMatrix) { }
		};

	public:
		/// <summary>
		/// Gets the camera matrix from the TcVnGevImageProvider TcCOM module (requires intrinsic calibration parameters, e.g. set by the calibration assistant)
		/// </summary>
		/// <param name="aCameraMatrix">Returns the camera matrix</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCameraMatrix(TcVnMatrix3x3_LREAL& aCameraMatrix)
		{
			GetCameraMatrix_Params params(aCameraMatrix);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[6](&params);

			return params.retVal;
		}

	private:
		struct GetCurrentImage_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			HRESULT retVal;

			GetCurrentImage_Params(ITcVnImage*& ipImage) : ipImage(ipImage) { }
		};

	public:
		/// <summary>
		/// Gets the current available image (first in receive queue).
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImage(ITcVnImage*& ipImage)
		{
			GetCurrentImage_Params params(ipImage);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[7](&params);

			return params.retVal;
		}

	private:
		struct GetCurrentImageUndistorted_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			HRESULT retVal;

			GetCurrentImageUndistorted_Params(ITcVnImage*& ipImage) : ipImage(ipImage) { }
		};

	public:
		/// <summary>
		/// Gets the current available image (first in receive queue) with undistortion applied. Incompatible with pixel formats that contain an encoding, e.g. a Bayer pattern. Requires intrinsic calibration parameters in the TcVnGevImageProvider TcCOM module, e.g. set by the calibration assistant.
		/// </summary>
		/// <param name="ipImage">Returns the undistorted image</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImageUndistorted(ITcVnImage*& ipImage)
		{
			GetCurrentImageUndistorted_Params params(ipImage);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[8](&params);

			return params.retVal;
		}

	private:
		struct GetCurrentImageWithGvspInfo_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			GVSP_IMAGE_INFO& stGvspInfo;
			HRESULT retVal;

			GetCurrentImageWithGvspInfo_Params(ITcVnImage*& ipImage, GVSP_IMAGE_INFO& stGvspInfo) : ipImage(ipImage), stGvspInfo(stGvspInfo) { }
		};

	public:
		/// <summary>
		/// Gets the current available image (first in receive queue) and its corresponding GVSP info.
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <param name="stGvspInfo">Returns the GVSP info</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImageWithGvspInfo(ITcVnImage*& ipImage, GVSP_IMAGE_INFO& stGvspInfo)
		{
			GetCurrentImageWithGvspInfo_Params params(ipImage, stGvspInfo);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[9](&params);

			return params.retVal;
		}

	private:
		struct GetCurrentImageWithGvspInfoUndistorted_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			GVSP_IMAGE_INFO& stGvspInfo;
			HRESULT retVal;

			GetCurrentImageWithGvspInfoUndistorted_Params(ITcVnImage*& ipImage, GVSP_IMAGE_INFO& stGvspInfo) : ipImage(ipImage), stGvspInfo(stGvspInfo) { }
		};

	public:
		/// <summary>
		/// Gets the current available image (first in receive queue) with its corresponding GVSP info and undistortion applied. Incompatible with pixel formats that contain an encoding, e.g. a Bayer pattern. Requires intrinsic calibration parameters in the TcVnGevImageProvider TcCOM module, e.g. set by the calibration assistant.
		/// </summary>
		/// <param name="ipImage">Returns the undistorted image</param>
		/// <param name="stGvspInfo">Returns the GVSP info</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImageWithGvspInfoUndistorted(ITcVnImage*& ipImage, GVSP_IMAGE_INFO& stGvspInfo)
		{
			GetCurrentImageWithGvspInfoUndistorted_Params params(ipImage, stGvspInfo);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[10](&params);

			return params.retVal;
		}

	private:
		struct GetCurrentImageWithTimestamps_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			ULONGLONG nTimestamps;
			LONGLONG* pTimestamps;
			HRESULT retVal;
			GVSP_IMAGE_INFO stGvspInfo;

			GetCurrentImageWithTimestamps_Params(ITcVnImage*& ipImage, ULONGLONG nTimestamps, LONGLONG* pTimestamps) : ipImage(ipImage), nTimestamps(nTimestamps), pTimestamps(pTimestamps) { }
		};

	public:
		/// <summary>
		/// Gets the current available image (first in receive queue) and corresponding timestamps.
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <param name="nTimestamps">Select timestamps to return (ETcVnTimestamp)</param>
		/// <param name="pTimestamps">Returns the requested timestamps (make sure to provide an array of sufficient size).</param>
		/// <param name="stGvspInfo">Returns the GVSP info</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImageWithTimestamps(ITcVnImage*& ipImage, ULONGLONG nTimestamps, LONGLONG* pTimestamps, GVSP_IMAGE_INFO& stGvspInfo)
		{
			GetCurrentImageWithTimestamps_Params params(ipImage, nTimestamps, pTimestamps);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[11](&params);

			AssignTo(stGvspInfo, params.stGvspInfo);

			return params.retVal;
		}

		/// <summary>
		/// Gets the current available image (first in receive queue) and corresponding timestamps.
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <param name="nTimestamps">Select timestamps to return (ETcVnTimestamp)</param>
		/// <param name="pTimestamps">Returns the requested timestamps (make sure to provide an array of sufficient size).</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImageWithTimestamps(ITcVnImage*& ipImage, ULONGLONG nTimestamps, LONGLONG* pTimestamps)
		{
			GetCurrentImageWithTimestamps_Params params(ipImage, nTimestamps, pTimestamps);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[11](&params);

			return params.retVal;
		}

	private:
		struct GetDistortionCoefficients_Params : PLC_PARAM_Main
		{
			TcVnArray8_LREAL& aDistortionCoefficients;
			HRESULT retVal;

			GetDistortionCoefficients_Params(TcVnArray8_LREAL& aDistortionCoefficients) : aDistortionCoefficients(aDistortionCoefficients) { }
		};

	public:
		/// <summary>
		/// Gets the distortion coefficients from the TcVnGevImageProvider TcCOM module (requires intrinsic calibration parameters, e.g. set by the calibration assistant)
		/// </summary>
		/// <param name="aDistortionCoefficients">Returns the distortion coefficients [k1, k2, p1, p2, k3, k4, k5, k6]</param>
		/// <returns>HRESULT</returns>
		HRESULT GetDistortionCoefficients(TcVnArray8_LREAL& aDistortionCoefficients)
		{
			GetDistortionCoefficients_Params params(aDistortionCoefficients);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[12](&params);

			return params.retVal;
		}

	private:
		struct GetLastImageFromQueue_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			HRESULT retVal;

			GetLastImageFromQueue_Params(ITcVnImage*& ipImage) : ipImage(ipImage) { }
		};

	public:
		/// <summary>
		/// Gets the last received image from the queue.
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <returns>HRESULT</returns>
		HRESULT GetLastImageFromQueue(ITcVnImage*& ipImage)
		{
			GetLastImageFromQueue_Params params(ipImage);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[13](&params);

			return params.retVal;
		}

	private:
		struct GetOmittedImagesNum_Params : PLC_PARAM_Main
		{
			ULONGLONG& nOmitted;
			HRESULT retVal;

			GetOmittedImagesNum_Params(ULONGLONG& nOmitted) : nOmitted(nOmitted) { }
		};

	public:
		/// <summary>
		/// Gets the number of omitted images since the last call of ClearImageQueue(). If the image receive queue in the TcVnGevImageProvider TcCOM module is full and a new image arrives, the first one in the queue will be deleted and the omitted counter is increased.
		/// </summary>
		/// <param name="nOmitted">Returns the number of omitted images</param>
		/// <returns>HRESULT</returns>
		HRESULT GetOmittedImagesNum(ULONGLONG& nOmitted)
		{
			GetOmittedImagesNum_Params params(nOmitted);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[14](&params);

			return params.retVal;
		}

	private:
		struct GetRotationMatrix_Params : PLC_PARAM_Main
		{
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			HRESULT retVal;

			GetRotationMatrix_Params(TcVnMatrix3x3_LREAL& aRotationMatrix) : aRotationMatrix(aRotationMatrix) { }
		};

	public:
		/// <summary>
		/// Gets the rotation matrix from the TcVnGevImageProvider TcCOM module (requires extrinsic calibration parameters, e.g. set by the calibration assistant)
		/// </summary>
		/// <param name="aRotationMatrix">Returns the rotation matrix</param>
		/// <returns>HRESULT</returns>
		HRESULT GetRotationMatrix(TcVnMatrix3x3_LREAL& aRotationMatrix)
		{
			GetRotationMatrix_Params params(aRotationMatrix);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[15](&params);

			return params.retVal;
		}

	private:
		struct GetState_Params : PLC_PARAM_Main
		{
			ETcVnCameraState retVal;
		};

	public:
		/// <summary>
		/// Gets the current state of the internal camera control state machine.
		/// </summary>
		/// <returns>ETcVnCameraState</returns>
		ETcVnCameraState GetState()
		{
			GetState_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[16](&params);

			return params.retVal;
		}

	private:
		struct GetTranslationVector_Params : PLC_PARAM_Main
		{
			VN_TcVnVector3_LREAL& aTranslationVector;
			HRESULT retVal;

			GetTranslationVector_Params(TcVnVector3_LREAL& aTranslationVector) : aTranslationVector(aTranslationVector) { }
		};

	public:
		/// <summary>
		/// Gets the translation vector from the TcVnGevImageProvider TcCOM module (requires extrinsic calibration parameters, e.g. set by the calibration assistant)
		/// </summary>
		/// <param name="aTranslationVector">Returns the translation vector</param>
		/// <returns>HRESULT</returns>
		HRESULT GetTranslationVector(TcVnVector3_LREAL& aTranslationVector)
		{
			GetTranslationVector_Params params(aTranslationVector);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[17](&params);

			return params.retVal;
		}

	private:
		struct InitializeCamera_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Initialize the camera to the intended state (includes sending the 'InitCameraCommands' defined in the GevImageAcquisition TcCOM module to the camera).
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT InitializeCamera()
		{
			InitializeCamera_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[18](&params);

			return params.retVal;
		}

	private:
		struct OpenCamera_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Open a control channel to the camera.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT OpenCamera()
		{
			OpenCamera_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[19](&params);

			return params.retVal;
		}

	private:
		struct Reset_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Reset the camera controller to initial state (might require multiple calls depending on current state, until S_OK is returned)
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT Reset()
		{
			Reset_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[20](&params);

			return params.retVal;
		}

	private:
		struct ResetCameraFeatures_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Reset the camera features to initial state (sends the 'InitCameraCommands' defined in the GevImageAcquisition TcCOM module to the camera).
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT ResetCameraFeatures()
		{
			ResetCameraFeatures_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[21](&params);

			return params.retVal;
		}

	private:
		struct SetCameraMatrix_Params : PLC_PARAM_Main
		{
			TcVnMatrix3x3_LREAL& aCameraMatrix;
			HRESULT retVal;

			SetCameraMatrix_Params(TcVnMatrix3x3_LREAL& aCameraMatrix) : aCameraMatrix(aCameraMatrix) { }
		};

	public:
		/// <summary>
		/// Sets the camera matrix to the TcVnGevImageProvider TcCOM module
		/// </summary>
		/// <param name="aCameraMatrix">The camera matrix to be copied to the TcCOM module</param>
		/// <returns>HRESULT</returns>
		HRESULT SetCameraMatrix(TcVnMatrix3x3_LREAL& aCameraMatrix)
		{
			SetCameraMatrix_Params params(aCameraMatrix);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[22](&params);

			return params.retVal;
		}

	private:
		struct SetDistortionCoefficients_Params : PLC_PARAM_Main
		{
			TcVnArray8_LREAL& aDistortionCoefficients;
			HRESULT retVal;

			SetDistortionCoefficients_Params(TcVnArray8_LREAL& aDistortionCoefficients) : aDistortionCoefficients(aDistortionCoefficients) { }
		};

	public:
		/// <summary>
		/// Sets the distortion coefficients to the TcVnGevImageProvider TcCOM module
		/// </summary>
		/// <param name="aDistortionCoefficients">The distortion coefficients to be copied to the TcCOM module</param>
		/// <returns>HRESULT</returns>
		HRESULT SetDistortionCoefficients(TcVnArray8_LREAL& aDistortionCoefficients)
		{
			SetDistortionCoefficients_Params params(aDistortionCoefficients);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[23](&params);

			return params.retVal;
		}

	private:
		struct SetRotationMatrix_Params : PLC_PARAM_Main
		{
			TcVnMatrix3x3_LREAL& aRotationMatrix;
			HRESULT retVal;

			SetRotationMatrix_Params(TcVnMatrix3x3_LREAL& aRotationMatrix) : aRotationMatrix(aRotationMatrix) { }
		};

	public:
		/// <summary>
		/// Sets the rotation matrix to the TcVnGevImageProvider TcCOM module
		/// </summary>
		/// <param name="aRotationMatrix">The rotation matrix to be copied to the TcCOM module</param>
		/// <returns>HRESULT</returns>
		HRESULT SetRotationMatrix(TcVnMatrix3x3_LREAL& aRotationMatrix)
		{
			SetRotationMatrix_Params params(aRotationMatrix);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[24](&params);

			return params.retVal;
		}

	private:
		struct SetTranslationVector_Params : PLC_PARAM_Main
		{
			VN_TcVnVector3_LREAL& aTranslationVector;
			HRESULT retVal;

			SetTranslationVector_Params(TcVnVector3_LREAL& aTranslationVector) : aTranslationVector(aTranslationVector) { }
		};

	public:
		/// <summary>
		/// Sets the translation vector to the TcVnGevImageProvider TcCOM module
		/// </summary>
		/// <param name="aTranslationVector">The translation vector to be copied to the TcCOM module</param>
		/// <returns>HRESULT</returns>
		HRESULT SetTranslationVector(TcVnVector3_LREAL& aTranslationVector)
		{
			SetTranslationVector_Params params(aTranslationVector);
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[25](&params);

			return params.retVal;
		}

	private:
		struct StartAcquisition_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Send the 'StartAcquisitionCommands' defined in the TcVnGevImageProvider TcCOM module to the camera.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT StartAcquisition()
		{
			StartAcquisition_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[26](&params);

			return params.retVal;
		}

	private:
		struct StopAcquisition_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Send the 'StopAcquisitionCommands' defined in the TcVnGevImageProvider TcCOM module to the camera.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT StopAcquisition()
		{
			StopAcquisition_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[27](&params);

			return params.retVal;
		}

	private:
		struct TriggerImage_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Send the 'SoftwareTriggerCommands' defined in the TcVnGevImageProvider TcCOM module to the camera.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT TriggerImage()
		{
			TriggerImage_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[1 - Lic0FBsOffs].pFcts[28](&params);

			return params.retVal;
		}

#ifdef _X86_
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		PVOID pInternal; // Internal stuff
#else
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved1[4];
	public:
	private:
		PVOID pInternal; // Internal stuff
#endif
	};

#ifdef _X86_
	static_assert(sizeof(GevCameraControl) == 12);
#else
	static_assert(sizeof(GevCameraControl) == 24);
#endif

	/// <summary>
	/// This FB initializes selected functions.
	/// </summary>
	struct InitializeFunction final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[2 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="eFunction">Selects the function to initialize</param>
		/// <param name="nOptions">Selects initialization options for the function</param>
		/// <param name="bStart">Function initialization is triggered by a rising edge at this input.</param>
		void FB_Main(ETcVnInitializableFunction eFunction, ULONGLONG nOptions, bool bStart)
		{
			this->eFunction = eFunction;
			this->nOptions = nOptions;
			this->bStart = bStart;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bStart">Function initialization is triggered by a rising edge at this input.</param>
		void FB_Main(bool bStart)
		{
			this->bStart = bStart;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		InitializeFunction()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[2 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~InitializeFunction()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[2 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		ETcVnInitializableFunction eFunction; // Selects the function to initialize
		ULONGLONG nOptions; // Selects initialization options for the function
		bool bStart; // Function initialization is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[3];
		PVOID pBuffer; // Internal parameter
		ETcVnInitializableFunction ePendingFunction; // Internal parameter
		UCHAR reserved4[4];
		ULONGLONG nPendingOptions; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
		LONG nFilePathCounter; // Internal parameter
#else
		ETcVnInitializableFunction eFunction; // Selects the function to initialize
	private:
		UCHAR reserved1[4];
	public:
		ULONGLONG nOptions; // Selects initialization options for the function
		bool bStart; // Function initialization is triggered by a rising edge at this input.
	private:
		UCHAR reserved2[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved3[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved4[7];
		PVOID pBuffer; // Internal parameter
		ETcVnInitializableFunction ePendingFunction; // Internal parameter
		UCHAR reserved5[4];
		ULONGLONG nPendingOptions; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
		LONG nFilePathCounter; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(InitializeFunction) == 72);
#else
	static_assert(sizeof(InitializeFunction) == 96);
#endif

	/// <summary>
	/// This FB reads calibration pattern reference points from an xml file on the targte pc.
	/// </summary>
	struct ReadCalibrationPattern final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[3 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc</param>
		/// <param name="pipDestContainer">Returns a container with the pattern points (ContainerType_Vector_TcVnPoint3_REAL)</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, ITcVnContainer** pipDestContainer, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->pipDestContainer = pipDestContainer;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		ReadCalibrationPattern()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[3 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadCalibrationPattern()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[3 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnContainer** pipDestContainer; // Returns a container with the pattern points (ContainerType_Vector_TcVnPoint3_REAL)
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[3];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#else
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnContainer** pipDestContainer; // Returns a container with the pattern points (ContainerType_Vector_TcVnPoint3_REAL)
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[7];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadCalibrationPattern) == 48);
#else
	static_assert(sizeof(ReadCalibrationPattern) == 72);
#endif

	/// <summary>
	/// This FB reads calibration results from a json file on the targte pc.
	/// </summary>
	struct ReadCalibrationResult final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[4 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc</param>
		/// <param name="paCameraMatrix">Returns the camera matrix</param>
		/// <param name="paDistortionCoefficients">Returns the distortion coefficients</param>
		/// <param name="paRotationMatrix">Returns the rotation matrix</param>
		/// <param name="paTranslationVector">Returns the translation vector</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, TcVnMatrix3x3_LREAL* paCameraMatrix, TcVnArray8_LREAL* paDistortionCoefficients, TcVnMatrix3x3_LREAL* paRotationMatrix, TcVnVector3_LREAL* paTranslationVector, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->paCameraMatrix = paCameraMatrix;
			this->paDistortionCoefficients = paDistortionCoefficients;
			this->paRotationMatrix = paRotationMatrix;
			this->paTranslationVector = paTranslationVector;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		ReadCalibrationResult()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[4 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadCalibrationResult()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[4 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		TcVnMatrix3x3_LREAL* paCameraMatrix; // Returns the camera matrix
		TcVnArray8_LREAL* paDistortionCoefficients; // Returns the distortion coefficients
		TcVnMatrix3x3_LREAL* paRotationMatrix; // Returns the rotation matrix
		TcVnVector3_LREAL* paTranslationVector; // Returns the translation vector
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[3];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#else
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		TcVnMatrix3x3_LREAL* paCameraMatrix; // Returns the camera matrix
		TcVnArray8_LREAL* paDistortionCoefficients; // Returns the distortion coefficients
		TcVnMatrix3x3_LREAL* paRotationMatrix; // Returns the rotation matrix
		TcVnVector3_LREAL* paTranslationVector; // Returns the translation vector
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[7];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadCalibrationResult) == 60);
#else
	static_assert(sizeof(ReadCalibrationResult) == 96);
#endif

	/// <summary>
	/// This FB reads a container from an xml file on the target pc.
	/// </summary>
	struct ReadContainer final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[5 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc</param>
		/// <param name="pipDestContainer">Returns a container with the loaded content</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, ITcVnContainer** pipDestContainer, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->pipDestContainer = pipDestContainer;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc</param>
		/// <param name="pipDestContainer">Returns a container with the loaded content</param>
		/// <param name="nDestTypeGuid">The type id of the container to return. If this parameter is not set, a suitable container type will be determined automatically (except for csv files).</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, ITcVnContainer** pipDestContainer, GUID nDestTypeGuid, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->pipDestContainer = pipDestContainer;
			this->nDestTypeGuid = nDestTypeGuid;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		ReadContainer()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[5 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadContainer()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[5 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnContainer** pipDestContainer; // Returns a container with the loaded content
		GUID nDestTypeGuid; // The type id of the container to return. If this parameter is not set, a suitable container type will be determined automatically (except for csv files).
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[3];
		PVOID pReadBuffer; // Internal parameter
		PVOID pWriteBuffer; // Internal parameter
		ULONG nWriteSize; // Internal parameter
#else
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnContainer** pipDestContainer; // Returns a container with the loaded content
		GUID nDestTypeGuid; // The type id of the container to return. If this parameter is not set, a suitable container type will be determined automatically (except for csv files).
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[7];
		PVOID pReadBuffer; // Internal parameter
		PVOID pWriteBuffer; // Internal parameter
		ULONG nWriteSize; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadContainer) == 68);
#else
	static_assert(sizeof(ReadContainer) == 96);
#endif

	/// <summary>
	/// This FB reads an image from a file on the target pc.
	/// </summary>
	struct ReadImage final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[6 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default image directory on the target pc</param>
		/// <param name="pipDestImage">Returns an image with the loaded content</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, ITcVnImage** pipDestImage, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->pipDestImage = pipDestImage;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		ReadImage()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[6 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadImage()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[6 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		PCCH sFilePath; // Full path of the file or relative path to the default image directory on the target pc
		ITcVnImage** pipDestImage; // Returns an image with the loaded content
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[3];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#else
		PCCH sFilePath; // Full path of the file or relative path to the default image directory on the target pc
		ITcVnImage** pipDestImage; // Returns an image with the loaded content
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[7];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadImage) == 48);
#else
	static_assert(sizeof(ReadImage) == 72);
#endif

	/// <summary>
	/// This FB reads consecutive memory locations from the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct ReadMemory final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[7 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the first byte to read from the camera (must be 32-bit aligned)</param>
		/// <param name="nLength">The number of bytes to read, starting with nAddress (must be a multiple of 4, not more than 536)</param>
		/// <param name="pBuffer">Pointer to the buffer where the read memory content is written to (The buffer must have a size of at least nLength bytes!)</param>
		/// <param name="bRead">Reading the memory is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, USHORT nLength, PVOID pBuffer, bool bRead)
		{
			this->nAddress = nAddress;
			this->nLength = nLength;
			this->pBuffer = pBuffer;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the memory is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		ReadMemory(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[7 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadMemory()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[7 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the first byte to read from the camera (must be 32-bit aligned)
		USHORT nLength; // The number of bytes to read, starting with nAddress (must be a multiple of 4, not more than 536)
	private:
		UCHAR reserved1[2];
	public:
		PVOID pBuffer; // Pointer to the buffer where the read memory content is written to (The buffer must have a size of at least nLength bytes!)
		bool bRead; // Reading the memory is triggered by a rising edge at this input.
	private:
		UCHAR reserved2[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved3[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the first byte to read from the camera (must be 32-bit aligned)
		USHORT nLength; // The number of bytes to read, starting with nAddress (must be a multiple of 4, not more than 536)
	private:
		UCHAR reserved1[2];
	public:
		PVOID pBuffer; // Pointer to the buffer where the read memory content is written to (The buffer must have a size of at least nLength bytes!)
		bool bRead; // Reading the memory is triggered by a rising edge at this input.
	private:
		UCHAR reserved2[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved3[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved4[4];
	public:
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadMemory) == 48);
#else
	static_assert(sizeof(ReadMemory) == 64);
#endif

	/// <summary>
	/// This FB reads a machine learning model from a file on the target pc.
	/// </summary>
	struct ReadMlModel final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[8 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc</param>
		/// <param name="pipDestMlModel">Returns the loaded machine learning model</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, ITcVnMlModel** pipDestMlModel, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->pipDestMlModel = pipDestMlModel;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		ReadMlModel()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[8 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadMlModel()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[8 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnMlModel** pipDestMlModel; // Returns the loaded machine learning model
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[3];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#else
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnMlModel** pipDestMlModel; // Returns the loaded machine learning model
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[7];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadMlModel) == 48);
#else
	static_assert(sizeof(ReadMlModel) == 72);
#endif

	/// <summary>
	/// This FB reads a neural network from a file on the target pc.
	/// </summary>
	struct ReadNeuralNetwork final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[9 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc</param>
		/// <param name="pipDestNeuralNetwork">Returns the neural network</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, ITcVnNeuralNetwork** pipDestNeuralNetwork, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->pipDestNeuralNetwork = pipDestNeuralNetwork;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc</param>
		/// <param name="pipDestNeuralNetwork">Returns the neural network</param>
		/// <param name="paInputShape">Optional input shape for testing the execution of the neural network model. The error code INCOMPATIBLE is returned if the execution fails. Setting aInputShape = 0 or aInputShape[0] = 0 disables the testing of the execution.</param>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, ITcVnNeuralNetwork** pipDestNeuralNetwork, TcVnArray33_UDINT* paInputShape, bool bRead)
		{
			this->sFilePath = sFilePath;
			this->pipDestNeuralNetwork = pipDestNeuralNetwork;
			this->paInputShape = paInputShape;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the file is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		ReadNeuralNetwork()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[9 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadNeuralNetwork()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[9 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnNeuralNetwork** pipDestNeuralNetwork; // Returns the neural network
		TcVnArray33_UDINT* paInputShape; // Optional input shape for testing the execution of the neural network model. The error code INCOMPATIBLE is returned if the execution fails. Setting aInputShape = 0 or aInputShape[0] = 0 disables the testing of the execution.
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[3];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#else
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc
		ITcVnNeuralNetwork** pipDestNeuralNetwork; // Returns the neural network
		TcVnArray33_UDINT* paInputShape; // Optional input shape for testing the execution of the neural network model. The error code INCOMPATIBLE is returned if the execution fails. Setting aInputShape = 0 or aInputShape[0] = 0 disables the testing of the execution.
		bool bRead; // Reading the file is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		BYTE ePendingRequest; // Internal parameter
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastRead; // Internal parameter
		UCHAR reserved3[7];
		PVOID pBuffer; // Internal parameter
		PVOID pFilePathPending; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadNeuralNetwork) == 52);
#else
	static_assert(sizeof(ReadNeuralNetwork) == 80);
#endif

	/// <summary>
	/// This FB reads a REAL register from the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct ReadRegister_REAL final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[10 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the register that should be read</param>
		/// <param name="bRead">Reading the register is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, bool bRead)
		{
			this->nAddress = nAddress;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the register is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		ReadRegister_REAL(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[10 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadRegister_REAL()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[10 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be read
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bRead; // Reading the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		float fValue; // The read value
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be read
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bRead; // Reading the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		float fValue; // The read value
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved3[4];
	public:
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadRegister_REAL) == 44);
#else
	static_assert(sizeof(ReadRegister_REAL) == 56);
#endif

	/// <summary>
	/// This FB reads a DINT register from the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct ReadRegister_UDINT final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[11 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the register that should be read</param>
		/// <param name="bRead">Reading the register is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, bool bRead)
		{
			this->nAddress = nAddress;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the register is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		ReadRegister_UDINT(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[11 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadRegister_UDINT()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[11 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be read
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bRead; // Reading the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		ULONG nValue; // The read value
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be read
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bRead; // Reading the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		ULONG nValue; // The read value
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved3[4];
	public:
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadRegister_UDINT) == 44);
#else
	static_assert(sizeof(ReadRegister_UDINT) == 56);
#endif

	/// <summary>
	/// This FB reads a ULINT register from the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct ReadRegister_ULINT final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[12 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the register that should be read</param>
		/// <param name="bRead">Reading the register is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, bool bRead)
		{
			this->nAddress = nAddress;
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bRead">Reading the register is triggered by a rising edge at this input.</param>
		void FB_Main(bool bRead)
		{
			this->bRead = bRead;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		ReadRegister_ULINT(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[12 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~ReadRegister_ULINT()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[12 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be read
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bRead; // Reading the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		ULONGLONG nValue; // The read value
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be read
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bRead; // Reading the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
	private:
		UCHAR reserved2[4];
	public:
		ULONGLONG nValue; // The read value
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved3[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved4[4];
	public:
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(ReadRegister_ULINT) == 48);
#else
	static_assert(sizeof(ReadRegister_ULINT) == 64);
#endif

	/// <summary>
	/// This FB provides the basic functionality to control a camera or a FileSource.
	/// </summary>
	struct SimpleCameraControl final : _FB_BASE
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnImageProvider">Internal reference to the corresponding TcVnImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		SimpleCameraControl(OTCID oidITcVnImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnImageProvider = oidITcVnImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~SimpleCameraControl()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

	private:
		struct GetCurrentImage_Params : PLC_PARAM_Main
		{
			ITcVnImage*& ipImage;
			HRESULT retVal;

			GetCurrentImage_Params(ITcVnImage*& ipImage) : ipImage(ipImage) { }
		};

	public:
		/// <summary>
		/// Get the current available image (if any).
		/// </summary>
		/// <param name="ipImage">Returns the image</param>
		/// <returns>HRESULT</returns>
		HRESULT GetCurrentImage(ITcVnImage*& ipImage)
		{
			GetCurrentImage_Params params(ipImage);
			params.pInstance = this;

			libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[3](&params);

			return params.retVal;
		}

	private:
		struct GetState_Params : PLC_PARAM_Main
		{
			ETcVnCameraState retVal;
		};

	public:
		/// <summary>
		/// Get the current state of the internal camera control state machine.
		/// </summary>
		/// <returns>ETcVnCameraState</returns>
		ETcVnCameraState GetState()
		{
			GetState_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[4](&params);

			return params.retVal;
		}

	private:
		struct Reset_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Reset the camera to initial state (might require multiple calls depending on current state, until S_OK is returned)
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT Reset()
		{
			Reset_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[5](&params);

			return params.retVal;
		}

	private:
		struct StartAcquisition_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Start the image acquisition.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT StartAcquisition()
		{
			StartAcquisition_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[6](&params);

			return params.retVal;
		}

	private:
		struct StopAcquisition_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Stop the image acquisition.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT StopAcquisition()
		{
			StopAcquisition_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[7](&params);

			return params.retVal;
		}

	private:
		struct TriggerImage_Params : PLC_PARAM_Main
		{
			HRESULT retVal;
		};

	public:
		/// <summary>
		/// Trigger the next image.
		/// </summary>
		/// <returns>HRESULT</returns>
		HRESULT TriggerImage()
		{
			TriggerImage_Params params;
			params.pInstance = this;

			libraryInfo.functionBlocks[13 - Lic0FBsOffs].pFcts[8](&params);

			return params.retVal;
		}

#ifdef _X86_
		OTCID oidITcVnImageProvider; // Internal reference to the corresponding TcVnImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		PVOID pInternal; // Internal stuff
#else
		OTCID oidITcVnImageProvider; // Internal reference to the corresponding TcVnImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved1[4];
	public:
	private:
		PVOID pInternal; // Internal stuff
#endif
	};

#ifdef _X86_
	static_assert(sizeof(SimpleCameraControl) == 12);
#else
	static_assert(sizeof(SimpleCameraControl) == 24);
#endif

	/// <summary>
	/// This FB writes calibration results as a json file to the hard drive.
	/// </summary>
	struct WriteCalibrationResult final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[14 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).</param>
		/// <param name="paCameraMatrix">Returns the camera matrix</param>
		/// <param name="paDistortionCoefficients">Returns the distortion coefficients</param>
		/// <param name="paRotationMatrix">Returns the rotation matrix</param>
		/// <param name="paTranslationVector">Returns the translation vector</param>
		/// <param name="bWrite">Writing the container is triggered by a rising edge at this input.</param>
		void FB_Main(PCCH sFilePath, TcVnMatrix3x3_LREAL* paCameraMatrix, TcVnArray8_LREAL* paDistortionCoefficients, TcVnMatrix3x3_LREAL* paRotationMatrix, TcVnVector3_LREAL* paTranslationVector, bool bWrite)
		{
			this->sFilePath = sFilePath;
			this->paCameraMatrix = paCameraMatrix;
			this->paDistortionCoefficients = paDistortionCoefficients;
			this->paRotationMatrix = paRotationMatrix;
			this->paTranslationVector = paTranslationVector;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the container is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		WriteCalibrationResult()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[14 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteCalibrationResult()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[14 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		TcVnMatrix3x3_LREAL* paCameraMatrix; // Returns the camera matrix
		TcVnArray8_LREAL* paDistortionCoefficients; // Returns the distortion coefficients
		TcVnMatrix3x3_LREAL* paRotationMatrix; // Returns the rotation matrix
		TcVnVector3_LREAL* paTranslationVector; // Returns the translation vector
		bool bWrite; // Writing the container is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#else
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		TcVnMatrix3x3_LREAL* paCameraMatrix; // Returns the camera matrix
		TcVnArray8_LREAL* paDistortionCoefficients; // Returns the distortion coefficients
		TcVnMatrix3x3_LREAL* paRotationMatrix; // Returns the rotation matrix
		TcVnVector3_LREAL* paTranslationVector; // Returns the translation vector
		bool bWrite; // Writing the container is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteCalibrationResult) == 52);
#else
	static_assert(sizeof(WriteCalibrationResult) == 80);
#endif

	/// <summary>
	/// This FB writes a container as an xml file to the hard drive.
	/// </summary>
	struct WriteContainer final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[15 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="pipContainer">The container to write</param>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).</param>
		/// <param name="eExportFormat">Container export format (default is human readable xml)</param>
		/// <param name="bWrite">Writing the container is triggered by a rising edge at this input.</param>
		void FB_Main(ITcVnContainer** pipContainer, PCCH sFilePath, ETcVnContainerExportFormat eExportFormat, bool bWrite)
		{
			this->pipContainer = pipContainer;
			this->sFilePath = sFilePath;
			this->eExportFormat = eExportFormat;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the container is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		WriteContainer()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[15 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteContainer()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[15 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		ITcVnContainer** pipContainer; // The container to write
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		ETcVnContainerExportFormat eExportFormat; // Container export format (default is human readable xml)
		bool bWrite; // Writing the container is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#else
		ITcVnContainer** pipContainer; // The container to write
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		ETcVnContainerExportFormat eExportFormat; // Container export format (default is human readable xml)
		bool bWrite; // Writing the container is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteContainer) == 40);
#else
	static_assert(sizeof(WriteContainer) == 56);
#endif

	/// <summary>
	/// This FB writes an image to the hard drive.
	/// </summary>
	struct WriteImage final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[16 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="pipImage">The image to write</param>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).</param>
		/// <param name="bWrite">Writing the image is triggered by a rising edge at this input.</param>
		void FB_Main(ITcVnImage** pipImage, PCCH sFilePath, bool bWrite)
		{
			this->pipImage = pipImage;
			this->sFilePath = sFilePath;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the image is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		WriteImage()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[16 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteImage()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[16 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		ITcVnImage** pipImage; // The image to write
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		bool bWrite; // Writing the image is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#else
		ITcVnImage** pipImage; // The image to write
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		bool bWrite; // Writing the image is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteImage) == 40);
#else
	static_assert(sizeof(WriteImage) == 56);
#endif

	/// <summary>
	/// This FB writes data to consecutive memory locations on the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct WriteMemory final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[17 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the first byte to write to the camera (must be 32-bit aligned)</param>
		/// <param name="nLength">The number of bytes to write, starting at nAddress (must be a multiple of 4, not more than 536)</param>
		/// <param name="pData">Pointer to the data that should be written to the camera (must have a size of at least nLength bytes!)</param>
		/// <param name="bWrite">Writing the memory is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, USHORT nLength, PVOID pData, bool bWrite)
		{
			this->nAddress = nAddress;
			this->nLength = nLength;
			this->pData = pData;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the memory is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		WriteMemory(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[17 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteMemory()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[17 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the first byte to write to the camera (must be 32-bit aligned)
		USHORT nLength; // The number of bytes to write, starting at nAddress (must be a multiple of 4, not more than 536)
	private:
		UCHAR reserved1[2];
	public:
		PVOID pData; // Pointer to the data that should be written to the camera (must have a size of at least nLength bytes!)
		bool bWrite; // Writing the memory is triggered by a rising edge at this input.
	private:
		UCHAR reserved2[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved3[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		USHORT nBytesWritten; // The number of bytes that have been successfully written to the camera.
	private:
		UCHAR reserved4[2];
	public:
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the first byte to write to the camera (must be 32-bit aligned)
		USHORT nLength; // The number of bytes to write, starting at nAddress (must be a multiple of 4, not more than 536)
	private:
		UCHAR reserved1[2];
	public:
		PVOID pData; // Pointer to the data that should be written to the camera (must have a size of at least nLength bytes!)
		bool bWrite; // Writing the memory is triggered by a rising edge at this input.
	private:
		UCHAR reserved2[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved3[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		USHORT nBytesWritten; // The number of bytes that have been successfully written to the camera.
	private:
		UCHAR reserved4[2];
	public:
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastRead; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteMemory) == 52);
#else
	static_assert(sizeof(WriteMemory) == 64);
#endif

	/// <summary>
	/// This FB writes a machine learning model to the hard drive.
	/// </summary>
	struct WriteMlModel final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[18 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="pipMlModel">The machine learning model to write</param>
		/// <param name="sFilePath">Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).</param>
		/// <param name="bWrite">Writing the machine learning model is triggered by a rising edge at this input.</param>
		void FB_Main(ITcVnMlModel** pipMlModel, PCCH sFilePath, bool bWrite)
		{
			this->pipMlModel = pipMlModel;
			this->sFilePath = sFilePath;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the machine learning model is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		WriteMlModel()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[18 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteMlModel()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[18 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		ITcVnMlModel** pipMlModel; // The machine learning model to write
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		bool bWrite; // Writing the machine learning model is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#else
		ITcVnMlModel** pipMlModel; // The machine learning model to write
		PCCH sFilePath; // Full path of the file or relative path to the default directory on the target pc (e.g. only a file name). If the string is empty, a file name will be generated (containing the current time).
		bool bWrite; // Writing the machine learning model is triggered by a rising edge at this input.
	private:
		UCHAR reserved1[3];
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
	private:
		USHORT nAdsInvStamp; // Internal parameter
		BYTE nAdsInvCnt; // Internal parameter
		UCHAR reserved3;
		unsigned int nTimeElapsed; // Internal parameter
		bool bLastWrite; // Internal parameter
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteMlModel) == 40);
#else
	static_assert(sizeof(WriteMlModel) == 56);
#endif

	/// <summary>
	/// This FB writes a REAL value into a register on the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct WriteRegister_REAL final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[19 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the register that should be written</param>
		/// <param name="fValue">The value to write</param>
		/// <param name="bWrite">Writing the register is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, float fValue, bool bWrite)
		{
			this->nAddress = nAddress;
			this->fValue = fValue;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the register is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		WriteRegister_REAL(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[19 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteRegister_REAL()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[19 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be written
		float fValue; // The value to write
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bWrite; // Writing the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastWrite; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be written
		float fValue; // The value to write
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bWrite; // Writing the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved3[4];
	public:
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastWrite; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteRegister_REAL) == 44);
#else
	static_assert(sizeof(WriteRegister_REAL) == 56);
#endif

	/// <summary>
	/// This FB writes a DINT value into a register on the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct WriteRegister_UDINT final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[20 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the register that should be written</param>
		/// <param name="nValue">The value to write</param>
		/// <param name="bWrite">Writing the register is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, ULONG nValue, bool bWrite)
		{
			this->nAddress = nAddress;
			this->nValue = nValue;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the register is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		WriteRegister_UDINT(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[20 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteRegister_UDINT()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[20 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be written
		ULONG nValue; // The value to write
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bWrite; // Writing the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastWrite; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be written
		ULONG nValue; // The value to write
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bWrite; // Writing the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved3[4];
	public:
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastWrite; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteRegister_UDINT) == 44);
#else
	static_assert(sizeof(WriteRegister_UDINT) == 56);
#endif

	/// <summary>
	/// This FB writes a ULINT value into a register on the camera. Requires an open control channel (e.g. by calling FB_VN_GevCameraControl.OpenCamera() before)
	/// </summary>
	struct WriteRegister_ULINT final : _FB_BASE
	{
		/// <summary>
		/// Executes the FB.
		/// </summary>
		void FB_Main()
		{
			PLC_PARAM_Main params;
			params.pInstance = this;
			libraryInfo.functionBlocks[21 - Lic0FBsOffs].pFcts[0](&params);
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="nAddress">The address of the register that should be written</param>
		/// <param name="nValue">The value to write</param>
		/// <param name="bWrite">Writing the register is triggered by a rising edge at this input.</param>
		void FB_Main(GVCP_REGISTER_ADDRESS nAddress, ULONGLONG nValue, bool bWrite)
		{
			this->nAddress = nAddress;
			this->nValue = nValue;
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Executes the FB.
		/// </summary>
		/// <param name="bWrite">Writing the register is triggered by a rising edge at this input.</param>
		void FB_Main(bool bWrite)
		{
			this->bWrite = bWrite;

			FB_Main();
		}

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="oidITcVnGevImageProvider">Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.</param>
		WriteRegister_ULINT(OTCID oidITcVnGevImageProvider)
		{
			if(TmlHandler::s_ipInst)
			{
				this->oidITcVnGevImageProvider = oidITcVnGevImageProvider;

				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[21 - Lic0FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~WriteRegister_ULINT()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[21 - Lic0FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

#ifdef _X86_
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be written
		ULONGLONG nValue; // The value to write
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bWrite; // Writing the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved1;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved2[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastWrite; // Internal flag for rising edge detection
#else
		GVCP_REGISTER_ADDRESS nAddress; // The address of the register that should be written
	private:
		UCHAR reserved1[4];
	public:
		ULONGLONG nValue; // The value to write
		USHORT nEndian; // OPTIONAL: The endianness of the register. 0 = Big, 1 = Little. Default: 0
		bool bWrite; // Writing the register is triggered by a rising edge at this input.
	private:
		UCHAR reserved2;
	public:
		unsigned int nTimeout; // Indicates the time before the function is cancelled.
		bool bBusy; // This output remains TRUE until the function block has executed a command, but at the longest for the duration supplied to the 'nTimeout' input. While bBusy = TRUE, no new command will be accepted at the inputs.
		bool bError; // This output is switched to TRUE as soon as an error occurs during the execution of a command. The command-specific error code is contained in nErrorId. If the function block has a timeout error, 'bError' is TRUE and 'nErrorId' is 1861 (hexadecimal 0x745). Is reset to FALSE by the execution of a command at the inputs.
	private:
		UCHAR reserved3[2];
	public:
		ULONG nErrorId; // Contains the ADS error code or the command-specific error code of the last executed command. Is reset to 0 by the execution of a command at the inputs.
		OTCID oidITcVnGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider TcCOM module ID, which needs to be set via TC init symbol.
	private:
		UCHAR reserved4[4];
	public:
	private:
		ITcVnGevImageProvider* ipGevImageProvider; // Internal reference to the corresponding TcVnGevImageProvider module.
		unsigned int nTimeElapsed; // Internal timestamp for timeout detection
		bool bLastWrite; // Internal flag for rising edge detection
#endif
	};

#ifdef _X86_
	static_assert(sizeof(WriteRegister_ULINT) == 48);
#else
	static_assert(sizeof(WriteRegister_ULINT) == 64);
#endif
#endif

#ifdef LIC_TC3_Vision_Code_Reading
#endif

#ifdef LIC_TC3_Vision_Code_Quality
#endif

#ifdef LIC_TC3_Vision_Metrology_2D
#endif

#ifdef LIC_TC3_Vision_Matching

	/// <summary>
	/// This FB provides the Generalized Hough Ballard functionality. First, set the parameters via the corresponding methods (optional, defaults are used otherwise). Then, set the template (required). Afterwards, the Detect method can be executed.
	/// </summary>
	struct GeneralizedHoughBallard final : _FB_BASE
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		GeneralizedHoughBallard()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~GeneralizedHoughBallard()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

	private:
		struct Detect_Params : PLC_PARAM_Main
		{
			ITcVnImage* ipImage;
			ITcVnContainer*& ipPositions;
			HRESULT retVal;

			Detect_Params(ITcVnImage* ipImage, ITcVnContainer*& ipPositions) : ipImage(ipImage), ipPositions(ipPositions) { }
		};

	public:
		/// <summary>
		/// Detect the template in an image (SetTemplate must have been called before).
		/// </summary>
		/// <param name="ipImage">Source image (1 channel, USINT)</param>
		/// <param name="ipPositions">Returns the centers of the detected template positions (ContainerType_Vector_TcVnPoint2_REAL; Non-zero interface pointers are reused.)</param>
		/// <returns>HRESULT</returns>
		HRESULT Detect(ITcVnImage* ipImage, ITcVnContainer*& ipPositions)
		{
			Detect_Params params(ipImage, ipPositions);
			params.pInstance = this;

			libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[3](&params);

			return params.retVal;
		}

	private:
		struct SetCannyThreshold_Params : PLC_PARAM_Main
		{
			LONG nLow;
			LONG nHigh;
			HRESULT retVal;

			SetCannyThreshold_Params(LONG nLow, LONG nHigh) : nLow(nLow), nHigh(nHigh) { }
		};

	public:
		/// <summary>
		/// Sets the canny edge detection thresholds.
		/// </summary>
		/// <param name="nLow">Low threshold (&gt; 0)</param>
		/// <param name="nHigh">High threshold (&gt; nLow, usually 2 to 3 * nLow)</param>
		/// <returns>HRESULT</returns>
		HRESULT SetCannyThreshold(LONG nLow, LONG nHigh)
		{
			SetCannyThreshold_Params params(nLow, nHigh);
			params.pInstance = this;

			libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[4](&params);

			return params.retVal;
		}

	private:
		struct SetInvAccuRatio_Params : PLC_PARAM_Main
		{
			double fInvAccuRatio;
			HRESULT retVal;

			SetInvAccuRatio_Params(double fInvAccuRatio) : fInvAccuRatio(fInvAccuRatio) { }
		};

	public:
		/// <summary>
		/// Sets the inverted ratio of the accumulator size in relation to the source image's size (e.g. a value of 2 means that the size is halved in both directions.)
		/// </summary>
		/// <param name="fInvAccuRatio">Inverted accumulator ratio (&gt; 0)</param>
		/// <returns>HRESULT</returns>
		HRESULT SetInvAccuRatio(double fInvAccuRatio)
		{
			SetInvAccuRatio_Params params(fInvAccuRatio);
			params.pInstance = this;

			libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[5](&params);

			return params.retVal;
		}

	private:
		struct SetLevels_Params : PLC_PARAM_Main
		{
			LONG nLevels;
			HRESULT retVal;

			SetLevels_Params(LONG nLevels) : nLevels(nLevels) { }
		};

	public:
		/// <summary>
		/// Sets the number of R-table levels.
		/// </summary>
		/// <param name="nLevels">Number of R-table levels (&gt; 0)</param>
		/// <returns>HRESULT</returns>
		HRESULT SetLevels(LONG nLevels)
		{
			SetLevels_Params params(nLevels);
			params.pInstance = this;

			libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[6](&params);

			return params.retVal;
		}

	private:
		struct SetMinDist_Params : PLC_PARAM_Main
		{
			double fMinDist;
			HRESULT retVal;

			SetMinDist_Params(double fMinDist) : fMinDist(fMinDist) { }
		};

	public:
		/// <summary>
		/// Sets the minimum distance between the centers of different objects.
		/// </summary>
		/// <param name="fMinDist">Minimum distance (&gt; 0)</param>
		/// <returns>HRESULT</returns>
		HRESULT SetMinDist(double fMinDist)
		{
			SetMinDist_Params params(fMinDist);
			params.pInstance = this;

			libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[7](&params);

			return params.retVal;
		}

	private:
		struct SetTemplate_Params : PLC_PARAM_Main
		{
			ITcVnImage* ipImage;
			HRESULT retVal;

			SetTemplate_Params(ITcVnImage* ipImage) : ipImage(ipImage) { }
		};

	public:
		/// <summary>
		/// Sets the template image to search for in the Detect method.
		/// </summary>
		/// <param name="ipImage">Template image (1 channel, USINT)</param>
		/// <returns>HRESULT</returns>
		HRESULT SetTemplate(ITcVnImage* ipImage)
		{
			SetTemplate_Params params(ipImage);
			params.pInstance = this;

			libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[8](&params);

			return params.retVal;
		}

	private:
		struct SetVotesThreshold_Params : PLC_PARAM_Main
		{
			LONG nVotes;
			HRESULT retVal;

			SetVotesThreshold_Params(LONG nVotes) : nVotes(nVotes) { }
		};

	public:
		/// <summary>
		/// Sets the accumulator threshold, i.e. the number of votes required to detect a match (too small values lead to false detections).
		/// </summary>
		/// <param name="nVotes">Number of votes required to detect a match (&gt; 0)</param>
		/// <returns>HRESULT</returns>
		HRESULT SetVotesThreshold(LONG nVotes)
		{
			SetVotesThreshold_Params params(nVotes);
			params.pInstance = this;

			libraryInfo.functionBlocks[22 - Lic4FBsOffs].pFcts[9](&params);

			return params.retVal;
		}

#ifdef _X86_
	private:
		PVOID internal1; // Internal stuff
		PVOID internal2; // Internal stuff
		bool internal3; // Internal stuff
#else
	private:
		PVOID internal1; // Internal stuff
		PVOID internal2; // Internal stuff
		bool internal3; // Internal stuff
#endif
	};

#ifdef _X86_
	static_assert(sizeof(GeneralizedHoughBallard) == 16);
#else
	static_assert(sizeof(GeneralizedHoughBallard) == 32);
#endif

	/// <summary>
	/// This FB provides the structural similarity (SSIM) functionality. First, set the reference image. Afterwards, the Compute method can be executed.
	/// </summary>
	struct SSIM final : _FB_BASE
	{
		/// <summary>
		/// Constructor.
		/// </summary>
		SSIM()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Init params;
				params.pInstance = this;
				params.bInCopyCode = false;
				params.bInitRetains = false;

				libraryInfo.functionBlocks[23 - Lic4FBsOffs].pFcts[2](&params);

				TmlHandler::s_ipInst->IncrementReference();
			}
		}

		/// <summary>
		/// Destructor.
		/// </summary>
		virtual ~SSIM()
		{
			if(TmlHandler::s_ipInst)
			{
				PLC_PARAM_Exit params;
				params.pInstance = this;
				params.bInCopyCode = false;

				libraryInfo.functionBlocks[23 - Lic4FBsOffs].pFcts[1](&params);

				TmlHandler::s_ipInst->DecrementReference();
			}
		}

	private:
		struct Compute_Params : PLC_PARAM_Main
		{
			ITcVnImage* ipSrcImage;
			ITcVnImage*& ipSSIM;
			HRESULT retVal;

			Compute_Params(ITcVnImage* ipSrcImage, ITcVnImage*& ipSSIM) : ipSrcImage(ipSrcImage), ipSSIM(ipSSIM) { }
		};

	public:
		/// <summary>
		/// Compute the structural similarity (SetReference must have been called before).
		/// </summary>
		/// <param name="ipSrcImage">Source image (USINT)</param>
		/// <param name="ipSSIM">Returns the SSIM (REAL, values from 0 to 1)</param>
		/// <returns>HRESULT</returns>
		HRESULT Compute(ITcVnImage* ipSrcImage, ITcVnImage*& ipSSIM)
		{
			Compute_Params params(ipSrcImage, ipSSIM);
			params.pInstance = this;

			libraryInfo.functionBlocks[23 - Lic4FBsOffs].pFcts[3](&params);

			return params.retVal;
		}

	private:
		struct SetReference_Params : PLC_PARAM_Main
		{
			ITcVnImage* ipImage;
			HRESULT retVal;

			SetReference_Params(ITcVnImage* ipImage) : ipImage(ipImage) { }
		};

	public:
		/// <summary>
		/// Sets the reference image, used by the SSIM method.
		/// </summary>
		/// <param name="ipImage">Reference image (USINT)</param>
		/// <returns>HRESULT</returns>
		HRESULT SetReference(ITcVnImage* ipImage)
		{
			SetReference_Params params(ipImage);
			params.pInstance = this;

			libraryInfo.functionBlocks[23 - Lic4FBsOffs].pFcts[4](&params);

			return params.retVal;
		}

#ifdef _X86_
	private:
		PVOID internal1; // Internal stuff
#else
	private:
		PVOID internal1; // Internal stuff
#endif
	};

#ifdef _X86_
	static_assert(sizeof(SSIM) == 8);
#else
	static_assert(sizeof(SSIM) == 16);
#endif
#endif

#ifdef LIC_TC3_Vision_OCR
#endif

#ifdef LIC_TC3_Machine_Learning_Realtime_Inference
#endif

#ifdef LIC_TC3_Neural_Network_Realtime_Inference
#endif

	///////////////////////////////////////////////////////////////////////////////
	// TcVisionCppTypes.h
	
	#ifndef TCVN_CPPTYPES_NAMESPACE
		#define TCVN_CPPTYPES_NAMESPACE std
	#endif
	
	///////////////////////////////////////////////////////////////////////////////
	// iterators
	///////////////////////////////////////////////////////////////////////////////
	
	//-----------------------------------------------------------------------------
	// helper types
	//-----------------------------------------------------------------------------
	
	template<typename _valueType, size_t nDepth>class CTc3_VisionArrowOperatorProxy
	{
		static_assert(nDepth > 0, "CTc3_VisionArrowOperatorProxy requires nDepth > 0");
	
	public:
		using value_type = typename _valueType;
	
	private:
		value_type m_value;
	
	public:
	
		CTc3_VisionArrowOperatorProxy(const value_type& value) : m_value{value} {}
		CTc3_VisionArrowOperatorProxy(const CTc3_VisionArrowOperatorProxy<_valueType, nDepth>&) = delete;
		CTc3_VisionArrowOperatorProxy<_valueType, nDepth>& operator=(const CTc3_VisionArrowOperatorProxy<_valueType, nDepth>&) = delete;
	
		value_type* operator->()
		{
			return TCVN_CPPTYPES_NAMESPACE::addressof(m_value);
		}
	
		const value_type* operator->() const
		{
			return TCVN_CPPTYPES_NAMESPACE::addressof(m_value);
		}
	};
	
	template<typename _valueType>class CTc3_VisionArrowOperatorProxy<_valueType, 1>
	{
	public:
		using value_type = typename _valueType;
	
	private:
		const value_type m_value;
	
	public:
	
		CTc3_VisionArrowOperatorProxy(const value_type& value) : m_value{value} {}
		CTc3_VisionArrowOperatorProxy(const CTc3_VisionArrowOperatorProxy<_valueType, 1>&) = delete;
		CTc3_VisionArrowOperatorProxy<_valueType, 1>& operator=(const CTc3_VisionArrowOperatorProxy<_valueType, 1>&) = delete;
	
		const value_type* operator->() const
		{
			return TCVN_CPPTYPES_NAMESPACE::addressof(m_value);
		}
	};
	
	namespace Tc3_VisionCppInternal
	{
		template<typename _valueType, template<typename, size_t>class _containerType, size_t nDepth>
		struct CTc3_VisionDereferenceTraits
		{
			using value_type = ITcVnContainer*;
			using reference = value_type&;
			using size_type = typename _containerType<_valueType, nDepth>::size_type;
			using dereference_type = _containerType<_valueType, nDepth - 1>;
	
			static dereference_type Dereference(ITcVnForwardIterator* ipIterator)
			{
				if(ipIterator != nullptr)
				{
					dereference_type spTmp;
					HRESULT hr = ipIterator->GetContainer(&spTmp);
				
					if(SUCCEEDED(hr))
						return spTmp;
					else // virtually impossible
						TCVN_ERROR(STATUS_TCVN_GENERAL_ERROR);
				}
				else
					TCVN_ERROR(STATUS_TCVN_NULL_POINTER);
	
				return dereference_type();
			}
	
			static HRESULT Get(ITcVnForwardIterator* ipIterator, reference ipContainer)
			{
				if(ipIterator != nullptr)
					return ipIterator->GetContainer(&ipContainer);
				else
					return ADS_E_NOINTERFACE;
			}
	
			static HRESULT GetAt(ITcVnRandomAccessIterator* ipIterator, size_type nIndex, reference ipContainer)
			{
				if(ipIterator != nullptr)
					return ipIterator->GetContainerAt(nIndex, &ipContainer);
				else
					return ADS_E_NOINTERFACE;
			}
	
			static HRESULT Set(ITcVnForwardIterator* ipIterator, value_type ipContainer)
			{
				if(ipIterator != nullptr)
					return ipIterator->SetContainer(ipContainer);
				else
					return ADS_E_NOINTERFACE;
			}
		};
	
		template<typename _valueType, template<typename, size_t>class _containerType>
		struct CTc3_VisionDereferenceTraits<_valueType, _containerType, 2>
		{
			using value_type = _valueType;
			using reference = typename _containerType<value_type, 2>::reference;
			using size_type = typename _containerType<value_type, 2>::size_type;
			using dereference_type = _valueType;
			using access_interface = typename Tc3_VisionElementAccessTraits<value_type>::access_interface_type;
			using access_smart_pointer = _TCOM_SMARTPTR<_tc_com_IIID<access_interface, &__uuidof(access_interface)> >;
			using random_access_interface = typename Tc3_VisionElementAccessTraits<value_type>::random_access_interface_type;
			using random_access_smart_pointer = _TCOM_SMARTPTR<_tc_com_IIID<random_access_interface, &__uuidof(random_access_interface)> >;
	
			static dereference_type Dereference(ITcVnForwardIterator* ipIterator)
			{
				if(ipIterator != nullptr)
				{
					access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(access_interface), reinterpret_cast<PPVOID>(&spAccessor));
	
					dereference_type tmp;
					hr = FAILED(hr) ? hr : spAccessor->Get(tmp);
					if(SUCCEEDED(hr))
						return tmp;
					else // virtually impossible
						TCVN_ERROR(STATUS_TCVN_GENERAL_ERROR);
				}
				else
					TCVN_ERROR(STATUS_TCVN_NULL_POINTER);
	
				return dereference_type();
			}
	
			static HRESULT Get(ITcVnForwardIterator* ipIterator, reference val)
			{
				if(ipIterator != nullptr)
				{
					access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(access_interface), reinterpret_cast<PPVOID>(&spAccessor));
					hr = FAILED(hr) ? hr : spAccessor->Get(val);
					return hr;
				}
				else
					return ADS_E_NOINTERFACE;
			}
	
			static HRESULT GetAt(ITcVnRandomAccessIterator* ipIterator, size_type nIndex, reference val)
			{
				if(ipIterator != nullptr)
				{
					random_access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(random_access_interface), reinterpret_cast<PPVOID>(&spAccessor));
					hr = FAILED(hr) ? hr : spAccessor->GetAt(nIndex, val);
					return hr;
				}
				else
					return ADS_E_NOINTERFACE;
			}
	
			static HRESULT SetArithmetic(ITcVnForwardIterator* ipIterator, value_type val)
			{
				if(ipIterator != nullptr)
				{
					access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(access_interface), reinterpret_cast<PPVOID>(&spAccessor));
					hr = FAILED(hr) ? hr : spAccessor->Set(val);
					return hr;
				}
				else
					return ADS_E_NOINTERFACE;
			}
	
			static HRESULT SetNonArithmetic(ITcVnForwardIterator* ipIterator, reference val)
			{
				if(ipIterator != nullptr)
				{
					access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(access_interface), reinterpret_cast<PPVOID>(&spAccessor));
					hr = FAILED(hr) ? hr : spAccessor->Set(val);
					return hr;
				}
				else
					return ADS_E_NOINTERFACE;
			}
		};
	
		template<template<typename, size_t>class _containerType>
		struct CTc3_VisionDereferenceTraits<ITcVnImage*, _containerType, 2>;
	}
	
	//-----------------------------------------------------------------------------
	// CTc3_VisionIteratorBase
	//-----------------------------------------------------------------------------
	
	namespace Tc3_VisionCppInternal
	{
		template<typename _valueType, template<typename, size_t>class _containerType, size_t nDepth>
		class CTc3_VisionIteratorBase
		{	
		protected:
			using value_type = typename _containerType<_valueType, nDepth>::value_type;
			using const_pointer = typename _containerType<_valueType, nDepth>::const_pointer;
			using pointer = typename _containerType<_valueType, nDepth>::pointer;
			using reference = typename _containerType<_valueType, nDepth>::reference;
	
		protected:
			ITcVnForwardIterator* m_ipIterator;
	
		protected:
	
			CTc3_VisionIteratorBase() : m_ipIterator{} {}
			CTc3_VisionIteratorBase(const CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>&) = delete;
			CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>& operator=(const CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>&) = delete;
	
			CTc3_VisionIteratorBase(ITcVnForwardIterator* ipIterator)
			{
				m_ipIterator = ipIterator;
				if(m_ipIterator)
					m_ipIterator->TcAddRef();
			}
	
			~CTc3_VisionIteratorBase()
			{
				safe_release(m_ipIterator);
			}
	
			static void Copy(const ITcVnForwardIterator* ipSrc, ITcVnForwardIterator** pipDest)
			{
				ITcVnIteratorCopyCreatorPtr spIteratorCopyCreator;
	
				if(pipDest == nullptr)
					TCVN_ERROR(STATUS_TCVN_NULL_POINTER)
				else if(ipSrc != nullptr)
				{
					safe_release(*pipDest);
	
					HRESULT hr = const_cast<ITcVnForwardIterator*>(ipSrc)->TcQueryInterface(IID_ITcVnIteratorCopyCreator, reinterpret_cast<PPVOID>(&spIteratorCopyCreator));
					hr = FAILED(hr) ? hr : spIteratorCopyCreator->Create(pipDest);
	
					if(hr == ADS_E_NOMEMORY)
						TCVN_ERROR(STATUS_TCVN_MEMORY_ALLOCATION_FAILED)
					else if(FAILED(hr)) // virtually impossible
						TCVN_ERROR(STATUS_TCVN_GENERAL_ERROR)
				}
				else
					safe_release(*pipDest);
			}
	
			void Increment() 
			{
				if(m_ipIterator)
				{
					HRESULT hr = m_ipIterator->Increment();
					TCVN_ASSERT(SUCCEEDED(hr));
				}
				else
					TCVN_ERROR(STATUS_TCVN_NULL_POINTER);
			}
	
		public:
	
			bool operator==(const CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>& rhs) const 
			{
				if(m_ipIterator == rhs.m_ipIterator)
					return true;
				else if(m_ipIterator)
					return m_ipIterator->CheckIfEqualTo(rhs.m_ipIterator) == S_OK;
				else
					return false;
			} 
	
			bool operator!=(const CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>& rhs) const 
			{
				return !operator==(rhs);
			}
		};
	}
	
	
	//-----------------------------------------------------------------------------
	// CTc3_VisionIterator
	//-----------------------------------------------------------------------------
	
	namespace Tc3_VisionCppInternal
	{
		template<typename _valueType, template<typename, size_t>class _containerType, size_t nDepth>
		struct CTc3_VisionIterator : CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>
		{
			using iterator_category = TCVN_CPPTYPES_NAMESPACE::input_iterator_tag;
			using value_type = typename _containerType<_valueType, nDepth>::value_type;
			using difference_type = typename _containerType<value_type, nDepth>::difference_type;
			using pointer = typename _containerType<value_type, nDepth>::pointer;
			using const_pointer = typename _containerType<value_type, nDepth>::const_pointer;
			using reference = typename _containerType<value_type, nDepth>::reference;
			using base_type = typename CTc3_VisionIteratorBase<value_type, _containerType, nDepth>;
	
			using base_type::m_ipIterator;
	
			CTc3_VisionIterator() = default;
			CTc3_VisionIterator(ITcVnForwardIterator* ipIterator) : CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>{ipIterator} {}
	
			CTc3_VisionIterator(const CTc3_VisionIterator<value_type, _containerType, nDepth>& itOrg)
			{
				base_type::Copy(itOrg.m_ipIterator, &m_ipIterator);
			}
	
			operator ITcVnForwardIterator*&()
			{
				return m_ipIterator;
			}
	
			operator const ITcVnForwardIterator*() const
			{
				return m_ipIterator;
			}
	
			operator ITcVnForwardIterator**()
			{
				return &m_ipIterator;
			}
	
			CTc3_VisionIterator<value_type, _containerType, nDepth>& operator=(const CTc3_VisionIterator<value_type, _containerType, nDepth>& rhs)
			{
				if(this != &rhs)
					base_type::Copy(rhs.m_ipIterator, &m_ipIterator);
	
				return *this;
			}
	
			typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::dereference_type operator*() const
			{
				return Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::Dereference(m_ipIterator);
			}
	
			CTc3_VisionArrowOperatorProxy<typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::dereference_type, nDepth - 1>operator->() const
			{
				return CTc3_VisionArrowOperatorProxy<typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::dereference_type, nDepth - 1>(operator*());
			}
	
			CTc3_VisionIterator operator++()
			{
				base_type::Increment();
				return *this;
			}
	
			CTc3_VisionIterator operator++(int)
			{	
				ITcVnForwardIterator* ipCreatedIterator = nullptr;
				base_type::Copy(m_ipIterator, &ipCreatedIterator);
				this->Increment();
				CTc3_VisionIterator it(ipCreatedIterator);
				safe_release(ipCreatedIterator);
				return it;
			}
	
			// Get can only be called for non-const references. 
			HRESULT Get(typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::reference val) const
			{
				return Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::Get(m_ipIterator, val);
			}
	
			template<typename _setValueType = value_type, size_t nSetDepth = nDepth>
			typename TCVN_CPPTYPES_NAMESPACE::enable_if<
				TCVN_CPPTYPES_NAMESPACE::is_same<_setValueType, value_type>::value &&
				TCVN_CPPTYPES_NAMESPACE::is_arithmetic<_setValueType>::value &&
				(nSetDepth == nDepth) && (nSetDepth == 2), HRESULT>::type
			Set(const _setValueType val)
			{
				return Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::SetArithmetic(m_ipIterator, val);
			}
	
			template<typename _setValueType = value_type, size_t nSetDepth = nDepth>
			typename TCVN_CPPTYPES_NAMESPACE::enable_if<
				TCVN_CPPTYPES_NAMESPACE::is_same<_setValueType, value_type>::value &&
				!TCVN_CPPTYPES_NAMESPACE::is_arithmetic<_setValueType>::value &&
				!TCVN_CPPTYPES_NAMESPACE::is_same<_setValueType, ITcVnImage*>::value &&
				(nSetDepth == nDepth) && (nSetDepth == 2), HRESULT>::type
			Set(_setValueType&& val)
			{
				return Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::SetNonArithmetic(m_ipIterator, val);
			}
	
			template<typename _setValueType = value_type, size_t nSetDepth = nDepth>
			typename TCVN_CPPTYPES_NAMESPACE::enable_if<
				TCVN_CPPTYPES_NAMESPACE::is_same<_setValueType, value_type>::value &&
				TCVN_CPPTYPES_NAMESPACE::is_same<_setValueType, ITcVnImage*>::value &&
				(nSetDepth == nDepth) && (nSetDepth == 2), HRESULT>::type
			Set(ITcVnImage* ipImage)
			{
				return Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::Set(m_ipIterator, ipImage);
			}
	
			template<size_t nSetDepth = nDepth>
			typename TCVN_CPPTYPES_NAMESPACE::enable_if<(nSetDepth == nDepth) && (nSetDepth >= 2), HRESULT>::type
			Set(ITcVnContainer* ipContainer)
			{
				return Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::Set(m_ipIterator, ipContainer);
			}
		};
	}
	
	//-----------------------------------------------------------------------------
	// CTc3_VisionConstIterator
	//-----------------------------------------------------------------------------
	
	namespace Tc3_VisionCppInternal
	{
		template<typename _valueType, template<typename, size_t>class _containerType, size_t nDepth>
		struct CTc3_VisionConstIterator : CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>
		{
			using iterator_category = TCVN_CPPTYPES_NAMESPACE::input_iterator_tag;
			using value_type = typename _containerType<_valueType, nDepth>::value_type;
			using difference_type = typename _containerType<value_type, nDepth>::difference_type;
			using pointer = typename _containerType<value_type, nDepth>::const_pointer;
			using const_pointer = typename _containerType<value_type, nDepth>::const_pointer;
			using reference = typename _containerType<value_type, nDepth>::const_reference;
			using base_type = typename CTc3_VisionIteratorBase<value_type, _containerType, nDepth>;
	
			using base_type::m_ipIterator;
	
			CTc3_VisionConstIterator() = default;
			CTc3_VisionConstIterator(ITcVnForwardIterator* ipIterator) : CTc3_VisionIteratorBase<_valueType, _containerType, nDepth>{ipIterator} {}
	
			CTc3_VisionConstIterator(const CTc3_VisionConstIterator<value_type, _containerType, nDepth>& itOrg)
			{
				base_type::Copy(itOrg.m_ipIterator, &m_ipIterator);
			}
	
			CTc3_VisionConstIterator(const CTc3_VisionIterator<value_type, _containerType, nDepth>& it)
			{
				base_type::Copy(const_cast<ITcVnForwardIterator*>(static_cast<const ITcVnForwardIterator*>(it)), &m_ipIterator);
			}
	
			operator const ITcVnForwardIterator*() const
			{
				return m_ipIterator;
			}
	
			CTc3_VisionConstIterator<value_type, _containerType, nDepth>& operator=(const CTc3_VisionConstIterator<value_type, _containerType, nDepth>& rhs)
			{
				if(this != & rhs)
					base_type::Copy(rhs.m_ipIterator, &m_ipIterator);
	
				return *this;
			}
	
			CTc3_VisionConstIterator<value_type, _containerType, nDepth>& operator=(const CTc3_VisionIterator<value_type, _containerType, nDepth>& rhs)
			{
				base_type::Copy(static_cast<const ITcVnForwardIterator*>(rhs), &m_ipIterator);
				return *this;
			}
	
			const typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::dereference_type operator*() const
			{
				return Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::Dereference(m_ipIterator);
			}
	
			const CTc3_VisionArrowOperatorProxy<const typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::dereference_type, nDepth - 1>operator->() const
			{
				return CTc3_VisionArrowOperatorProxy<const typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, _containerType, nDepth>::dereference_type, nDepth - 1>(operator*());
			}
	
			CTc3_VisionConstIterator operator++()
			{
				base_type::Increment();
				return *this;
			}
	
			CTc3_VisionConstIterator operator++(int)
			{	
				ITcVnForwardIterator* ipCreatedIterator = nullptr;
				base_type::Copy(m_ipIterator, &ipCreatedIterator);
				this->Increment();
				CTc3_VisionConstIterator it(ipCreatedIterator);
				safe_release(ipCreatedIterator);
				return it;
			}
		};
	}
	
	///////////////////////////////////////////////////////////////////////////////
	// smart pointer definitions
	///////////////////////////////////////////////////////////////////////////////
	
	#define TC3_VISION_VPTR_BASICS(CLASS_NAME, ITF_TYPE) \
		using interface_type = ITF_TYPE; \
		using base_type = _tc_com_ptr_t<_tc_com_IIID<interface_type, &__uuidof(interface_type)> >; \
		CLASS_NAME() = default; \
		template<typename _otherIID>CLASS_NAME(const _tc_com_ptr_t<_otherIID>& spSmartPointer) : base_type{spSmartPointer} {} \
		template<typename _interfaceType>CLASS_NAME(_interfaceType* ipInterface) : base_type{ipInterface} {} \
		explicit CLASS_NAME(CLASS_NAME* pSmartPointer) : base_type{static_cast<base_type*>(pSmartPointer)} {} \
		CLASS_NAME(int oid) : base_type{oid} {} \
		CLASS_NAME(interface_type* ipInterface) : base_type{ipInterface} {} \
		CLASS_NAME(interface_type* ipInterface, bool bAddRef) : base_type{ipInterface, bAddRef} {} \
		CLASS_NAME(const CLASS_NAME&) = default; \
		CLASS_NAME& operator=(const CLASS_NAME&) = default; \
		using base_type::operator=; \
		operator interface_type*() const { return base_type::operator interface_type*(); } \
		operator interface_type*&() { return base_type::m_pInterface; } \
		template<typename _Ty = void>operator bool() { return base_type::operator bool(); } \
		template<typename _Ty = void>operator bool() const { return base_type::operator bool(); }
	
	///////////////////////////////////////////////////////////////////////////////
	// container
	///////////////////////////////////////////////////////////////////////////////
	
	namespace Tc3_VisionCppInternal
	{
		template<typename _elementType, size_t nDepth>
		struct ITc3_VisionContainerPtr : _tc_com_ptr_t<_tc_com_IIID<ITcVnContainer, &__uuidof(ITcVnContainer)> >
		{
			static_assert(!TCVN_CPPTYPES_NAMESPACE::is_pointer<_elementType>::value || 
				TCVN_CPPTYPES_NAMESPACE::is_same<_elementType, ITcVnImage*>::value, "element type not allowed");
	
	//-----------------------------------------------------------------------------
	//                                public types
	//-----------------------------------------------------------------------------
	
		public:
			using value_type = _elementType;
			using reference = value_type&;
			using const_reference = const value_type&;
			using pointer = value_type*;
			using const_pointer = const value_type*;
			using difference_type = long long;
			using size_type = unsigned long long;
	
	//-----------------------------------------------------------------------------
	//                            public data members
	//-----------------------------------------------------------------------------
	
		public:
			static constexpr size_t m_nDepth = nDepth;
	
	//-----------------------------------------------------------------------------
	//                          iterator type definitions
	//-----------------------------------------------------------------------------
	
		public:
			using iterator = CTc3_VisionIterator<value_type, Tc3_VisionCppInternal::ITc3_VisionContainerPtr, m_nDepth>;
			using const_iterator = CTc3_VisionConstIterator<value_type, Tc3_VisionCppInternal::ITc3_VisionContainerPtr, m_nDepth>;
	
	//-----------------------------------------------------------------------------
	//                                helper methods
	//-----------------------------------------------------------------------------
	
		private:
	
			template<typename _iteratorType>_iteratorType Begin() const
			{
				HRESULT hr = S_OK;
	
				if(m_pInterface != nullptr)
				{
					ITcVnForwardIterator* ipIterator = nullptr;
					hr = m_pInterface->GetForwardIterator(&ipIterator);
					hr = FAILED(hr) ? hr : ipIterator->SetToBegin(); 
					if(SUCCEEDED(hr))
					{
						_iteratorType it(ipIterator);
						ipIterator->TcRelease();
						return it;
					}
					else // virtually impossible
					{
						safe_release(ipIterator);
						TCVN_ERROR(STATUS_TCVN_GENERAL_ERROR);
					}
				}
				else
					TCVN_ERROR(STATUS_TCVN_NULL_POINTER);
	
				return _iteratorType(nullptr);
			}
	
			template<typename _iteratorType>_iteratorType End() const
			{
				HRESULT hr = S_OK;
	
				if(m_pInterface != nullptr)
				{
					ITcVnForwardIterator* ipIterator = nullptr;
					hr = m_pInterface->GetForwardIterator(&ipIterator);
					hr = FAILED(hr) ? hr : ipIterator->SetToEnd(); 
					if(SUCCEEDED(hr))
					{
						_iteratorType it(ipIterator);
						ipIterator->TcRelease();
						return it;
					}
					else // virtually impossible
					{
						safe_release(ipIterator);
						TCVN_ERROR(STATUS_TCVN_GENERAL_ERROR);
					}
				}
				else
					TCVN_ERROR(STATUS_TCVN_NULL_POINTER);
	
				return _iteratorType(nullptr); 
			}
	
	//-----------------------------------------------------------------------------
	//                                 public methods
	//-----------------------------------------------------------------------------
	
		public:
			TC3_VISION_VPTR_BASICS(ITc3_VisionContainerPtr, ITcVnContainer);
	
			iterator begin() 
			{
				return Begin<iterator>();
			}
	
			const_iterator begin() const
			{
				return Begin<const_iterator>();
			}
	
			const_iterator cbegin() const 
			{
				return Begin<const_iterator>();
			}
	
			iterator end() 
			{ 
				return End<iterator>();
			}
	
			const_iterator end() const 
			{
				return End<const_iterator>();
			}
	
			const_iterator cend() const 
			{
				return End<const_iterator>();
			}
	
			size_type size() const 
			{
				if(m_pInterface == nullptr)
					return 0;
				else
				{
					size_type nSize;
					HRESULT hr = m_pInterface->GetElementNum(nSize);
	
					TCVN_ASSERT(SUCCEEDED(hr));
	
					return FAILED(hr) ? 0 : nSize;
				}
			}
	
			bool empty() const
			{
				return(size() == 0);
			}
	
			// returns an r-value
			template<typename _indexType = typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, Tc3_VisionCppInternal::ITc3_VisionContainerPtr, nDepth>::dereference_type>
			typename TCVN_CPPTYPES_NAMESPACE::enable_if<TCVN_CPPTYPES_NAMESPACE::is_integral<_indexType>::value,
				typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, Tc3_VisionCppInternal::ITc3_VisionContainerPtr, nDepth>::dereference_type>::type
			operator[](_indexType nIndex) const
			{
				HRESULT hr;
	
				TCVN_ASSERT(nIndex >= 0)
	
				const_iterator it = cbegin();
				TCVN_CONDITIONAL_ERROR(!static_cast<const ITcVnForwardIterator*>(it), STATUS_TCVN_NULL_POINTER)
	
				ITcVnRandomAccessIterator* ipIterator = nullptr;
				hr = const_cast<ITcVnForwardIterator*>(static_cast<const ITcVnForwardIterator*>(it))->TcQueryInterface(IID_ITcVnRandomAccessIterator, reinterpret_cast<PPVOID>(&ipIterator));
				TCVN_CONDITIONAL_ERROR(FAILED(hr), STATUS_TCVN_NOT_SUPPORTED)
	
				typename Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, Tc3_VisionCppInternal::ITc3_VisionContainerPtr, nDepth>::dereference_type val{};
				hr = Tc3_VisionCppInternal::CTc3_VisionDereferenceTraits<value_type, Tc3_VisionCppInternal::ITc3_VisionContainerPtr, nDepth>::GetAt(ipIterator, nIndex, val);
				safe_release(ipIterator);
				TCVN_CONDITIONAL_ERROR(FAILED(hr), STATUS_TCVN_GENERAL_ERROR) // virtually impossible
	
				return val;
			}
		};
	}
	
	template<typename _elementType, size_t nDepth = 2>
	using ITcVnContainerVPtr = Tc3_VisionCppInternal::ITc3_VisionContainerPtr<_elementType, nDepth>;
	
	///////////////////////////////////////////////////////////////////////////////
	// ITcVnImageVPtr
	///////////////////////////////////////////////////////////////////////////////
	
	struct ITcVnImageVPtr : _tc_com_ptr_t<_tc_com_IIID<ITcVnImage, &__uuidof(ITcVnImage)> >
	{
		TC3_VISION_VPTR_BASICS(ITcVnImageVPtr, ITcVnImage);
	
		ULONG Width() const
		{
			if(m_pInterface == nullptr)
				return 0;
			else
			{
				ULONG nWidth;
				HRESULT hr = m_pInterface->GetWidth(nWidth);
	
				TCVN_ASSERT(SUCCEEDED(hr));
	
				return FAILED(hr) ? 0 : nWidth;
			}
		}
	
		ULONG Height() const
		{
			if(m_pInterface == nullptr)
				return 0;
			else
			{
				ULONG nHeight;
				HRESULT hr = m_pInterface->GetHeight(nHeight);
	
				TCVN_ASSERT(SUCCEEDED(hr));
	
				return FAILED(hr) ? 0 : nHeight;
			}
		}
	
		USHORT Channels() const
		{
			if(m_pInterface == nullptr)
				return 0;
			else
			{
				VN_TcVnPixelFormat stFormat;
				HRESULT hr = m_pInterface->GetPixelFormat(stFormat);
	
				TCVN_ASSERT(SUCCEEDED(hr));
	
				return FAILED(hr) ? 0 : static_cast<USHORT>(stFormat.nChannels);
			}
		}
	
		VN_ETcVnPixelEncoding PixelEncoding() const
		{
			if(m_pInterface == nullptr)
				return TCVN_PE_NONE;
			else
			{
				VN_TcVnPixelFormat stFormat;
				HRESULT hr = m_pInterface->GetPixelFormat(stFormat);
	
				TCVN_ASSERT(SUCCEEDED(hr));
	
				return FAILED(hr) ? TCVN_PE_NONE : stFormat.ePixelEncoding;
			}
		}
	
		VN_ETcVnElementType ElementType() const
		{
			if(m_pInterface == nullptr)
				return TCVN_ET_SAME_AS_SOURCE;
			else
			{
				VN_TcVnPixelFormat stFormat;
				HRESULT hr = m_pInterface->GetPixelFormat(stFormat);
	
				TCVN_ASSERT(SUCCEEDED(hr));
	
				if(FAILED(hr))
					return TCVN_ET_SAME_AS_SOURCE;
	
				VN_ETcVnElementType eType = TCVN_ET_SAME_AS_SOURCE;
	
				if(!stFormat.bFloat)
				{
					// unsigned integer
					if(!stFormat.bSigned)
					{
						switch(stFormat.nElementSize)
						{
						case 8:
							eType = TCVN_ET_USINT;
							break;
						case 16:
							eType = TCVN_ET_UINT;
							break;
						}
					}
					// signed integer
					else
					{
						switch(stFormat.nElementSize)
						{
						case 8:
							eType = TCVN_ET_SINT;
							break;
						case 16:
							eType = TCVN_ET_INT;
							break;
						case 32:
							eType = TCVN_ET_DINT;
							break;
						}
					}
				}
				// float
				else
				{
					switch(stFormat.nElementSize)
					{
					case 32:
						eType = TCVN_ET_REAL;
						break;
					case 64:
						eType = TCVN_ET_LREAL;
						break;
					}
				}
	
				return eType;
			}
		}
	};
	
	///////////////////////////////////////////////////////////////////////////////
	// simple smart pointers
	///////////////////////////////////////////////////////////////////////////////
	
	namespace Tc3_VisionCppInternal
	{
		template<typename _itfTy>
		struct ITc3_VisionSmartPointer : _tc_com_ptr_t<_tc_com_IIID<_itfTy, &__uuidof(_itfTy)> >
		{
			TC3_VISION_VPTR_BASICS(ITc3_VisionSmartPointer, _itfTy);
		};
	}
	
	using ITcVnDisplayableImageVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnDisplayableImage>;
	using ITcVnBitmapExportVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnBitmapExport>;
	using ITcVnTiffExportVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnTiffExport>;
	using ITcVnForwardIteratorVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnForwardIterator>;
	using ITcVnBidirectionalIteratorVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnBidirectionalIterator>;
	using ITcVnRandomAccessIteratorVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnRandomAccessIterator>;
	using ITcVnColorModelVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<ITcVnColorModel>;	// use ITcVnColorModel from the library namespace
	using ITcVnMlModelVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnMlModel>;
	using ITcVnNeuralNetworkVPtr = Tc3_VisionCppInternal::ITc3_VisionSmartPointer<::ITcVnNeuralNetwork>;
	
	namespace Tc3_VisionCppInternal
	{
		template<template<typename, size_t>class _containerType>
		struct CTc3_VisionDereferenceTraits<ITcVnImage*, _containerType, 2>
		{
			using value_type = ITcVnImage*;
			using reference = typename _containerType<value_type, 2>::reference;
			using size_type = typename _containerType<value_type, 2>::size_type;
			using dereference_type = ITcVnImageVPtr;
			using access_interface = typename Tc3_VisionElementAccessTraits<value_type>::access_interface_type;
			using access_smart_pointer = _TCOM_SMARTPTR<_tc_com_IIID<access_interface, &__uuidof(access_interface)> >;
			using random_access_interface = typename Tc3_VisionElementAccessTraits<value_type>::random_access_interface_type;
			using random_access_smart_pointer = _TCOM_SMARTPTR<_tc_com_IIID<random_access_interface, &__uuidof(random_access_interface)> >;
	
			static dereference_type Dereference(ITcVnForwardIterator* ipIterator)
			{
				if(ipIterator != nullptr)
				{
					access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(access_interface), reinterpret_cast<PPVOID>(&spAccessor));
	
					dereference_type spTmp;
					hr = FAILED(hr) ? hr : spAccessor->Get(spTmp);
					if(SUCCEEDED(hr))
						return spTmp;
					else // virtually impossible
						TCVN_ERROR(STATUS_TCVN_GENERAL_ERROR);
				}
				else
					TCVN_ERROR(STATUS_TCVN_NULL_POINTER);
	
				return dereference_type();
			}
	
			static HRESULT Get(ITcVnForwardIterator* ipIterator, reference val)
			{
				if(ipIterator != nullptr)
				{
					access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(access_interface), reinterpret_cast<PPVOID>(&spAccessor));
					hr = FAILED(hr) ? hr : spAccessor->Get(val);
					return hr;
				}
				else
					return ADS_E_NOINTERFACE;
			}
	
			static HRESULT GetAt(ITcVnRandomAccessIterator* ipIterator, size_type nIndex, reference val)
			{
				if(ipIterator != nullptr)
				{
					random_access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(random_access_interface), reinterpret_cast<PPVOID>(&spAccessor));
					hr = FAILED(hr) ? hr : spAccessor->GetAt(nIndex, val);
					return hr;
				}
				else
					return ADS_E_NOINTERFACE;
			}
	
			static HRESULT Set(ITcVnForwardIterator* ipIterator, value_type ipImage)
			{
				if(ipIterator != nullptr)
				{
					access_smart_pointer spAccessor;
					HRESULT hr = ipIterator->TcQueryInterface(__uuidof(access_interface), reinterpret_cast<PPVOID>(&spAccessor));
					hr = FAILED(hr) ? hr : spAccessor->Set(ipImage);
					return hr;
				}
				else
					return ADS_E_NOINTERFACE;
			}
		};
	}
}

#ifdef LIC_TC3_Vision_Base
	#define DEFINE_TC3_Vision_Base_FUNCS \
	{ { 0xe5face20, 0x9ef9, 0x4640, { 0x9a, 0xd6, 0xa1, 0xd6, 0x34, 0xbd, 0x1c, 0x2b } }, "F_VN_AdaptiveThresholdExp", nullptr }, \
	{ { 0x352c5fa6, 0x4391, 0x494a, { 0x9f, 0xb1, 0x94, 0xa7, 0x25, 0x01, 0x82, 0x63 } }, "F_VN_AddContainers", nullptr }, \
	{ { 0x652ec677, 0xde9a, 0x4415, { 0xba, 0x14, 0x3a, 0x4c, 0xd8, 0xe3, 0xd6, 0xd7 } }, "F_VN_AddImages", nullptr }, \
	{ { 0xb57a77a9, 0x943c, 0x4d22, { 0x8d, 0x35, 0xf0, 0xeb, 0x51, 0x5b, 0x90, 0x44 } }, "F_VN_AddImagesWeightedExp", nullptr }, \
	{ { 0x49eb1906, 0x9468, 0x44d2, { 0xae, 0xa9, 0x2d, 0x13, 0x22, 0x8c, 0x2f, 0xfb } }, "F_VN_AddScalarToImage", nullptr }, \
	{ { 0xbdb5adae, 0xcf6c, 0x4a4d, { 0x97, 0x99, 0x59, 0xfb, 0xf4, 0x25, 0x5d, 0x5d } }, "F_VN_AddToContainerElements_DINT", nullptr }, \
	{ { 0x6040541b, 0xc735, 0x488d, { 0xbd, 0xd4, 0xe8, 0x09, 0x99, 0xc1, 0xe7, 0xfb } }, "F_VN_AddToContainerElements_INT", nullptr }, \
	{ { 0x023c67ea, 0xcfd8, 0x4c36, { 0xae, 0x62, 0x84, 0x33, 0x0c, 0xbc, 0xfc, 0xd1 } }, "F_VN_AddToContainerElements_LREAL", nullptr }, \
	{ { 0x8f0bc81e, 0xa419, 0x462b, { 0xbf, 0x07, 0x61, 0xe2, 0x23, 0x97, 0x21, 0x17 } }, "F_VN_AddToContainerElements_REAL", nullptr }, \
	{ { 0xc4494ddc, 0x9ec5, 0x423f, { 0xbd, 0x35, 0x06, 0x66, 0xa7, 0x89, 0x71, 0xff } }, "F_VN_AddToContainerElements_SINT", nullptr }, \
	{ { 0xdd79cda1, 0xacc1, 0x4286, { 0x90, 0xda, 0x9c, 0x34, 0xde, 0x56, 0x86, 0xd7 } }, "F_VN_AddToContainerElements_TcVnKeyPoint", nullptr }, \
	{ { 0xe7a5c5e2, 0x2f8f, 0x41db, { 0xa2, 0x73, 0x87, 0x16, 0x76, 0xa7, 0xa9, 0xa1 } }, "F_VN_AddToContainerElements_TcVnPoint2_DINT", nullptr }, \
	{ { 0xa5569dae, 0x2674, 0x4200, { 0x9c, 0x2f, 0x18, 0x2e, 0x37, 0x8d, 0x92, 0x7a } }, "F_VN_AddToContainerElements_TcVnPoint2_LREAL", nullptr }, \
	{ { 0xe6b6d1f4, 0x96a9, 0x41fd, { 0xab, 0x34, 0x08, 0x5b, 0x9b, 0x25, 0xea, 0xae } }, "F_VN_AddToContainerElements_TcVnPoint2_REAL", nullptr }, \
	{ { 0x65bb2b85, 0xf411, 0x4df0, { 0x89, 0xd3, 0xec, 0x9a, 0x33, 0xc8, 0x64, 0xa9 } }, "F_VN_AddToContainerElements_TcVnPoint3_LREAL", nullptr }, \
	{ { 0x99a6e0ea, 0xd89b, 0x4ffd, { 0xbf, 0xb5, 0x80, 0xb7, 0x52, 0xcf, 0xac, 0xe4 } }, "F_VN_AddToContainerElements_TcVnPoint3_REAL", nullptr }, \
	{ { 0xb1746616, 0xc4fa, 0x4e04, { 0xb6, 0x1f, 0x43, 0x23, 0xb1, 0x3e, 0x79, 0x40 } }, "F_VN_AddToContainerElements_TcVnRectangle_DINT", nullptr }, \
	{ { 0x8237de6f, 0x0841, 0x49af, { 0xb1, 0xf3, 0xb2, 0xc8, 0x3b, 0xa7, 0x02, 0xa7 } }, "F_VN_AddToContainerElements_TcVnRotatedRectangle", nullptr }, \
	{ { 0x1b23a528, 0x3f98, 0x4a56, { 0x9f, 0x5b, 0x4a, 0x25, 0x77, 0x8a, 0xb9, 0xf4 } }, "F_VN_AddToContainerElements_TcVnVector2_DINT", nullptr }, \
	{ { 0xbc5fdf18, 0xbb4a, 0x4433, { 0xb7, 0x90, 0x70, 0x47, 0x9d, 0x5e, 0xa2, 0x29 } }, "F_VN_AddToContainerElements_TcVnVector2_INT", nullptr }, \
	{ { 0xfe56d4fc, 0x2d03, 0x46f2, { 0xa7, 0xc3, 0xe9, 0x86, 0xbf, 0xb9, 0x45, 0x92 } }, "F_VN_AddToContainerElements_TcVnVector2_REAL", nullptr }, \
	{ { 0x5ca03438, 0x78cd, 0x48bf, { 0x8d, 0x42, 0x99, 0x40, 0xc0, 0xb4, 0xcd, 0x3e } }, "F_VN_AddToContainerElements_TcVnVector2_SINT", nullptr }, \
	{ { 0xb013cfc3, 0x950c, 0x4c52, { 0xa5, 0xef, 0x2f, 0xae, 0xdb, 0x75, 0xea, 0xd9 } }, "F_VN_AddToContainerElements_TcVnVector2_UINT", nullptr }, \
	{ { 0xffa60c85, 0xb774, 0x4eda, { 0xb8, 0xa4, 0x0c, 0x08, 0xb3, 0xce, 0x4a, 0x2a } }, "F_VN_AddToContainerElements_TcVnVector2_USINT", nullptr }, \
	{ { 0x97fa8554, 0xb6fb, 0x4dc9, { 0xbb, 0xe0, 0x05, 0x5c, 0x80, 0xf2, 0xa2, 0xda } }, "F_VN_AddToContainerElements_TcVnVector3_INT", nullptr }, \
	{ { 0xe188b6a9, 0x390d, 0x463b, { 0xae, 0x83, 0x8d, 0x39, 0xf8, 0x1c, 0xcb, 0xe4 } }, "F_VN_AddToContainerElements_TcVnVector3_REAL", nullptr }, \
	{ { 0x8d790e96, 0xa406, 0x4628, { 0x94, 0x69, 0xb4, 0xaf, 0xf1, 0x84, 0xdf, 0x7a } }, "F_VN_AddToContainerElements_TcVnVector3_SINT", nullptr }, \
	{ { 0x241cdc13, 0x812b, 0x4cca, { 0xa3, 0x46, 0xe3, 0x88, 0x3d, 0xca, 0xe9, 0x4f } }, "F_VN_AddToContainerElements_TcVnVector3_UINT", nullptr }, \
	{ { 0x3174e338, 0x458a, 0x409e, { 0xa4, 0xd2, 0x3c, 0x11, 0xfa, 0x9b, 0x83, 0x8d } }, "F_VN_AddToContainerElements_TcVnVector3_USINT", nullptr }, \
	{ { 0x31643824, 0x4507, 0x4e7d, { 0xba, 0xb7, 0x34, 0x92, 0xef, 0x1c, 0x58, 0x64 } }, "F_VN_AddToContainerElements_TcVnVector4_DINT", nullptr }, \
	{ { 0xb1a5e2f0, 0x1cc0, 0x4265, { 0xbd, 0x4d, 0x30, 0x43, 0xb3, 0x57, 0xd9, 0x3f } }, "F_VN_AddToContainerElements_TcVnVector4_INT", nullptr }, \
	{ { 0xd023e748, 0x3e20, 0x46b9, { 0x87, 0xed, 0xdc, 0x81, 0x1d, 0xfa, 0x9e, 0x07 } }, "F_VN_AddToContainerElements_TcVnVector4_LREAL", nullptr }, \
	{ { 0x9d138516, 0x64b9, 0x4d44, { 0xb0, 0x8a, 0x1a, 0x88, 0x72, 0x54, 0x05, 0x12 } }, "F_VN_AddToContainerElements_TcVnVector4_REAL", nullptr }, \
	{ { 0xfe06371f, 0xca25, 0x4c29, { 0x80, 0x07, 0x24, 0xd3, 0x06, 0x24, 0xb1, 0xb3 } }, "F_VN_AddToContainerElements_TcVnVector4_SINT", nullptr }, \
	{ { 0xb7a12900, 0xdc62, 0x4c20, { 0x8a, 0x64, 0x43, 0x70, 0x24, 0x93, 0x61, 0xd8 } }, "F_VN_AddToContainerElements_TcVnVector4_UINT", nullptr }, \
	{ { 0x917e8b35, 0x7684, 0x4592, { 0xbe, 0x6a, 0xc7, 0x57, 0x32, 0x68, 0xf6, 0x9f } }, "F_VN_AddToContainerElements_TcVnVector4_USINT", nullptr }, \
	{ { 0xb8ebd475, 0xb853, 0x4fdb, { 0x90, 0x31, 0x9e, 0x7d, 0x14, 0xe3, 0x2c, 0xcc } }, "F_VN_AddToContainerElements_UDINT", nullptr }, \
	{ { 0x4cef4976, 0x922e, 0x4ae7, { 0xa3, 0x10, 0xd1, 0x72, 0x6e, 0xe1, 0xa4, 0x10 } }, "F_VN_AddToContainerElements_UINT", nullptr }, \
	{ { 0x63996d69, 0x22d9, 0x431b, { 0x93, 0x90, 0xf6, 0x8c, 0x19, 0x78, 0x3c, 0x6d } }, "F_VN_AddToContainerElements_ULINT", nullptr }, \
	{ { 0xbdd56c57, 0x4da3, 0x4ded, { 0xb9, 0x30, 0xbd, 0x0b, 0xad, 0x4a, 0x45, 0x8a } }, "F_VN_AddToContainerElements_USINT", nullptr }, \
	{ { 0xdc9c3112, 0x5d61, 0x4110, { 0xad, 0x68, 0xd0, 0xbc, 0x37, 0x50, 0x84, 0x79 } }, "F_VN_AddVectorToImage", nullptr }, \
	{ { 0x0e8ebd39, 0x3a73, 0x45a6, { 0xb6, 0x65, 0x55, 0x98, 0x3a, 0x92, 0x32, 0xb0 } }, "F_VN_AdjustActiveContour", nullptr }, \
	{ { 0xad2ceae5, 0x1a0d, 0x4ff3, { 0xab, 0xc7, 0xdd, 0x8f, 0x27, 0x6a, 0xc5, 0x08 } }, "F_VN_AdvanceIterator", nullptr }, \
	{ { 0xd2de5bdb, 0xa3fc, 0x4338, { 0xa0, 0xcd, 0x54, 0xfa, 0xf1, 0x41, 0x6f, 0x1a } }, "F_VN_AlignRotatedImageRegionExp", nullptr }, \
	{ { 0xd7e40b40, 0x26b7, 0x40c0, { 0xaf, 0x69, 0xea, 0x4d, 0x6a, 0xb7, 0x3f, 0x8e } }, "F_VN_AppendToContainer_DINT", nullptr }, \
	{ { 0x0da594b2, 0x423a, 0x41a2, { 0xb2, 0xdf, 0xc6, 0x6c, 0xe3, 0x76, 0x6d, 0x9b } }, "F_VN_AppendToContainer_INT", nullptr }, \
	{ { 0x1a76317b, 0x5c25, 0x426d, { 0x9e, 0xe5, 0x62, 0x0a, 0x3a, 0xb4, 0xab, 0x8d } }, "F_VN_AppendToContainer_ITcVnContainer", nullptr }, \
	{ { 0x7af9db59, 0xc041, 0x40cd, { 0xb6, 0xbb, 0x17, 0x57, 0x3a, 0xa7, 0x76, 0x88 } }, "F_VN_AppendToContainer_ITcVnForwardIterator", nullptr }, \
	{ { 0x8b4d0f03, 0x34a0, 0x46bd, { 0x83, 0x78, 0x60, 0x44, 0x1c, 0x5e, 0x46, 0xe7 } }, "F_VN_AppendToContainer_ITcVnImage", nullptr }, \
	{ { 0x20291568, 0x85aa, 0x4c18, { 0x9a, 0xe8, 0x6f, 0x74, 0x7a, 0x26, 0x22, 0xb4 } }, "F_VN_AppendToContainer_LREAL", nullptr }, \
	{ { 0x392ccd37, 0xce6d, 0x4aec, { 0x83, 0x6c, 0xaa, 0xe4, 0x19, 0x68, 0xbd, 0x1e } }, "F_VN_AppendToContainer_REAL", nullptr }, \
	{ { 0xbf095c3d, 0x7ce6, 0x4646, { 0x87, 0x8b, 0xc7, 0x3d, 0xa7, 0xd3, 0x08, 0x6c } }, "F_VN_AppendToContainer_SINT", nullptr }, \
	{ { 0xa50f6842, 0x38b1, 0x41c9, { 0x8a, 0xd8, 0x45, 0x55, 0xfb, 0xf6, 0x50, 0x92 } }, "F_VN_AppendToContainer_TcVnDMatch", nullptr }, \
	{ { 0x4c976ba6, 0x168c, 0x44ea, { 0x9f, 0x4b, 0xff, 0x13, 0x9a, 0x4b, 0xe4, 0x7e } }, "F_VN_AppendToContainer_TcVnKeyPoint", nullptr }, \
	{ { 0x73bdd13e, 0x824f, 0x4d7c, { 0xad, 0x84, 0x0a, 0x1a, 0xb5, 0x6d, 0x2f, 0x74 } }, "F_VN_AppendToContainer_TcVnPoint2_DINT", nullptr }, \
	{ { 0x877f3318, 0xf9e1, 0x44aa, { 0xb5, 0x1f, 0xdc, 0xa1, 0xc0, 0x19, 0x04, 0xbf } }, "F_VN_AppendToContainer_TcVnPoint2_LREAL", nullptr }, \
	{ { 0x3eab53ba, 0x8578, 0x40e4, { 0x9e, 0x69, 0x7a, 0x75, 0xec, 0x2a, 0x04, 0xf5 } }, "F_VN_AppendToContainer_TcVnPoint2_REAL", nullptr }, \
	{ { 0xd20a52a0, 0x7519, 0x43db, { 0xbf, 0x91, 0x73, 0xd7, 0xef, 0x19, 0xad, 0xdb } }, "F_VN_AppendToContainer_TcVnPoint3_LREAL", nullptr }, \
	{ { 0xced2c094, 0x3528, 0x4465, { 0xa3, 0x41, 0x34, 0x96, 0x94, 0x44, 0x2e, 0xec } }, "F_VN_AppendToContainer_TcVnPoint3_REAL", nullptr }, \
	{ { 0xd6afe77a, 0x1aee, 0x4627, { 0xb5, 0xc1, 0x29, 0x88, 0xbc, 0xbf, 0x52, 0x4f } }, "F_VN_AppendToContainer_TcVnRectangle_DINT", nullptr }, \
	{ { 0xe66c181a, 0xb2eb, 0x4a9f, { 0xa6, 0xf8, 0x30, 0xf3, 0x0f, 0x1d, 0xda, 0x23 } }, "F_VN_AppendToContainer_TcVnRotatedRectangle", nullptr }, \
	{ { 0x53b4b1b4, 0x9cd4, 0x47a5, { 0x80, 0x02, 0xa8, 0x10, 0xc8, 0x6c, 0xa4, 0x64 } }, "F_VN_AppendToContainer_TcVnVector2_DINT", nullptr }, \
	{ { 0x111effb0, 0x2ca6, 0x4951, { 0x98, 0xfa, 0x02, 0x3d, 0xd5, 0x43, 0x99, 0x02 } }, "F_VN_AppendToContainer_TcVnVector2_INT", nullptr }, \
	{ { 0xd8aee8ea, 0xef72, 0x4637, { 0x9e, 0x01, 0xb6, 0x55, 0x24, 0x7e, 0x67, 0x68 } }, "F_VN_AppendToContainer_TcVnVector2_REAL", nullptr }, \
	{ { 0xa044b7ba, 0xa832, 0x4da2, { 0xbf, 0x68, 0xe8, 0x2f, 0x0f, 0x83, 0xb4, 0xe5 } }, "F_VN_AppendToContainer_TcVnVector2_SINT", nullptr }, \
	{ { 0x77cd7cd7, 0x0e3e, 0x4e6f, { 0x8d, 0x9c, 0x4b, 0x51, 0x92, 0x34, 0x3c, 0xe2 } }, "F_VN_AppendToContainer_TcVnVector2_UINT", nullptr }, \
	{ { 0xddd9a89c, 0x90d1, 0x4821, { 0x8e, 0xcf, 0x68, 0xb1, 0x94, 0x80, 0xca, 0xfb } }, "F_VN_AppendToContainer_TcVnVector2_USINT", nullptr }, \
	{ { 0x9459b667, 0xf85a, 0x4042, { 0x8b, 0xc3, 0x74, 0x04, 0x96, 0xff, 0x05, 0xb2 } }, "F_VN_AppendToContainer_TcVnVector3_INT", nullptr }, \
	{ { 0xc0cb01aa, 0x632e, 0x4019, { 0xae, 0x79, 0x94, 0x9d, 0x9e, 0x18, 0xfd, 0xee } }, "F_VN_AppendToContainer_TcVnVector3_REAL", nullptr }, \
	{ { 0xd2b3ef60, 0x1435, 0x422c, { 0x87, 0x39, 0xcf, 0xb5, 0xc2, 0x1a, 0xe3, 0x5f } }, "F_VN_AppendToContainer_TcVnVector3_SINT", nullptr }, \
	{ { 0xe405b14b, 0xdf08, 0x4f41, { 0xb2, 0x93, 0x8a, 0x1d, 0xc2, 0xb8, 0xb9, 0x70 } }, "F_VN_AppendToContainer_TcVnVector3_UINT", nullptr }, \
	{ { 0x9965099b, 0x3219, 0x409c, { 0x9e, 0xc4, 0xc9, 0xdb, 0x39, 0x72, 0xcc, 0x9c } }, "F_VN_AppendToContainer_TcVnVector3_USINT", nullptr }, \
	{ { 0x99b41c3a, 0x15bd, 0x4eaf, { 0x85, 0xa9, 0x18, 0xf4, 0x28, 0x3c, 0x12, 0x01 } }, "F_VN_AppendToContainer_TcVnVector4_DINT", nullptr }, \
	{ { 0x92a9e160, 0x408d, 0x4b6c, { 0x87, 0x0f, 0xc4, 0x9a, 0xb1, 0x47, 0x5e, 0x8f } }, "F_VN_AppendToContainer_TcVnVector4_INT", nullptr }, \
	{ { 0xf996c227, 0xe060, 0x48a7, { 0x89, 0xb7, 0xfd, 0xfe, 0xc3, 0x99, 0x45, 0xc3 } }, "F_VN_AppendToContainer_TcVnVector4_LREAL", nullptr }, \
	{ { 0x5249b95b, 0xbe2b, 0x41ac, { 0x98, 0xf9, 0xdb, 0x6f, 0xf8, 0x64, 0xfb, 0x05 } }, "F_VN_AppendToContainer_TcVnVector4_REAL", nullptr }, \
	{ { 0x1e42d48f, 0xe9e5, 0x4742, { 0x8d, 0xf5, 0x8c, 0xde, 0x10, 0x9d, 0x34, 0xdc } }, "F_VN_AppendToContainer_TcVnVector4_SINT", nullptr }, \
	{ { 0x123532e4, 0xe8a7, 0x40b0, { 0xb4, 0x8d, 0x99, 0x11, 0x04, 0x98, 0xa1, 0x4d } }, "F_VN_AppendToContainer_TcVnVector4_UINT", nullptr }, \
	{ { 0xfe0cfe89, 0x0cc9, 0x4df3, { 0xa3, 0x0b, 0x76, 0xbd, 0x71, 0x48, 0x3b, 0xb3 } }, "F_VN_AppendToContainer_TcVnVector4_USINT", nullptr }, \
	{ { 0x15fbea4e, 0xf53b, 0x4279, { 0xb9, 0x81, 0x16, 0xda, 0xa6, 0x20, 0x87, 0xbf } }, "F_VN_AppendToContainer_UDINT", nullptr }, \
	{ { 0xafb0a8a6, 0xbe5c, 0x459c, { 0x8f, 0x23, 0x4e, 0x86, 0xa6, 0x17, 0xb6, 0xd1 } }, "F_VN_AppendToContainer_UINT", nullptr }, \
	{ { 0x23adb675, 0x922d, 0x46d7, { 0x8c, 0x0c, 0x1b, 0x0f, 0xe6, 0x61, 0x84, 0xe2 } }, "F_VN_AppendToContainer_ULINT", nullptr }, \
	{ { 0x9d2a97e4, 0x77a8, 0x41cf, { 0x93, 0x64, 0xc4, 0x8c, 0xe6, 0xfa, 0x33, 0x97 } }, "F_VN_AppendToContainer_USINT", nullptr }, \
	{ { 0x936b27f6, 0xdfd8, 0x4d75, { 0x91, 0xbd, 0x0b, 0x80, 0x5e, 0xf8, 0xc2, 0x51 } }, "F_VN_ApplyColorMap", nullptr }, \
	{ { 0x91d9aa80, 0x4cc0, 0x495e, { 0x9e, 0x6d, 0x66, 0xc0, 0xc4, 0x07, 0xb3, 0x4f } }, "F_VN_ApplyLut", nullptr }, \
	{ { 0x0865128b, 0x0121, 0x4cf9, { 0xba, 0x7b, 0x31, 0xbb, 0xaa, 0x7b, 0xc1, 0x71 } }, "F_VN_ApplyRotationToAffineTransformationExp", nullptr }, \
	{ { 0x0af9ce16, 0xe2dd, 0x4025, { 0x84, 0x8c, 0x14, 0x93, 0xb8, 0xce, 0x73, 0x87 } }, "F_VN_ApplyScalingToAffineTransformationExp", nullptr }, \
	{ { 0xb56a00f4, 0x7d80, 0x4e29, { 0xb5, 0xf2, 0xbc, 0x87, 0xec, 0x5d, 0xee, 0x33 } }, "F_VN_ApplyTranslationToAffineTransformationExp", nullptr }, \
	{ { 0x04fd3614, 0xad96, 0x4071, { 0xad, 0xb7, 0xb4, 0xb7, 0x79, 0xe1, 0xac, 0xae } }, "F_VN_ApplyYAxisInversionToAffineTransformationExp", nullptr }, \
	{ { 0x6adf4ccc, 0x8c68, 0x4115, { 0xaa, 0x04, 0xe9, 0xb9, 0x7f, 0x1b, 0xd6, 0x4c } }, "F_VN_ApproximatePolygon", nullptr }, \
	{ { 0x11c9551c, 0xd192, 0x4b24, { 0x81, 0xd8, 0x38, 0xf0, 0xbc, 0x1a, 0x35, 0x50 } }, "F_VN_BilateralFilterExp", nullptr }, \
	{ { 0xea91466c, 0x6531, 0x4994, { 0x8e, 0x14, 0x42, 0x06, 0x79, 0x1f, 0xa3, 0x5f } }, "F_VN_BitwiseAndContainers", nullptr }, \
	{ { 0xbf37824f, 0x88ae, 0x4fa2, { 0xb1, 0x8e, 0x75, 0xf9, 0x38, 0xa3, 0x7f, 0x38 } }, "F_VN_BitwiseAndImages", nullptr }, \
	{ { 0x29cd387f, 0xb2ba, 0x4caa, { 0x84, 0x42, 0x70, 0x2c, 0x48, 0x13, 0x88, 0xdf } }, "F_VN_BitwiseAndImagesExp", nullptr }, \
	{ { 0x39bb9513, 0xa3c3, 0x40ec, { 0xa2, 0x21, 0x70, 0xf6, 0xab, 0x1d, 0x46, 0x90 } }, "F_VN_BitwiseAndScalarWithImage", nullptr }, \
	{ { 0x3d77de56, 0x1ef9, 0x49c7, { 0x9d, 0xc5, 0x32, 0xef, 0x05, 0x49, 0x6e, 0x69 } }, "F_VN_BitwiseAndVectorWithImage", nullptr }, \
	{ { 0xf6f05d88, 0xac34, 0x41a7, { 0x89, 0xc3, 0x96, 0x10, 0xfc, 0xd6, 0x2e, 0x7e } }, "F_VN_BitwiseNotContainer", nullptr }, \
	{ { 0x0581b4d8, 0x25a3, 0x42d2, { 0xb4, 0x0b, 0xb4, 0x10, 0x7c, 0x95, 0x90, 0x8d } }, "F_VN_BitwiseNotImage", nullptr }, \
	{ { 0x3bfe5f00, 0x5b9f, 0x4d40, { 0x81, 0x84, 0x2f, 0x33, 0x23, 0x58, 0x39, 0x1e } }, "F_VN_BitwiseNotImageExp", nullptr }, \
	{ { 0xf197c750, 0x0798, 0x4120, { 0x99, 0xa9, 0xa2, 0xd8, 0x7c, 0x2a, 0x2b, 0x8d } }, "F_VN_BitwiseOrContainers", nullptr }, \
	{ { 0xc82c8d6b, 0xc5b6, 0x40b6, { 0x90, 0xb0, 0xca, 0xf9, 0xaf, 0x06, 0x9c, 0x49 } }, "F_VN_BitwiseOrImages", nullptr }, \
	{ { 0x64626384, 0x4345, 0x4c0f, { 0x9b, 0x96, 0x3d, 0x56, 0x92, 0xbe, 0xcc, 0x44 } }, "F_VN_BitwiseOrImagesExp", nullptr }, \
	{ { 0x0ea9015c, 0x4a52, 0x43a1, { 0x87, 0xaa, 0x7e, 0xf8, 0x88, 0xa5, 0x4b, 0xc3 } }, "F_VN_BitwiseOrScalarWithImage", nullptr }, \
	{ { 0x49718455, 0x90c8, 0x4efd, { 0xa5, 0x54, 0xe2, 0x61, 0x78, 0x8b, 0xce, 0x66 } }, "F_VN_BitwiseOrVectorWithImage", nullptr }, \
	{ { 0xb1ee3931, 0x694d, 0x44ee, { 0x83, 0x14, 0x83, 0x95, 0xe1, 0x59, 0xe9, 0x55 } }, "F_VN_BitwiseXorContainers", nullptr }, \
	{ { 0x09948b21, 0x37b4, 0x40c2, { 0x9a, 0xb3, 0xee, 0x83, 0x71, 0x55, 0xb7, 0x9c } }, "F_VN_BitwiseXorImages", nullptr }, \
	{ { 0x5ad525db, 0x76bd, 0x46d6, { 0xaf, 0x50, 0x84, 0xb6, 0x1f, 0x9f, 0x09, 0x4d } }, "F_VN_BitwiseXorImagesExp", nullptr }, \
	{ { 0x3050ccb5, 0xac20, 0x47b1, { 0xbd, 0x5a, 0x4f, 0xc4, 0x5e, 0x92, 0x5f, 0x22 } }, "F_VN_BitwiseXorScalarWithImage", nullptr }, \
	{ { 0xb626715f, 0x2127, 0x472d, { 0xb9, 0x10, 0x49, 0x0b, 0xea, 0x90, 0xe3, 0x05 } }, "F_VN_BitwiseXorVectorWithImage", nullptr }, \
	{ { 0xd8de6749, 0xa017, 0x47b9, { 0x84, 0x3f, 0xcd, 0x8f, 0x16, 0x8d, 0xc3, 0x15 } }, "F_VN_BlendImages", nullptr }, \
	{ { 0x729f6ca6, 0xecbe, 0x417a, { 0x98, 0xee, 0x7c, 0x33, 0x99, 0x5e, 0x42, 0x5b } }, "F_VN_BoxFilterExp", nullptr }, \
	{ { 0x0c108e30, 0x7911, 0x4ded, { 0xa4, 0x87, 0xa6, 0x56, 0x77, 0x32, 0x0f, 0x5d } }, "F_VN_BrightBorderObjects", nullptr }, \
	{ { 0x84f28f9e, 0xf118, 0x4a8a, { 0xaa, 0xfe, 0x20, 0xdc, 0x64, 0xc3, 0x7e, 0xf8 } }, "F_VN_CalibrateCameraPlanarExp", nullptr }, \
	{ { 0x173bebfd, 0xc26b, 0x4784, { 0x9d, 0x2f, 0x90, 0xed, 0x09, 0x64, 0xfd, 0x8c } }, "F_VN_CannyEdgeDetectionExp", nullptr }, \
	{ { 0x5ee1a669, 0xdaa3, 0x48eb, { 0x8e, 0xc1, 0x04, 0xf6, 0xc1, 0xbf, 0x7e, 0x47 } }, "F_VN_CheckColorRange", nullptr }, \
	{ { 0xd59a7572, 0xe555, 0x477c, { 0xa7, 0xc3, 0x48, 0xff, 0xd2, 0x1e, 0x30, 0x88 } }, "F_VN_CheckFunctionInitialization", nullptr }, \
	{ { 0xf6ce93d5, 0x775f, 0x447a, { 0x9e, 0xe3, 0xf6, 0xc4, 0x67, 0x87, 0xd1, 0xca } }, "F_VN_CheckIfEmpty", nullptr }, \
	{ { 0x3126c368, 0xf226, 0x44c9, { 0x85, 0x6b, 0x77, 0xb7, 0x8a, 0x63, 0x4d, 0x89 } }, "F_VN_CheckIfIteratorIsAtEnd", nullptr }, \
	{ { 0xafda4c97, 0x8b1d, 0x4f7e, { 0xb6, 0x19, 0x05, 0x52, 0xff, 0x4f, 0xdc, 0xfe } }, "F_VN_CheckIfPointIsInsideContour", nullptr }, \
	{ { 0x19047f12, 0xfd97, 0x409e, { 0x95, 0x19, 0x33, 0x93, 0x68, 0x46, 0xb9, 0xaf } }, "F_VN_ClaheExp", nullptr }, \
	{ { 0x4d9aef7e, 0x179b, 0x42f8, { 0xb4, 0x39, 0x7c, 0x1d, 0x9e, 0x07, 0x06, 0xf8 } }, "F_VN_ClipLineToBoundary", nullptr }, \
	{ { 0xf6d27d8e, 0x153d, 0x457b, { 0xae, 0xac, 0xce, 0x99, 0xe0, 0x35, 0x5f, 0x0e } }, "F_VN_ClipLineToBoundary_ITcVnImage", nullptr }, \
	{ { 0x9512c0f7, 0x894e, 0x4408, { 0xba, 0x59, 0xff, 0xf1, 0x54, 0x72, 0x2f, 0x6d } }, "F_VN_ClipLineToBoundary_TcVnRectangle_DINT", nullptr }, \
	{ { 0xdcc26dd0, 0x8a7a, 0x4076, { 0x98, 0xe3, 0x3d, 0x1e, 0x27, 0x4f, 0x4b, 0x69 } }, "F_VN_CombineImageChannels", nullptr }, \
	{ { 0xc1353c38, 0xb461, 0x4e44, { 0xb4, 0xe2, 0xdd, 0xe5, 0x45, 0xb4, 0xad, 0xaf } }, "F_VN_ConnectedComponentsExp", nullptr }, \
	{ { 0xbffaa6d3, 0xff3b, 0x4af9, { 0x97, 0xca, 0xbc, 0x8a, 0x5b, 0xc9, 0x34, 0xa3 } }, "F_VN_ConnectedComponentsWithStatsExp", nullptr }, \
	{ { 0x3b03384c, 0x6ef1, 0x4315, { 0x80, 0x4a, 0xb7, 0x8f, 0xa2, 0xe9, 0xc4, 0x09 } }, "F_VN_ContainerAverage", nullptr }, \
	{ { 0x341d8813, 0xbe68, 0x41e2, { 0x89, 0xf0, 0x33, 0xb9, 0xaa, 0x92, 0x6c, 0x4b } }, "F_VN_ContainerAverageElementwise2", nullptr }, \
	{ { 0xd175533d, 0xb311, 0x4bb3, { 0xac, 0xd9, 0x62, 0x42, 0x3e, 0x0a, 0xe8, 0x29 } }, "F_VN_ContainerAverageElementwise3", nullptr }, \
	{ { 0x4f27fc07, 0x01a0, 0x4247, { 0x85, 0x44, 0xcb, 0xe3, 0x8c, 0x3c, 0x99, 0x4b } }, "F_VN_ContainerAverageElementwise4", nullptr }, \
	{ { 0x69e65406, 0xfe6b, 0x4f6b, { 0x8e, 0xbe, 0x16, 0x3d, 0x9f, 0xde, 0xba, 0xa9 } }, "F_VN_ContainerAverageVariance", nullptr }, \
	{ { 0x0c53d64d, 0x2585, 0x449e, { 0x83, 0xe2, 0x6b, 0x6c, 0x40, 0x2d, 0xb3, 0x70 } }, "F_VN_ContainerAverageVarianceElementwise2", nullptr }, \
	{ { 0x6b0858e2, 0x95f1, 0x4c73, { 0x96, 0x7e, 0xa6, 0xea, 0x10, 0xfd, 0x5c, 0x4c } }, "F_VN_ContainerAverageVarianceElementwise3", nullptr }, \
	{ { 0x92951b7e, 0x2794, 0x42aa, { 0xbf, 0xc6, 0xf7, 0x9b, 0x25, 0x5d, 0x42, 0x00 } }, "F_VN_ContainerAverageVarianceElementwise4", nullptr }, \
	{ { 0x7e10165e, 0x0e90, 0x4670, { 0x9c, 0xdc, 0x5f, 0xce, 0x2e, 0x0d, 0x63, 0x60 } }, "F_VN_ContourArea", nullptr }, \
	{ { 0xc2744c0f, 0xaac5, 0x428f, { 0x8b, 0x95, 0xa9, 0x2d, 0xb3, 0xcd, 0x24, 0x5d } }, "F_VN_ContourCenterOfMass", nullptr }, \
	{ { 0x4846dfc5, 0x0653, 0x422a, { 0xac, 0x2a, 0x70, 0x8b, 0x44, 0x44, 0xbe, 0xb5 } }, "F_VN_ContourCircularityExp", nullptr }, \
	{ { 0xd6f16049, 0x88cb, 0x4dc6, { 0xa3, 0xeb, 0xac, 0x1a, 0xdf, 0xa0, 0xc6, 0x30 } }, "F_VN_ContourConvexity", nullptr }, \
	{ { 0x592d67e7, 0x5acc, 0x4304, { 0xa9, 0x61, 0x03, 0x89, 0x2d, 0x5c, 0x83, 0xb1 } }, "F_VN_ContourEccentricity", nullptr }, \
	{ { 0xf42af444, 0x86bc, 0x45e7, { 0xaf, 0x7a, 0x34, 0x02, 0xd0, 0x99, 0x37, 0x4d } }, "F_VN_ContourElongation", nullptr }, \
	{ { 0x2989752b, 0xbcb4, 0x4c43, { 0xa4, 0x50, 0x18, 0xea, 0x21, 0xf2, 0x91, 0x9a } }, "F_VN_ContourExtremePoint", nullptr }, \
	{ { 0x31320fe6, 0xb020, 0x43db, { 0xbe, 0xf5, 0x44, 0x9e, 0xca, 0x01, 0x6a, 0x72 } }, "F_VN_ContourInertiaRatio", nullptr }, \
	{ { 0x5c3683fc, 0x8621, 0x4ba0, { 0xa8, 0x74, 0x04, 0xe9, 0xe2, 0x56, 0x7d, 0xbd } }, "F_VN_ContourMoments", nullptr }, \
	{ { 0xfc115bcd, 0x2c53, 0x4b50, { 0xb1, 0xc4, 0xbf, 0x2d, 0xa8, 0x07, 0x6c, 0x75 } }, "F_VN_ContourOrientationExp", nullptr }, \
	{ { 0x6cad8ba9, 0x0ea2, 0x4f6d, { 0xac, 0x93, 0xc5, 0x90, 0x89, 0xb4, 0xda, 0xda } }, "F_VN_ContourPerimeter", nullptr }, \
	{ { 0xafdeba4d, 0x9cf5, 0x46d5, { 0xb2, 0xba, 0x4c, 0x17, 0x75, 0x96, 0x52, 0xad } }, "F_VN_ContourRoundness", nullptr }, \
	{ { 0x1c8c77e3, 0xa81f, 0x4184, { 0x96, 0x75, 0x25, 0x9a, 0x81, 0x56, 0x8f, 0x35 } }, "F_VN_ConvertCartesianToPolarAngleImageExp", nullptr }, \
	{ { 0x50f0bb26, 0x5f0a, 0x421d, { 0xa9, 0x38, 0x3c, 0x9f, 0xda, 0xc3, 0x3b, 0x91 } }, "F_VN_ConvertCartesianToPolarAnglesExp", nullptr }, \
	{ { 0xc62f6db7, 0x5557, 0x42f6, { 0x82, 0x83, 0x93, 0xcb, 0x82, 0xc6, 0xad, 0x63 } }, "F_VN_ConvertCartesianToPolarImagesExp", nullptr }, \
	{ { 0x0864d7b5, 0x3a13, 0x421c, { 0x95, 0x9c, 0x52, 0x02, 0x5e, 0x9b, 0xa2, 0xd4 } }, "F_VN_ConvertCartesianToPolarMagnitudeImage", nullptr }, \
	{ { 0x16dc5467, 0xcc9e, 0x4ffb, { 0x9b, 0x73, 0x28, 0x2f, 0xed, 0x29, 0x37, 0xca } }, "F_VN_ConvertCartesianToPolarMagnitudes", nullptr }, \
	{ { 0x7a35461f, 0xd7c3, 0x49a5, { 0x82, 0xac, 0x88, 0xe3, 0x85, 0xb1, 0xd2, 0x4f } }, "F_VN_ConvertCartesianToPolarPointsExp", nullptr }, \
	{ { 0xf5823f93, 0xd662, 0x4981, { 0x9d, 0xe8, 0xce, 0xa4, 0xec, 0xcb, 0x54, 0x55 } }, "F_VN_ConvertColorSpace", nullptr }, \
	{ { 0x0045fef2, 0x1ae4, 0x4323, { 0xaf, 0xec, 0x4a, 0xb3, 0x17, 0x75, 0x3c, 0x12 } }, "F_VN_ConvertContainerType", nullptr }, \
	{ { 0xb0131bfa, 0xecd8, 0x439a, { 0xa5, 0x34, 0xca, 0x84, 0x3c, 0x97, 0x18, 0xe4 } }, "F_VN_ConvertDataLayout", nullptr }, \
	{ { 0x8d8f0919, 0x045f, 0x453b, { 0xaa, 0x43, 0x7d, 0x67, 0xcd, 0xa2, 0xe7, 0x56 } }, "F_VN_ConvertElementTypeExp", nullptr }, \
	{ { 0x3cb40780, 0x8b3b, 0x448d, { 0xab, 0xdc, 0x33, 0x61, 0xc4, 0x84, 0x75, 0x62 } }, "F_VN_ConvertITcUnknownToITcVnBitmapExport", nullptr }, \
	{ { 0x01885e71, 0xec4f, 0x4206, { 0x90, 0xc3, 0x71, 0x55, 0x52, 0x30, 0x7b, 0x03 } }, "F_VN_ConvertITcUnknownToITcVnContainer", nullptr }, \
	{ { 0x0e70115e, 0xc2c5, 0x4a5c, { 0xbf, 0x69, 0x44, 0xac, 0xeb, 0x9d, 0x68, 0x66 } }, "F_VN_ConvertITcUnknownToITcVnImage", nullptr }, \
	{ { 0x12fec824, 0x8f4c, 0x4ced, { 0xae, 0xc4, 0xc6, 0xc8, 0x86, 0x12, 0x50, 0x73 } }, "F_VN_ConvertITcUnknownToITcVnMlModel", nullptr }, \
	{ { 0x8b3ec03d, 0xc6a6, 0x4c8e, { 0xbb, 0x25, 0x39, 0x65, 0xbe, 0xf7, 0xc0, 0x4f } }, "F_VN_ConvertPolarToCartesianImagesExp", nullptr }, \
	{ { 0x00044753, 0x7533, 0x4cc1, { 0xb4, 0xec, 0x43, 0xb8, 0x2b, 0xe9, 0x96, 0x9b } }, "F_VN_ConvertPolarToCartesianPointsExp", nullptr }, \
	{ { 0xb8c9a306, 0x77d4, 0x417e, { 0x97, 0x9c, 0x4d, 0x74, 0x86, 0x48, 0x92, 0x50 } }, "F_VN_ConvexHullPointsExp", nullptr }, \
	{ { 0x726be5b6, 0x9c22, 0x403e, { 0xa3, 0xc8, 0x02, 0xa8, 0xd6, 0x78, 0x98, 0x33 } }, "F_VN_ConvexityDefects", nullptr }, \
	{ { 0xdb47a05d, 0xdc4a, 0x40e1, { 0xb1, 0x78, 0xfa, 0x2a, 0x8e, 0xc9, 0x25, 0xf9 } }, "F_VN_CopyContainer", nullptr }, \
	{ { 0x2ea24e80, 0xf0e8, 0x4006, { 0x80, 0xcc, 0x7a, 0xb2, 0xc8, 0xb9, 0x7a, 0x87 } }, "F_VN_CopyContainerElementsConditional_ITcVnContainer", nullptr }, \
	{ { 0x42b81591, 0x24c8, 0x466b, { 0x87, 0xc5, 0x99, 0xb8, 0xc4, 0xdb, 0x0d, 0xaf } }, "F_VN_CopyContainerElementsConditional_ITcVnForwardIterator", nullptr }, \
	{ { 0x23d77a62, 0x328a, 0x40b4, { 0x80, 0x92, 0x1a, 0xd2, 0x71, 0x7b, 0xf0, 0x95 } }, "F_VN_CopyImage", nullptr }, \
	{ { 0x1ae71b39, 0x2d9f, 0x4268, { 0xb3, 0x5a, 0xfd, 0x57, 0x3e, 0xa5, 0x45, 0x3a } }, "F_VN_CopyImageRegion", nullptr }, \
	{ { 0x8dc816bd, 0x7134, 0x40d9, { 0x99, 0x79, 0xee, 0xe1, 0xc1, 0x9f, 0x25, 0x40 } }, "F_VN_CopyImageRegionToRegion", nullptr }, \
	{ { 0x895d324e, 0x4087, 0x43ea, { 0x85, 0xbc, 0x56, 0x72, 0xc3, 0xff, 0x3c, 0x2c } }, "F_VN_CopyIntoDisplayableImage", nullptr }, \
	{ { 0xe7149b76, 0x6569, 0x4603, { 0xa7, 0xf2, 0xd3, 0xf4, 0x09, 0x30, 0xf8, 0x1d } }, "F_VN_CountNonZeroPixels", nullptr }, \
	{ { 0x3ae0f8a9, 0xfacd, 0x4188, { 0xa7, 0x9b, 0x4d, 0xd1, 0xa2, 0xe1, 0xf7, 0xb2 } }, "F_VN_CreateAssociatedImage", nullptr }, \
	{ { 0x35fa98bd, 0xc57a, 0x4e19, { 0x89, 0xbb, 0x46, 0xf0, 0x11, 0xf6, 0xcc, 0x98 } }, "F_VN_CreateBandpassButterworthFilter", nullptr }, \
	{ { 0x3ab50c70, 0xf789, 0x4d67, { 0xbb, 0x69, 0x50, 0x99, 0xcf, 0xa4, 0x0b, 0x67 } }, "F_VN_CreateBandpassGaussianFilter", nullptr }, \
	{ { 0xd2760ff5, 0x6f01, 0x4ffe, { 0xa5, 0x73, 0xdb, 0xfe, 0xab, 0xb8, 0xfd, 0xd9 } }, "F_VN_CreateBandrejectButterworthFilter", nullptr }, \
	{ { 0xbc880db2, 0x91bc, 0x4dce, { 0xb5, 0x11, 0x9e, 0x7b, 0x03, 0x96, 0x9b, 0x1a } }, "F_VN_CreateBandrejectGaussianFilter", nullptr }, \
	{ { 0x60377a8b, 0x48fd, 0x448c, { 0x9d, 0x75, 0xf1, 0x2f, 0xe0, 0xe1, 0x22, 0xda } }, "F_VN_CreateContainer", nullptr }, \
	{ { 0xabbf3e47, 0x8241, 0x487d, { 0xb4, 0xa5, 0x08, 0x7b, 0x34, 0x52, 0x28, 0x1b } }, "F_VN_CreateContainerFromArray", nullptr }, \
	{ { 0xfded6d1e, 0x7b44, 0x41f9, { 0x98, 0xbc, 0xaa, 0xb7, 0xf6, 0xa5, 0x98, 0xc1 } }, "F_VN_CreateEmptyImage", nullptr }, \
	{ { 0xb7ba5988, 0x9105, 0x439a, { 0xa2, 0x8d, 0x36, 0x25, 0x5f, 0x35, 0xa8, 0x71 } }, "F_VN_CreateHighpassButterworthFilter", nullptr }, \
	{ { 0x003ec7a9, 0x1b26, 0x4f97, { 0x83, 0xdd, 0x12, 0x1c, 0x25, 0x17, 0x39, 0x80 } }, "F_VN_CreateHighpassGaussianFilter", nullptr }, \
	{ { 0xf7476ad4, 0xb914, 0x4919, { 0xae, 0xc3, 0x22, 0xab, 0x15, 0xdd, 0x90, 0xba } }, "F_VN_CreateImage", nullptr }, \
	{ { 0xd2a145f1, 0x59b2, 0x4016, { 0xaf, 0x51, 0x62, 0xc3, 0x61, 0x60, 0x15, 0x73 } }, "F_VN_CreateImageAndSetPixels", nullptr }, \
	{ { 0x1bfe9737, 0xc722, 0x4c7c, { 0xae, 0xf4, 0xee, 0xd1, 0xdb, 0x3a, 0xbc, 0xdc } }, "F_VN_CreateImageFromArray", nullptr }, \
	{ { 0xa6bb94c1, 0xcb25, 0x48e1, { 0xae, 0xf7, 0xe9, 0x21, 0x1a, 0x71, 0x83, 0x5f } }, "F_VN_CreateLowpassButterworthFilter", nullptr }, \
	{ { 0x6dbd5efd, 0xf5b0, 0x46da, { 0x8d, 0x9f, 0x0d, 0xfd, 0x63, 0x60, 0x91, 0x41 } }, "F_VN_CreateLowpassGaussianFilter", nullptr }, \
	{ { 0xffe947f3, 0x53c6, 0x4a16, { 0xa3, 0x21, 0x64, 0x05, 0x61, 0x64, 0x69, 0xe8 } }, "F_VN_CreateNDimensionalImage", nullptr }, \
	{ { 0xc5d0f55d, 0x2002, 0x43bf, { 0xb6, 0xea, 0xdb, 0x88, 0x82, 0x23, 0xa6, 0xa1 } }, "F_VN_CreateNDimensionalImageAndSetPixels", nullptr }, \
	{ { 0xe5fee24e, 0xaa8b, 0x47a4, { 0xa2, 0x7a, 0x3e, 0xa2, 0x33, 0xf2, 0xfb, 0xe2 } }, "F_VN_CreateNDimensionalImageFromArray", nullptr }, \
	{ { 0x2eca5bfc, 0x5250, 0x4621, { 0x9c, 0x58, 0x48, 0x0a, 0x30, 0xe1, 0x3d, 0xc9 } }, "F_VN_CreateStructuringElement", nullptr }, \
	{ { 0x2da091be, 0xa189, 0x4e4d, { 0x9d, 0xf6, 0x17, 0x2f, 0x34, 0xba, 0x13, 0x90 } }, "F_VN_CustomElementWiseContainerOperation_ITcVnContainer", nullptr }, \
	{ { 0x050aa749, 0xc07d, 0x4e49, { 0x8a, 0x03, 0x37, 0x69, 0xc8, 0xec, 0xa7, 0x29 } }, "F_VN_CustomElementWiseContainerOperation_ITcVnForwardIterator", nullptr }, \
	{ { 0xe29040f1, 0x0bdb, 0x441f, { 0x88, 0xfc, 0x4e, 0x77, 0xba, 0x03, 0x7f, 0x04 } }, "F_VN_CustomFilterExp", nullptr }, \
	{ { 0xd9acea59, 0xa01b, 0x4d16, { 0xa8, 0xc9, 0xbd, 0x2d, 0xb9, 0xb3, 0x11, 0x13 } }, "F_VN_DarkBorderObjects", nullptr }, \
	{ { 0x0bfdb8ab, 0x6ada, 0x4ecb, { 0x93, 0xde, 0xd1, 0x40, 0x76, 0xe7, 0x8d, 0x78 } }, "F_VN_DecomposeAffineTransformationExp", nullptr }, \
	{ { 0x75d840f7, 0x04e7, 0x4234, { 0x91, 0x4d, 0x97, 0x43, 0x12, 0xb8, 0xc6, 0x64 } }, "F_VN_DecomposeHomographyExp", nullptr }, \
	{ { 0x28eb60ce, 0xac7a, 0x429b, { 0x97, 0x79, 0x36, 0xa5, 0xa3, 0xf9, 0xe8, 0x92 } }, "F_VN_DeinitializeFunction", nullptr }, \
	{ { 0x1a37aaf7, 0x866b, 0x45bf, { 0xa1, 0xd0, 0x53, 0x84, 0xc9, 0x76, 0x29, 0x73 } }, "F_VN_DetectBlobsExp", nullptr }, \
	{ { 0x0d59e1ff, 0x7726, 0x44e3, { 0x8b, 0xf5, 0xa4, 0x95, 0x5f, 0xcc, 0x8c, 0xbe } }, "F_VN_Dft", nullptr }, \
	{ { 0x36ce795f, 0xc87f, 0x4696, { 0xad, 0x00, 0xab, 0x36, 0x23, 0x02, 0xec, 0x94 } }, "F_VN_DistanceTransformationExp", nullptr }, \
	{ { 0x568305f6, 0x07fe, 0x45a4, { 0xac, 0xcc, 0x05, 0x78, 0xfa, 0x4c, 0x05, 0x43 } }, "F_VN_DivideContainersExp", nullptr }, \
	{ { 0x199c5a51, 0x5352, 0x4857, { 0x8e, 0x53, 0x70, 0xa6, 0xda, 0x1f, 0x77, 0xcb } }, "F_VN_DivideImageByScalar", nullptr }, \
	{ { 0xe963a4c2, 0x23d4, 0x45e1, { 0x8c, 0x8e, 0xb3, 0x6d, 0x37, 0xfc, 0x48, 0x83 } }, "F_VN_DivideImageByVector", nullptr }, \
	{ { 0x09970669, 0xa997, 0x4162, { 0x81, 0x51, 0xc9, 0xc5, 0xe5, 0x8f, 0x8d, 0xbd } }, "F_VN_DivideImages", nullptr }, \
	{ { 0x5ae23a54, 0x6784, 0x4db2, { 0xbc, 0xf9, 0xba, 0xe2, 0xd1, 0x5d, 0x97, 0xea } }, "F_VN_DivideScalarByImage", nullptr }, \
	{ { 0x51c75939, 0x514a, 0x49b4, { 0x8c, 0xb4, 0xfc, 0xf3, 0x6e, 0x6d, 0x4a, 0x72 } }, "F_VN_DivideVectorByImage", nullptr }, \
	{ { 0x79d38c8d, 0x6833, 0x4ee4, { 0x8a, 0x54, 0x84, 0xfc, 0xde, 0x87, 0x6d, 0xa4 } }, "F_VN_DoubleThreshold", nullptr }, \
	{ { 0x8e1f4765, 0xce80, 0x4c87, { 0x8c, 0xc0, 0x7d, 0x81, 0x53, 0x0c, 0x32, 0x87 } }, "F_VN_DrawArrowExp", nullptr }, \
	{ { 0xfd74fbd1, 0x0a12, 0x42c3, { 0x94, 0x6a, 0x72, 0xeb, 0x13, 0x90, 0x83, 0x19 } }, "F_VN_DrawArrowExp_TcVnVector4_DINT", nullptr }, \
	{ { 0xfd9a6b41, 0x582b, 0x41dc, { 0x88, 0xe3, 0x37, 0xf7, 0x91, 0x63, 0x05, 0x7c } }, "F_VN_DrawCircleExp", nullptr }, \
	{ { 0x56ef6ce7, 0xfd88, 0x4dff, { 0xa3, 0x7d, 0x03, 0xbe, 0x32, 0x3d, 0x42, 0xc4 } }, "F_VN_DrawCirclesExp", nullptr }, \
	{ { 0xcfd8d400, 0xe948, 0x42e5, { 0xaf, 0x0e, 0x71, 0x66, 0xd3, 0xbe, 0xb1, 0xb7 } }, "F_VN_DrawCircularArcExp", nullptr }, \
	{ { 0x719c0985, 0x3fcd, 0x4bcb, { 0xb9, 0xd3, 0x83, 0xa0, 0x72, 0x7d, 0x0b, 0x63 } }, "F_VN_DrawComponentsExp", nullptr }, \
	{ { 0xd8905896, 0xe860, 0x4b57, { 0xae, 0x41, 0x6a, 0xf4, 0xf5, 0x1f, 0x4e, 0xb9 } }, "F_VN_DrawContoursExp", nullptr }, \
	{ { 0xd3ec3658, 0x1cfb, 0x4618, { 0x83, 0xc7, 0x50, 0x27, 0xdb, 0xe0, 0x59, 0xe3 } }, "F_VN_DrawEllipseExp", nullptr }, \
	{ { 0x4c4bc95a, 0xf0da, 0x4d84, { 0xbb, 0xb2, 0x27, 0xd3, 0x85, 0x56, 0x42, 0x5e } }, "F_VN_DrawLineExp", nullptr }, \
	{ { 0xfa2f2e4f, 0x9c5a, 0x45ff, { 0x9b, 0x3c, 0x43, 0xf0, 0xa1, 0x92, 0x7d, 0xa3 } }, "F_VN_DrawLineExp_TcVnVector4_DINT", nullptr }, \
	{ { 0xd8f62c5e, 0x0da7, 0x4543, { 0xaf, 0x44, 0x7f, 0x74, 0x53, 0x2f, 0x2d, 0x4d } }, "F_VN_DrawLineExp_TcVnVector4_LREAL", nullptr }, \
	{ { 0xd56f5890, 0x7fe9, 0x44db, { 0xb9, 0x05, 0xdb, 0xd9, 0x39, 0xd2, 0xc5, 0x5a } }, "F_VN_DrawLinesExp", nullptr }, \
	{ { 0x05da70a1, 0x6e22, 0x413f, { 0x98, 0xb4, 0x65, 0x17, 0x7d, 0xb6, 0xd1, 0x1f } }, "F_VN_DrawOrientation", nullptr }, \
	{ { 0xe0ea0855, 0x6c5e, 0x4bd0, { 0xac, 0xb9, 0x8a, 0x71, 0x04, 0x4c, 0x6b, 0xf1 } }, "F_VN_DrawOrientationExp", nullptr }, \
	{ { 0x8537519e, 0x818b, 0x4be8, { 0x86, 0x5b, 0x69, 0xa8, 0xea, 0xec, 0x46, 0xe2 } }, "F_VN_DrawPointExp", nullptr }, \
	{ { 0xbd342853, 0x82df, 0x4974, { 0x80, 0x03, 0x5e, 0xe3, 0xe1, 0x1b, 0xd4, 0x99 } }, "F_VN_DrawPointsExp", nullptr }, \
	{ { 0x5e1c2a6f, 0x0d36, 0x4484, { 0x8a, 0x0b, 0xcb, 0xcf, 0xc8, 0x31, 0x65, 0x82 } }, "F_VN_DrawPolygonExp", nullptr }, \
	{ { 0x43f09fa5, 0xc152, 0x4b0f, { 0x9c, 0x86, 0x35, 0xca, 0x8e, 0x00, 0xdd, 0x46 } }, "F_VN_DrawRectangle", nullptr }, \
	{ { 0xbc13bf6f, 0x295b, 0x4b1d, { 0xa6, 0x60, 0x34, 0x44, 0xc4, 0xa5, 0xd9, 0x9f } }, "F_VN_DrawRectangle_TcVnRectangle_DINT", nullptr }, \
	{ { 0xc2f4ba90, 0xb522, 0x49bd, { 0xa2, 0x49, 0xdf, 0x86, 0x69, 0x46, 0x78, 0x6a } }, "F_VN_DrawRectangle_TcVnRectangle_UDINT", nullptr }, \
	{ { 0x77807517, 0xfc0d, 0x4256, { 0x99, 0x2d, 0x99, 0xb6, 0x04, 0xca, 0x6a, 0x31 } }, "F_VN_DrawRotatedRectangleExp", nullptr }, \
	{ { 0x732c8323, 0x4fe5, 0x4967, { 0x8a, 0x75, 0x17, 0x25, 0xd5, 0x08, 0x37, 0x6b } }, "F_VN_ElementwiseExp", nullptr }, \
	{ { 0x6bfb991a, 0xed4a, 0x4f79, { 0xb3, 0xc1, 0xda, 0x4f, 0xa9, 0xe3, 0x75, 0x22 } }, "F_VN_ElementwiseLog", nullptr }, \
	{ { 0x8ab6a8f4, 0x803e, 0x47de, { 0x9c, 0x01, 0x05, 0x5a, 0x97, 0x00, 0x70, 0xfc } }, "F_VN_EnclosingCircle", nullptr }, \
	{ { 0xfce1c887, 0x2729, 0x43b1, { 0x84, 0x47, 0x24, 0xa8, 0x3d, 0xc0, 0x77, 0x7c } }, "F_VN_EnclosingRectangle", nullptr }, \
	{ { 0x311d62d9, 0xfbc3, 0x4dce, { 0xa1, 0xe8, 0x46, 0x21, 0xcf, 0x68, 0xee, 0x86 } }, "F_VN_EnclosingTriangle", nullptr }, \
	{ { 0xd7624183, 0x8c87, 0x4bcb, { 0x96, 0xdb, 0x1a, 0x8e, 0x0f, 0x80, 0x7b, 0xf3 } }, "F_VN_EraseFromContainer", nullptr }, \
	{ { 0xb2f45e70, 0x1a6a, 0x4a02, { 0xa0, 0xc0, 0xb2, 0xbd, 0xff, 0x64, 0x1d, 0x2b } }, "F_VN_ExportContainer", nullptr }, \
	{ { 0x5a3ca859, 0x9951, 0x4468, { 0x94, 0x80, 0x99, 0x52, 0xca, 0x23, 0x75, 0x80 } }, "F_VN_ExportContainer_String", nullptr }, \
	{ { 0x7710b82d, 0x3834, 0x4541, { 0xad, 0xc0, 0x71, 0x16, 0x47, 0x53, 0x10, 0x6b } }, "F_VN_ExportContainerSize", nullptr }, \
	{ { 0x68a034a2, 0xd2c8, 0x451e, { 0xa5, 0x7b, 0xa5, 0x11, 0x61, 0x21, 0x23, 0x8f } }, "F_VN_ExportImage", nullptr }, \
	{ { 0x3d4057bf, 0x0568, 0x42f9, { 0xb8, 0x66, 0x78, 0x47, 0x80, 0x7d, 0x17, 0x61 } }, "F_VN_ExportImageAsBmpExp", nullptr }, \
	{ { 0x6f19ca7a, 0xc6a1, 0x406c, { 0x84, 0x7c, 0x7b, 0x27, 0xc1, 0x0e, 0x2f, 0x9f } }, "F_VN_ExportImageAsBmpSizeExp", nullptr }, \
	{ { 0xe31f4a54, 0x201f, 0x4a5d, { 0x82, 0x19, 0x63, 0x7f, 0x0a, 0x1d, 0x7c, 0xcc } }, "F_VN_ExportImageSize", nullptr }, \
	{ { 0x2d92d21b, 0x4fea, 0x48e7, { 0x82, 0x4d, 0xcb, 0xbf, 0xaf, 0xb7, 0xfd, 0x12 } }, "F_VN_ExportSubContainer", nullptr }, \
	{ { 0x4eb15990, 0x7527, 0x4a74, { 0xb0, 0x5d, 0xc5, 0xb1, 0x83, 0x2d, 0x34, 0x3d } }, "F_VN_ExportSubContainer_String", nullptr }, \
	{ { 0x9bd382eb, 0xbc7f, 0x4747, { 0xb3, 0x0b, 0x44, 0xc3, 0x0c, 0x02, 0x22, 0xa2 } }, "F_VN_ExportSubContainerSize", nullptr }, \
	{ { 0x4f568770, 0x89a3, 0x4edf, { 0x93, 0xbf, 0xb6, 0xc7, 0x79, 0x89, 0xd3, 0xba } }, "F_VN_ExtractContainerRange", nullptr }, \
	{ { 0xde7199c9, 0x8138, 0x4b3b, { 0xa1, 0xeb, 0x64, 0x48, 0x14, 0xb6, 0xc1, 0x83 } }, "F_VN_FillCircle", nullptr }, \
	{ { 0x99b59919, 0xa720, 0x44fb, { 0x98, 0xd5, 0x0f, 0xa0, 0x57, 0xcf, 0x60, 0xb9 } }, "F_VN_FillContainer_DINT", nullptr }, \
	{ { 0x1f581418, 0x596a, 0x4198, { 0x81, 0xa9, 0x2a, 0x51, 0x8b, 0x97, 0x89, 0x46 } }, "F_VN_FillContainer_INT", nullptr }, \
	{ { 0xb32271f4, 0x0172, 0x48af, { 0xaf, 0xc7, 0xef, 0x42, 0x09, 0x83, 0x38, 0x8c } }, "F_VN_FillContainer_ITcVnImage", nullptr }, \
	{ { 0x1cb405d8, 0x51bd, 0x4b25, { 0x99, 0x76, 0x72, 0x2a, 0x97, 0x39, 0x87, 0xae } }, "F_VN_FillContainer_LREAL", nullptr }, \
	{ { 0x41be2b8a, 0x489a, 0x41fc, { 0xa7, 0xce, 0xe1, 0x4b, 0x34, 0xf3, 0x4e, 0x94 } }, "F_VN_FillContainer_REAL", nullptr }, \
	{ { 0x66826c9d, 0x3f79, 0x43d8, { 0x95, 0x41, 0xd2, 0xf4, 0x56, 0xb9, 0xb4, 0xa1 } }, "F_VN_FillContainer_SINT", nullptr }, \
	{ { 0x0b42d8af, 0x407a, 0x478e, { 0x92, 0x64, 0x13, 0x35, 0x6b, 0xc5, 0xc6, 0x69 } }, "F_VN_FillContainer_TcVnDMatch", nullptr }, \
	{ { 0x81f296bb, 0x3ef5, 0x42dd, { 0x9b, 0x85, 0x78, 0x8a, 0x78, 0x53, 0x9e, 0x7e } }, "F_VN_FillContainer_TcVnKeyPoint", nullptr }, \
	{ { 0x9b6d59e7, 0xc2ee, 0x4aad, { 0x94, 0x48, 0xda, 0xa8, 0xbd, 0xdd, 0xf1, 0x9f } }, "F_VN_FillContainer_TcVnPoint2_DINT", nullptr }, \
	{ { 0x3bb0ac8a, 0x1cfa, 0x4cc1, { 0xbd, 0xfe, 0x01, 0xfd, 0xba, 0x98, 0x59, 0x5d } }, "F_VN_FillContainer_TcVnPoint2_LREAL", nullptr }, \
	{ { 0x94011020, 0xc2cd, 0x4603, { 0x92, 0x1a, 0x6a, 0x7e, 0xf5, 0xe4, 0xbe, 0x6e } }, "F_VN_FillContainer_TcVnPoint2_REAL", nullptr }, \
	{ { 0x6f4155b7, 0xc588, 0x4276, { 0xa4, 0xc9, 0x4f, 0x1f, 0x50, 0x01, 0x79, 0xd8 } }, "F_VN_FillContainer_TcVnPoint3_LREAL", nullptr }, \
	{ { 0x8ec8b6c4, 0xaa37, 0x43cc, { 0x9e, 0x67, 0x56, 0x39, 0xf7, 0x72, 0xf4, 0x9b } }, "F_VN_FillContainer_TcVnPoint3_REAL", nullptr }, \
	{ { 0xfe019528, 0xe340, 0x4f3d, { 0xba, 0x78, 0x71, 0x16, 0x25, 0x8f, 0xb2, 0x7d } }, "F_VN_FillContainer_TcVnRectangle_DINT", nullptr }, \
	{ { 0xabb2eaa5, 0xe23e, 0x4edf, { 0xbb, 0xaf, 0xb7, 0xdc, 0x73, 0x86, 0x93, 0x27 } }, "F_VN_FillContainer_TcVnRotatedRectangle", nullptr }, \
	{ { 0xc4959c9b, 0x4f9b, 0x4547, { 0xbd, 0x40, 0x15, 0x5b, 0x30, 0xce, 0x2e, 0xc6 } }, "F_VN_FillContainer_TcVnVector2_DINT", nullptr }, \
	{ { 0x1435ef16, 0xf7ca, 0x48f3, { 0x8b, 0x57, 0x05, 0xea, 0xd2, 0xc5, 0x02, 0x38 } }, "F_VN_FillContainer_TcVnVector2_INT", nullptr }, \
	{ { 0x5354fb89, 0x51d5, 0x4bf8, { 0x8e, 0x4a, 0xea, 0x03, 0x3f, 0xa2, 0x24, 0xa2 } }, "F_VN_FillContainer_TcVnVector2_REAL", nullptr }, \
	{ { 0xe4d55a1d, 0xbdd1, 0x44cd, { 0x9a, 0xc1, 0x1c, 0x40, 0xa3, 0xca, 0x24, 0x4a } }, "F_VN_FillContainer_TcVnVector2_SINT", nullptr }, \
	{ { 0x64cb9ec9, 0xf03d, 0x4f3b, { 0xa0, 0x19, 0x9b, 0x93, 0x5b, 0x29, 0xe7, 0x77 } }, "F_VN_FillContainer_TcVnVector2_UINT", nullptr }, \
	{ { 0x4c0b551e, 0x6cd7, 0x4192, { 0xa6, 0xa5, 0x53, 0xbe, 0x48, 0xbc, 0xb9, 0x87 } }, "F_VN_FillContainer_TcVnVector2_USINT", nullptr }, \
	{ { 0x8fcbedc7, 0x2e8f, 0x418b, { 0x88, 0x88, 0x51, 0x42, 0x4b, 0xd9, 0x46, 0xc0 } }, "F_VN_FillContainer_TcVnVector3_INT", nullptr }, \
	{ { 0x0ab2bedd, 0x2509, 0x420e, { 0xb0, 0xb3, 0x47, 0xd2, 0xf2, 0x51, 0x5f, 0x14 } }, "F_VN_FillContainer_TcVnVector3_REAL", nullptr }, \
	{ { 0xe38a5cc4, 0xfc6b, 0x496c, { 0xaa, 0x59, 0x70, 0x40, 0x2d, 0x61, 0xeb, 0xda } }, "F_VN_FillContainer_TcVnVector3_SINT", nullptr }, \
	{ { 0xdae54568, 0xc9c2, 0x4d57, { 0x91, 0x33, 0xf9, 0x2a, 0x07, 0x18, 0x62, 0x18 } }, "F_VN_FillContainer_TcVnVector3_UINT", nullptr }, \
	{ { 0xbd7b026c, 0xf5ef, 0x4f21, { 0xa8, 0xca, 0xc8, 0x45, 0x56, 0x14, 0x4c, 0xd5 } }, "F_VN_FillContainer_TcVnVector3_USINT", nullptr }, \
	{ { 0x05932bfe, 0x98dc, 0x452e, { 0x96, 0xe1, 0x75, 0xa9, 0x4f, 0x26, 0x9f, 0xfb } }, "F_VN_FillContainer_TcVnVector4_DINT", nullptr }, \
	{ { 0xdb22b4a7, 0x6b40, 0x42c6, { 0x87, 0xd3, 0x4e, 0x34, 0x65, 0x63, 0xfe, 0x78 } }, "F_VN_FillContainer_TcVnVector4_INT", nullptr }, \
	{ { 0xdc13b10c, 0x3db3, 0x4c15, { 0xa5, 0x2c, 0x2f, 0x77, 0xca, 0x0f, 0x6b, 0x9f } }, "F_VN_FillContainer_TcVnVector4_LREAL", nullptr }, \
	{ { 0x98f94a02, 0x5d74, 0x4536, { 0x94, 0x09, 0x55, 0xc5, 0xc3, 0xfc, 0xa7, 0x40 } }, "F_VN_FillContainer_TcVnVector4_REAL", nullptr }, \
	{ { 0x2fe18642, 0xa71c, 0x4169, { 0x80, 0x7c, 0x79, 0xcc, 0x6b, 0x9b, 0xf6, 0x48 } }, "F_VN_FillContainer_TcVnVector4_SINT", nullptr }, \
	{ { 0xe2d10cc3, 0x285e, 0x45d3, { 0xb6, 0xda, 0xbf, 0x99, 0xf0, 0x72, 0x16, 0x03 } }, "F_VN_FillContainer_TcVnVector4_UINT", nullptr }, \
	{ { 0x332f3fe3, 0xb339, 0x41b8, { 0x9d, 0x85, 0x4d, 0x29, 0x28, 0xd2, 0xf4, 0x5f } }, "F_VN_FillContainer_TcVnVector4_USINT", nullptr }, \
	{ { 0xb21c66a1, 0x9473, 0x45b5, { 0xbc, 0x01, 0xde, 0xce, 0xa2, 0x57, 0x57, 0x3e } }, "F_VN_FillContainer_UDINT", nullptr }, \
	{ { 0x2443d205, 0xf5a2, 0x4a25, { 0xa3, 0x80, 0xaa, 0x55, 0x02, 0x6f, 0x30, 0x3d } }, "F_VN_FillContainer_UINT", nullptr }, \
	{ { 0x8f94f09c, 0x48b0, 0x4654, { 0x98, 0x96, 0xf8, 0x13, 0xd1, 0xc0, 0xfb, 0x5e } }, "F_VN_FillContainer_ULINT", nullptr }, \
	{ { 0xe564ce87, 0xd10e, 0x430b, { 0x94, 0xba, 0x82, 0x16, 0x17, 0xb8, 0xe2, 0x0c } }, "F_VN_FillContainer_USINT", nullptr }, \
	{ { 0x5ef1e67a, 0x5f4d, 0x442f, { 0x97, 0xcb, 0x78, 0xb3, 0x77, 0x78, 0x70, 0x44 } }, "F_VN_FillContainerExp_DINT", nullptr }, \
	{ { 0x45209fe2, 0x24ad, 0x423a, { 0x8a, 0x93, 0xc1, 0xae, 0x6c, 0xef, 0x69, 0xf0 } }, "F_VN_FillContainerExp_INT", nullptr }, \
	{ { 0x7055749a, 0x7e3b, 0x466d, { 0x8a, 0x7b, 0x1e, 0xb2, 0xbb, 0x34, 0x1c, 0xb6 } }, "F_VN_FillContainerExp_ITcVnImage", nullptr }, \
	{ { 0xe08e7287, 0x40a1, 0x4ac6, { 0x9f, 0xc5, 0x88, 0xbc, 0xa2, 0x38, 0xc2, 0x82 } }, "F_VN_FillContainerExp_LREAL", nullptr }, \
	{ { 0xae9ec190, 0x5a75, 0x490c, { 0xaf, 0x00, 0x1f, 0x42, 0x18, 0xbc, 0xbb, 0x51 } }, "F_VN_FillContainerExp_REAL", nullptr }, \
	{ { 0x76a0bb9b, 0xdd23, 0x4400, { 0xa5, 0xf4, 0xa8, 0x5e, 0x29, 0x6b, 0x3f, 0x35 } }, "F_VN_FillContainerExp_SINT", nullptr }, \
	{ { 0x8895ae7b, 0x554b, 0x4481, { 0xb2, 0xd1, 0x72, 0xec, 0xb4, 0x5b, 0x80, 0x87 } }, "F_VN_FillContainerExp_TcVnDMatch", nullptr }, \
	{ { 0xb8aa63c4, 0x437e, 0x48b6, { 0x96, 0xb2, 0x14, 0x8f, 0xbd, 0x2b, 0x27, 0x6a } }, "F_VN_FillContainerExp_TcVnKeyPoint", nullptr }, \
	{ { 0xb3df04c1, 0x7b6e, 0x44c4, { 0x88, 0x38, 0x8c, 0xbb, 0xa8, 0xf3, 0x57, 0x8a } }, "F_VN_FillContainerExp_TcVnPoint2_DINT", nullptr }, \
	{ { 0x09d737ad, 0x9cbc, 0x4210, { 0xb6, 0xec, 0x3d, 0xc7, 0x3b, 0x4d, 0x00, 0x99 } }, "F_VN_FillContainerExp_TcVnPoint2_LREAL", nullptr }, \
	{ { 0x34b39520, 0x4665, 0x47e5, { 0xbc, 0xc4, 0xf8, 0x49, 0x03, 0x0c, 0x28, 0x62 } }, "F_VN_FillContainerExp_TcVnPoint2_REAL", nullptr }, \
	{ { 0x514e36cd, 0x3016, 0x41c1, { 0xa8, 0x23, 0x85, 0x87, 0x2f, 0x32, 0x38, 0x67 } }, "F_VN_FillContainerExp_TcVnPoint3_LREAL", nullptr }, \
	{ { 0x8cf24d25, 0xf1c9, 0x41ff, { 0xa1, 0xd4, 0xa8, 0x92, 0x84, 0x64, 0x9a, 0xa1 } }, "F_VN_FillContainerExp_TcVnPoint3_REAL", nullptr }, \
	{ { 0x6d9aaccc, 0xa11b, 0x47ed, { 0xa6, 0x5e, 0xc0, 0x1c, 0xa5, 0x35, 0xa3, 0xea } }, "F_VN_FillContainerExp_TcVnRectangle_DINT", nullptr }, \
	{ { 0xbe41a6e2, 0x6b67, 0x4ac1, { 0x91, 0x48, 0xdd, 0x67, 0x2d, 0xfc, 0x9c, 0xb3 } }, "F_VN_FillContainerExp_TcVnRotatedRectangle", nullptr }, \
	{ { 0x3308ec27, 0x1b84, 0x455e, { 0xb3, 0xfa, 0x61, 0x34, 0x39, 0xb9, 0xfa, 0x93 } }, "F_VN_FillContainerExp_TcVnVector2_DINT", nullptr }, \
	{ { 0x168df7c9, 0x3bfe, 0x4c66, { 0x84, 0x1d, 0xbf, 0x7d, 0x9d, 0x87, 0x50, 0x0d } }, "F_VN_FillContainerExp_TcVnVector2_INT", nullptr }, \
	{ { 0x9ff56bc0, 0x1c7d, 0x45ae, { 0x84, 0x05, 0x4d, 0x2b, 0x1c, 0xc4, 0x16, 0xbf } }, "F_VN_FillContainerExp_TcVnVector2_REAL", nullptr }, \
	{ { 0xbc46e904, 0x34ea, 0x4050, { 0xa3, 0x57, 0x82, 0xb9, 0xd1, 0xe7, 0x72, 0xc3 } }, "F_VN_FillContainerExp_TcVnVector2_SINT", nullptr }, \
	{ { 0xcef1676e, 0x4c8f, 0x45bb, { 0x90, 0xc8, 0x20, 0x85, 0x14, 0x70, 0xf8, 0x03 } }, "F_VN_FillContainerExp_TcVnVector2_UINT", nullptr }, \
	{ { 0x2cf8cb5a, 0x278d, 0x4263, { 0x8e, 0xda, 0x1a, 0x23, 0xcf, 0x46, 0xae, 0xfb } }, "F_VN_FillContainerExp_TcVnVector2_USINT", nullptr }, \
	{ { 0x6e54ef99, 0x4e98, 0x45b8, { 0xae, 0x7a, 0x94, 0x4d, 0xb9, 0x1e, 0x1d, 0xbe } }, "F_VN_FillContainerExp_TcVnVector3_INT", nullptr }, \
	{ { 0x11388f47, 0x9aee, 0x4be8, { 0x80, 0xf2, 0x23, 0x23, 0xd7, 0x4d, 0xd7, 0xeb } }, "F_VN_FillContainerExp_TcVnVector3_REAL", nullptr }, \
	{ { 0x214139ed, 0x4417, 0x477f, { 0x97, 0xe8, 0x9b, 0x8f, 0x6e, 0x56, 0x75, 0x8d } }, "F_VN_FillContainerExp_TcVnVector3_SINT", nullptr }, \
	{ { 0x441443d5, 0xf8c3, 0x4ab0, { 0x98, 0x77, 0xa0, 0xc0, 0xfc, 0x62, 0x4e, 0x5c } }, "F_VN_FillContainerExp_TcVnVector3_UINT", nullptr }, \
	{ { 0x49516577, 0xa3eb, 0x4073, { 0xb1, 0xce, 0x7a, 0xa4, 0x09, 0x2b, 0x83, 0x63 } }, "F_VN_FillContainerExp_TcVnVector3_USINT", nullptr }, \
	{ { 0x3692f70c, 0x156f, 0x4098, { 0x8d, 0x8c, 0x9c, 0x8a, 0x5b, 0x99, 0x33, 0x9a } }, "F_VN_FillContainerExp_TcVnVector4_DINT", nullptr }, \
	{ { 0x18215241, 0xee77, 0x47b7, { 0xa6, 0xa4, 0x57, 0x44, 0x4b, 0x48, 0x5c, 0xf7 } }, "F_VN_FillContainerExp_TcVnVector4_INT", nullptr }, \
	{ { 0x38b7f69b, 0x2d89, 0x4864, { 0x9d, 0x4d, 0x75, 0x30, 0xdf, 0x3d, 0x06, 0x48 } }, "F_VN_FillContainerExp_TcVnVector4_LREAL", nullptr }, \
	{ { 0x0baf9b36, 0xd36e, 0x45ff, { 0xb6, 0xa8, 0xc7, 0x65, 0x8c, 0x3e, 0x8f, 0x04 } }, "F_VN_FillContainerExp_TcVnVector4_REAL", nullptr }, \
	{ { 0xd089c36c, 0x5b32, 0x4580, { 0xa9, 0x33, 0x8c, 0xcb, 0xef, 0xc2, 0x8a, 0xbb } }, "F_VN_FillContainerExp_TcVnVector4_SINT", nullptr }, \
	{ { 0x8924dda7, 0xd195, 0x4035, { 0x8e, 0x9b, 0x3b, 0x89, 0x74, 0x88, 0x0b, 0x17 } }, "F_VN_FillContainerExp_TcVnVector4_UINT", nullptr }, \
	{ { 0x6ed09b6a, 0xd8e6, 0x4d5a, { 0x90, 0xb0, 0xe8, 0x69, 0xd4, 0xe7, 0xd6, 0xfb } }, "F_VN_FillContainerExp_TcVnVector4_USINT", nullptr }, \
	{ { 0x27af1d8f, 0x4bc2, 0x4440, { 0x87, 0xc9, 0xd3, 0x63, 0xa4, 0x1a, 0x97, 0x6b } }, "F_VN_FillContainerExp_UDINT", nullptr }, \
	{ { 0xa003568f, 0x583c, 0x4803, { 0xb5, 0xb8, 0x1d, 0xa2, 0x55, 0xc0, 0x94, 0x04 } }, "F_VN_FillContainerExp_UINT", nullptr }, \
	{ { 0x077194a0, 0x0b82, 0x4513, { 0x86, 0x12, 0x9f, 0xde, 0x4d, 0x8f, 0x99, 0xf1 } }, "F_VN_FillContainerExp_ULINT", nullptr }, \
	{ { 0xb8c89ece, 0xe2b1, 0x4ad2, { 0x9e, 0x39, 0x27, 0x0a, 0x3a, 0x2a, 0x64, 0x3b } }, "F_VN_FillContainerExp_USINT", nullptr }, \
	{ { 0x13916ae1, 0x6351, 0x451e, { 0x93, 0x3d, 0xcf, 0x00, 0xea, 0x4a, 0xca, 0xb0 } }, "F_VN_FillContours", nullptr }, \
	{ { 0xd55f223d, 0xee43, 0x4eb4, { 0x98, 0x44, 0xc4, 0xd1, 0xb3, 0xc4, 0x9f, 0xba } }, "F_VN_FillEllipse", nullptr }, \
	{ { 0xbcdb4c09, 0x796a, 0x419b, { 0x90, 0x10, 0x4f, 0x3b, 0x1c, 0x88, 0x4b, 0x3d } }, "F_VN_FillHoles", nullptr }, \
	{ { 0xac4d5fae, 0x6cf8, 0x4e5e, { 0x82, 0xb1, 0x59, 0x78, 0x52, 0x57, 0xf7, 0xa3 } }, "F_VN_FillPolygon", nullptr }, \
	{ { 0x3f70fe13, 0x38ff, 0x4b59, { 0xa4, 0xf7, 0xd7, 0x73, 0xa5, 0x26, 0xa7, 0x83 } }, "F_VN_FillRectangle", nullptr }, \
	{ { 0x8c9d21f3, 0x30b2, 0x49ba, { 0x98, 0xc4, 0x70, 0x21, 0xa0, 0x47, 0x3a, 0x94 } }, "F_VN_FillRotatedRectangle", nullptr }, \
	{ { 0x7255387d, 0x97b1, 0x4662, { 0xa4, 0x5e, 0xc4, 0x72, 0xe6, 0xab, 0xdf, 0xf1 } }, "F_VN_FindContourHierarchyExp", nullptr }, \
	{ { 0x6a9cd696, 0x4b17, 0x4747, { 0xb6, 0xde, 0x92, 0xae, 0x73, 0x2b, 0x1d, 0x6c } }, "F_VN_FindContoursExp", nullptr }, \
	{ { 0x37a94b96, 0x76e9, 0x476c, { 0x9d, 0x75, 0xaf, 0xa7, 0xa1, 0xf5, 0x1e, 0xc8 } }, "F_VN_FitEllipse", nullptr }, \
	{ { 0xdf74f83d, 0x60e4, 0x47fc, { 0x80, 0x2f, 0x3a, 0xe7, 0xc6, 0x3e, 0x09, 0x19 } }, "F_VN_FitLineExp", nullptr }, \
	{ { 0xd9382907, 0x93cd, 0x4a0e, { 0x90, 0xd2, 0x53, 0x71, 0x4d, 0x22, 0x30, 0xcd } }, "F_VN_FlipImage", nullptr }, \
	{ { 0x8ece7f82, 0xc73e, 0x4a12, { 0xab, 0xa2, 0xce, 0x8f, 0x53, 0xc7, 0x28, 0xe5 } }, "F_VN_FourierDescriptors", nullptr }, \
	{ { 0x3ec47c9a, 0x4b97, 0x4541, { 0x9a, 0xf9, 0x34, 0xcf, 0xd2, 0xbd, 0x6e, 0xfd } }, "F_VN_FuseImages", nullptr }, \
	{ { 0x0acd1b71, 0x5306, 0x424c, { 0x9e, 0x12, 0x3b, 0xfb, 0xeb, 0xdc, 0xbb, 0xb7 } }, "F_VN_FuseImagesArray", nullptr }, \
	{ { 0xbdb6e3ac, 0x2d73, 0x48df, { 0xbe, 0x75, 0x8c, 0xff, 0x50, 0xa1, 0xec, 0x5a } }, "F_VN_GaussianFilterExp", nullptr }, \
	{ { 0x9ffd6732, 0xb0d1, 0x443f, { 0x97, 0xa4, 0xc2, 0xea, 0x9f, 0xc8, 0x9e, 0xd7 } }, "F_VN_GenerateAffineTransformationUnitMatrix2D", nullptr }, \
	{ { 0x8db898b6, 0xe618, 0x441a, { 0xba, 0xee, 0x7b, 0x16, 0x40, 0x08, 0xd8, 0xd6 } }, "F_VN_GenerateColorMap", nullptr }, \
	{ { 0xe98c8618, 0x5d75, 0x4430, { 0xab, 0x72, 0xb2, 0xab, 0xe1, 0x53, 0xfd, 0xd1 } }, "F_VN_GenerateCustomColorMap", nullptr }, \
	{ { 0xee1f72d9, 0x35c4, 0x4090, { 0x93, 0xd5, 0x68, 0xf4, 0x3c, 0x97, 0x82, 0x7b } }, "F_VN_GetAffineTransformation", nullptr }, \
	{ { 0x36a5b7b0, 0xb1d2, 0x4a1b, { 0x93, 0x9b, 0x38, 0x64, 0xcb, 0x1a, 0xd3, 0xe4 } }, "F_VN_GetAffineTransformation2DExp", nullptr }, \
	{ { 0x35dfbc00, 0xd132, 0x4005, { 0xb6, 0x46, 0x5d, 0x8a, 0x53, 0x54, 0x9b, 0x48 } }, "F_VN_GetAt_DINT", nullptr }, \
	{ { 0x7da5c76e, 0xebcd, 0x4aac, { 0x9e, 0xfd, 0xf1, 0xae, 0xe9, 0xce, 0x12, 0x0d } }, "F_VN_GetAt_INT", nullptr }, \
	{ { 0xe279339a, 0x1998, 0x4710, { 0x9d, 0x7d, 0x7b, 0xe3, 0x62, 0x60, 0x5d, 0xc5 } }, "F_VN_GetAt_ITcVnContainer", nullptr }, \
	{ { 0x7ab0f351, 0x3d6e, 0x4257, { 0x98, 0x97, 0xa1, 0x7a, 0x19, 0x66, 0x32, 0x15 } }, "F_VN_GetAt_ITcVnImage", nullptr }, \
	{ { 0x3aa1ec32, 0x6d78, 0x4551, { 0xa7, 0xcf, 0x9b, 0xc7, 0x76, 0x7e, 0x25, 0xed } }, "F_VN_GetAt_LREAL", nullptr }, \
	{ { 0xf830128f, 0x3e13, 0x405e, { 0xb1, 0x8c, 0x4a, 0x3f, 0x13, 0xef, 0xeb, 0x0f } }, "F_VN_GetAt_REAL", nullptr }, \
	{ { 0x6e30c043, 0x83e2, 0x43b3, { 0x96, 0xe0, 0xbb, 0x8b, 0x36, 0x71, 0x38, 0xd7 } }, "F_VN_GetAt_SINT", nullptr }, \
	{ { 0xd4216fd0, 0xfcf3, 0x46c1, { 0xb0, 0x2f, 0x24, 0x7c, 0xca, 0xd6, 0x81, 0xa8 } }, "F_VN_GetAt_TcVnDMatch", nullptr }, \
	{ { 0xcb2394ed, 0x808d, 0x42d3, { 0xac, 0x5f, 0x8b, 0xf9, 0x9d, 0x47, 0x1e, 0x09 } }, "F_VN_GetAt_TcVnKeyPoint", nullptr }, \
	{ { 0x0518a622, 0xcb24, 0x46ff, { 0xb5, 0x3d, 0xd4, 0x5b, 0x3b, 0xbe, 0x4f, 0xad } }, "F_VN_GetAt_TcVnPoint2_DINT", nullptr }, \
	{ { 0x78cdd92a, 0xc8d0, 0x43e4, { 0x97, 0x50, 0x8b, 0x36, 0xbf, 0xfe, 0x19, 0xaa } }, "F_VN_GetAt_TcVnPoint2_LREAL", nullptr }, \
	{ { 0xd13829ae, 0xe369, 0x4955, { 0x8f, 0xe3, 0x2e, 0xcb, 0xae, 0x7d, 0xc9, 0xce } }, "F_VN_GetAt_TcVnPoint2_REAL", nullptr }, \
	{ { 0x761f8ab4, 0xb167, 0x4df9, { 0xa1, 0xa5, 0x1d, 0x69, 0xf7, 0xf1, 0xc6, 0x34 } }, "F_VN_GetAt_TcVnPoint3_LREAL", nullptr }, \
	{ { 0xec7b48da, 0xf27e, 0x4731, { 0xb5, 0x3a, 0xb2, 0x4c, 0x70, 0x11, 0x02, 0x1c } }, "F_VN_GetAt_TcVnPoint3_REAL", nullptr }, \
	{ { 0x9395c7f0, 0x641c, 0x4037, { 0xb3, 0x63, 0x30, 0xf2, 0xeb, 0x0c, 0x5a, 0x0d } }, "F_VN_GetAt_TcVnRectangle_DINT", nullptr }, \
	{ { 0xde362fca, 0x1068, 0x4398, { 0x92, 0xf0, 0x53, 0xa4, 0xf1, 0xc2, 0xb0, 0x4e } }, "F_VN_GetAt_TcVnRotatedRectangle", nullptr }, \
	{ { 0x01e435c8, 0xb518, 0x4b50, { 0x9b, 0x4b, 0x02, 0x35, 0x39, 0x8f, 0x43, 0x25 } }, "F_VN_GetAt_TcVnVector2_DINT", nullptr }, \
	{ { 0x9637d96f, 0xdc35, 0x48d2, { 0xaf, 0xc2, 0x0a, 0x12, 0x89, 0x41, 0xc1, 0xc8 } }, "F_VN_GetAt_TcVnVector2_INT", nullptr }, \
	{ { 0x75698c45, 0x3c77, 0x4310, { 0x93, 0x62, 0x77, 0x11, 0x20, 0x84, 0x73, 0xa4 } }, "F_VN_GetAt_TcVnVector2_REAL", nullptr }, \
	{ { 0x4619bb5b, 0x3dd7, 0x4799, { 0x9d, 0x4c, 0x38, 0xc7, 0xc1, 0xd4, 0x09, 0x68 } }, "F_VN_GetAt_TcVnVector2_SINT", nullptr }, \
	{ { 0x27ca1b29, 0x38e0, 0x48a3, { 0xbf, 0x45, 0xb1, 0x02, 0x0c, 0x92, 0x07, 0xde } }, "F_VN_GetAt_TcVnVector2_UINT", nullptr }, \
	{ { 0x7777209b, 0x1909, 0x40ed, { 0xbe, 0x36, 0x8d, 0x36, 0x2e, 0xa0, 0xe2, 0x5f } }, "F_VN_GetAt_TcVnVector2_USINT", nullptr }, \
	{ { 0xb53261a0, 0xce7c, 0x44c3, { 0xa7, 0xa7, 0xda, 0xd0, 0x4b, 0xbd, 0x9e, 0xb7 } }, "F_VN_GetAt_TcVnVector3_INT", nullptr }, \
	{ { 0x097ebacc, 0xe2f1, 0x465b, { 0xac, 0xad, 0x50, 0x63, 0x65, 0xf7, 0xa3, 0xac } }, "F_VN_GetAt_TcVnVector3_REAL", nullptr }, \
	{ { 0x1562a261, 0x1b4b, 0x4914, { 0xad, 0x73, 0x5b, 0xea, 0x9b, 0x03, 0x2d, 0x5e } }, "F_VN_GetAt_TcVnVector3_SINT", nullptr }, \
	{ { 0xd5f9893c, 0x165c, 0x4cee, { 0x80, 0xb7, 0xdd, 0xf1, 0x59, 0x9f, 0xa4, 0x5e } }, "F_VN_GetAt_TcVnVector3_UINT", nullptr }, \
	{ { 0x8c9a8567, 0xed21, 0x4dd1, { 0x99, 0x4d, 0x1d, 0xf6, 0xf7, 0xdd, 0x38, 0xcf } }, "F_VN_GetAt_TcVnVector3_USINT", nullptr }, \
	{ { 0x0c29f244, 0x1337, 0x44ac, { 0x9c, 0x46, 0x70, 0xf7, 0x44, 0x2c, 0xe8, 0xae } }, "F_VN_GetAt_TcVnVector4_DINT", nullptr }, \
	{ { 0x8db50cb5, 0x39bb, 0x4eae, { 0xa4, 0x02, 0xd5, 0x46, 0x8b, 0x6b, 0x37, 0x89 } }, "F_VN_GetAt_TcVnVector4_INT", nullptr }, \
	{ { 0x25ef0899, 0x8127, 0x440d, { 0x9c, 0x7f, 0xf6, 0x52, 0x68, 0x1d, 0x82, 0xc2 } }, "F_VN_GetAt_TcVnVector4_LREAL", nullptr }, \
	{ { 0x77b9e065, 0x3a6f, 0x4d3a, { 0x9f, 0x65, 0xd7, 0x43, 0xf3, 0xe1, 0x11, 0x3a } }, "F_VN_GetAt_TcVnVector4_REAL", nullptr }, \
	{ { 0x5d02d52b, 0xd66f, 0x493c, { 0xab, 0x9e, 0xcd, 0xed, 0x6a, 0xec, 0x66, 0xee } }, "F_VN_GetAt_TcVnVector4_SINT", nullptr }, \
	{ { 0xdb2e2bb7, 0x4d81, 0x482d, { 0x9e, 0x09, 0x46, 0x29, 0x3a, 0x82, 0x4f, 0x63 } }, "F_VN_GetAt_TcVnVector4_UINT", nullptr }, \
	{ { 0xb1a8dd2d, 0xe99c, 0x48be, { 0x85, 0x9a, 0xf1, 0xd3, 0xf0, 0x72, 0xe6, 0x42 } }, "F_VN_GetAt_TcVnVector4_USINT", nullptr }, \
	{ { 0xbe7391aa, 0xa5b4, 0x4499, { 0xaa, 0xf8, 0x1b, 0xc2, 0xfa, 0x2e, 0x31, 0x6f } }, "F_VN_GetAt_UDINT", nullptr }, \
	{ { 0xd513dcbd, 0xb4a1, 0x48b8, { 0x8c, 0xf4, 0xb1, 0x63, 0x4a, 0xb1, 0xdd, 0x67 } }, "F_VN_GetAt_UINT", nullptr }, \
	{ { 0xbd544779, 0x2c6f, 0x49ce, { 0xab, 0x3d, 0xcb, 0xa2, 0x12, 0xf3, 0xbc, 0x7e } }, "F_VN_GetAt_ULINT", nullptr }, \
	{ { 0x3fadd0c1, 0xb0bc, 0x4a29, { 0xbb, 0x6f, 0x39, 0x20, 0xf4, 0xf8, 0xec, 0x6f } }, "F_VN_GetAt_USINT", nullptr }, \
	{ { 0xe158cab8, 0x28a5, 0x4b55, { 0xa9, 0x3e, 0x5c, 0xf8, 0xe9, 0x24, 0xa4, 0x6c } }, "F_VN_GetConnectedComponentExp", nullptr }, \
	{ { 0x26b458f6, 0x1c5e, 0x4b31, { 0x95, 0xbb, 0x53, 0xe3, 0x4e, 0x8b, 0xfe, 0x11 } }, "F_VN_GetContainer", nullptr }, \
	{ { 0x4288f27b, 0x71a3, 0x4b8f, { 0xbf, 0x7b, 0x58, 0x2e, 0xe4, 0x2c, 0x8e, 0xf1 } }, "F_VN_GetContainerExp", nullptr }, \
	{ { 0x42e38ce8, 0xd541, 0x4d2f, { 0x86, 0x27, 0x6b, 0xa0, 0xba, 0xde, 0x9d, 0xb8 } }, "F_VN_GetForwardIterator", nullptr }, \
	{ { 0x6f2a698d, 0x6b0d, 0x46ca, { 0xa3, 0x85, 0x81, 0xed, 0x4b, 0x34, 0x03, 0x44 } }, "F_VN_GetImageChannel", nullptr }, \
	{ { 0x1feca9cc, 0x6c27, 0x45a2, { 0xad, 0xc6, 0x41, 0xc1, 0xc7, 0xe6, 0x7a, 0x1c } }, "F_VN_GetImageHeight", nullptr }, \
	{ { 0x5ea127da, 0x2843, 0x422e, { 0xbc, 0x28, 0x7b, 0x88, 0x71, 0x98, 0xa7, 0x6f } }, "F_VN_GetImageInfo", nullptr }, \
	{ { 0x270e55ab, 0x5915, 0x49a4, { 0xb1, 0x12, 0xda, 0xae, 0x47, 0x76, 0xe1, 0xf6 } }, "F_VN_GetImageWidth", nullptr }, \
	{ { 0xa865fc19, 0xef1b, 0x461a, { 0x89, 0x1a, 0xb7, 0x1a, 0xf9, 0xc1, 0xf9, 0x30 } }, "F_VN_GetLayoutInfo", nullptr }, \
	{ { 0xc08c4990, 0x49a9, 0x4a93, { 0xb5, 0x20, 0xe9, 0x2b, 0x6e, 0x3b, 0xa0, 0xf3 } }, "F_VN_GetNumberOfElements", nullptr }, \
	{ { 0x62f12f9e, 0x4570, 0x4087, { 0xb4, 0x31, 0xbc, 0xd0, 0x38, 0x4a, 0x15, 0xb6 } }, "F_VN_GetPerspectiveTransformation", nullptr }, \
	{ { 0x25e75993, 0x5744, 0x43c4, { 0xa6, 0x4b, 0x61, 0x43, 0x60, 0x7e, 0xf1, 0xd3 } }, "F_VN_GetPixel", nullptr }, \
	{ { 0xaeef5c65, 0x7b31, 0x442c, { 0x9e, 0x43, 0x8b, 0x4a, 0xbd, 0x33, 0xd7, 0x50 } }, "F_VN_GetPixelFormat", nullptr }, \
	{ { 0x3e4d20d8, 0xe518, 0x4076, { 0xb0, 0xa1, 0xf5, 0x1b, 0x09, 0x6d, 0x55, 0xbd } }, "F_VN_GetRandomAccessIterator", nullptr }, \
	{ { 0x6d4bc9c0, 0xd1a4, 0x402b, { 0xa5, 0x39, 0x03, 0x1b, 0xb9, 0x29, 0x0a, 0x1a } }, "F_VN_GetRoi", nullptr }, \
	{ { 0xd470b0ca, 0x252b, 0x46e3, { 0x8c, 0x9f, 0xfb, 0x61, 0x65, 0x9e, 0x32, 0x56 } }, "F_VN_GetTimestamp", nullptr }, \
	{ { 0x0ee7184d, 0x16cb, 0x4389, { 0xad, 0x0d, 0xcf, 0xcf, 0xc0, 0xb1, 0x21, 0x29 } }, "F_VN_HistogramExp", nullptr }, \
	{ { 0x421e12cd, 0xa09d, 0x4e5c, { 0xbd, 0xdd, 0x3d, 0x9d, 0x93, 0xb8, 0x37, 0x72 } }, "F_VN_HistogramEqualizationExp", nullptr }, \
	{ { 0x33845a60, 0xab69, 0x4f25, { 0xbb, 0x2d, 0x4e, 0x9e, 0x41, 0xb6, 0x32, 0x2e } }, "F_VN_HomographyExp", nullptr }, \
	{ { 0x172331b9, 0xdb90, 0x4faf, { 0x99, 0x9a, 0x47, 0x21, 0x8b, 0x0a, 0x89, 0x89 } }, "F_VN_HoughCirclesExp", nullptr }, \
	{ { 0xba609302, 0x420d, 0x4903, { 0x81, 0x80, 0x01, 0xc3, 0x6d, 0x94, 0xd6, 0x3c } }, "F_VN_HoughLinesExp", nullptr }, \
	{ { 0xc9ca452e, 0xf9c4, 0x42e8, { 0x86, 0xb4, 0x72, 0x60, 0xdc, 0xcc, 0xc4, 0xa7 } }, "F_VN_HoughLinesPExp", nullptr }, \
	{ { 0xae9787c2, 0xbf6f, 0x4a13, { 0x8c, 0x0b, 0x3d, 0x94, 0x36, 0xa0, 0xcd, 0xae } }, "F_VN_HuMomentInvariants", nullptr }, \
	{ { 0xa3ae6d98, 0xa3b6, 0x46c0, { 0x80, 0xa5, 0xd4, 0x5d, 0xbe, 0x5f, 0x63, 0xe2 } }, "F_VN_ImageAbsoluteAverage", nullptr }, \
	{ { 0xb7a71d9e, 0xe400, 0x4cae, { 0xbd, 0x42, 0x25, 0xf8, 0xfd, 0x07, 0x89, 0xf8 } }, "F_VN_ImageAverageExp", nullptr }, \
	{ { 0x0f183032, 0xfda8, 0x4272, { 0xbd, 0x43, 0xfc, 0xb7, 0xdf, 0xc2, 0x16, 0x80 } }, "F_VN_ImageAverageStdDevExp", nullptr }, \
	{ { 0xd06da3c7, 0xdb1b, 0x42e7, { 0xbc, 0xf3, 0xcf, 0x60, 0x33, 0x03, 0xe5, 0x0d } }, "F_VN_ImageCenterOfMassExp", nullptr }, \
	{ { 0xfdbca763, 0x8e68, 0x4bfa, { 0xbb, 0x34, 0x53, 0x7b, 0x89, 0x7b, 0x35, 0x28 } }, "F_VN_ImageMedianExp", nullptr }, \
	{ { 0x6f662031, 0xa977, 0x47ec, { 0x99, 0x73, 0xa6, 0x87, 0xcf, 0x8e, 0x86, 0xb7 } }, "F_VN_ImageMoments", nullptr }, \
	{ { 0x6845693e, 0xdda5, 0x46d2, { 0xa0, 0xa6, 0x4a, 0xe0, 0x81, 0xa0, 0x46, 0xbe } }, "F_VN_IncrementIterator", nullptr }, \
	{ { 0x958f479e, 0x8bea, 0x4b5e, { 0x8b, 0xca, 0x09, 0x21, 0x26, 0x49, 0xfd, 0x04 } }, "F_VN_InitMatrixStruct", nullptr }, \
	{ { 0x9593bc44, 0xa11b, 0x47fb, { 0x8b, 0x76, 0x68, 0xff, 0x00, 0xf5, 0x6e, 0x98 } }, "F_VN_InsertIntoContainer_DINT", nullptr }, \
	{ { 0x6db7fded, 0xee2b, 0x43bc, { 0x9c, 0xad, 0x11, 0x9f, 0x3a, 0x06, 0x15, 0xb8 } }, "F_VN_InsertIntoContainer_INT", nullptr }, \
	{ { 0xa7efdd8c, 0x6627, 0x44cb, { 0x99, 0x7a, 0x8b, 0x7e, 0x5e, 0x0c, 0x07, 0x9d } }, "F_VN_InsertIntoContainer_ITcVnContainer", nullptr }, \
	{ { 0xfa913a2b, 0x3532, 0x4269, { 0x9d, 0x55, 0x7e, 0x67, 0x15, 0x33, 0x47, 0x9e } }, "F_VN_InsertIntoContainer_ITcVnForwardIterator", nullptr }, \
	{ { 0x806ead89, 0xe4dc, 0x4ca2, { 0xa0, 0x8e, 0x1b, 0x76, 0xc1, 0xb1, 0x15, 0x49 } }, "F_VN_InsertIntoContainer_ITcVnImage", nullptr }, \
	{ { 0x088b56e2, 0xbdcf, 0x46bf, { 0x91, 0x56, 0x0b, 0xee, 0x74, 0xfc, 0x08, 0x66 } }, "F_VN_InsertIntoContainer_LREAL", nullptr }, \
	{ { 0x4495800f, 0x4f7f, 0x4760, { 0x85, 0x4d, 0x65, 0x9d, 0xfe, 0x96, 0x6c, 0xb0 } }, "F_VN_InsertIntoContainer_REAL", nullptr }, \
	{ { 0xa61b547d, 0xdc1a, 0x400b, { 0x8b, 0xae, 0xa3, 0x85, 0xea, 0xbf, 0x65, 0xc2 } }, "F_VN_InsertIntoContainer_SINT", nullptr }, \
	{ { 0x18bba1f2, 0xce68, 0x4f50, { 0xad, 0x30, 0x23, 0xd7, 0x3e, 0xa9, 0xa2, 0xf8 } }, "F_VN_InsertIntoContainer_TcVnDMatch", nullptr }, \
	{ { 0xcc177671, 0x0c03, 0x42f4, { 0xa0, 0xda, 0xd5, 0x06, 0x2e, 0x0a, 0x3d, 0x96 } }, "F_VN_InsertIntoContainer_TcVnKeyPoint", nullptr }, \
	{ { 0x8f7a84be, 0x3380, 0x4465, { 0xb4, 0xe9, 0x01, 0xba, 0x65, 0xb6, 0x38, 0x68 } }, "F_VN_InsertIntoContainer_TcVnPoint2_DINT", nullptr }, \
	{ { 0x7501ef49, 0x1bd7, 0x4e4d, { 0xa2, 0x38, 0x37, 0x32, 0xdf, 0xd2, 0xe4, 0xda } }, "F_VN_InsertIntoContainer_TcVnPoint2_LREAL", nullptr }, \
	{ { 0x084cf95f, 0x440c, 0x46ce, { 0x89, 0xdc, 0x85, 0xbc, 0x20, 0xa8, 0x9f, 0x68 } }, "F_VN_InsertIntoContainer_TcVnPoint2_REAL", nullptr }, \
	{ { 0x7d403c97, 0x3f8b, 0x4edc, { 0x84, 0x93, 0x4f, 0x1e, 0x85, 0xb6, 0x3b, 0x38 } }, "F_VN_InsertIntoContainer_TcVnPoint3_LREAL", nullptr }, \
	{ { 0x1c507102, 0x06a9, 0x4057, { 0xa0, 0x95, 0x82, 0x6a, 0xbf, 0xaa, 0xf9, 0xde } }, "F_VN_InsertIntoContainer_TcVnPoint3_REAL", nullptr }, \
	{ { 0x170f29d1, 0xf599, 0x4e09, { 0x98, 0x3a, 0xc6, 0xed, 0xed, 0xd1, 0xcf, 0x46 } }, "F_VN_InsertIntoContainer_TcVnRectangle_DINT", nullptr }, \
	{ { 0xf52a2c4f, 0xc655, 0x47a9, { 0xac, 0x6b, 0xa4, 0xa6, 0xeb, 0xb2, 0x78, 0x91 } }, "F_VN_InsertIntoContainer_TcVnRotatedRectangle", nullptr }, \
	{ { 0xece072d0, 0xb14a, 0x4f47, { 0x9d, 0x79, 0x0a, 0x41, 0x89, 0xe8, 0x80, 0x08 } }, "F_VN_InsertIntoContainer_TcVnVector2_DINT", nullptr }, \
	{ { 0x93c26a0e, 0x61ba, 0x41c9, { 0xa2, 0x98, 0xb5, 0x32, 0x80, 0x62, 0xc5, 0x62 } }, "F_VN_InsertIntoContainer_TcVnVector2_INT", nullptr }, \
	{ { 0x9d725aa6, 0x2f61, 0x48cd, { 0x8a, 0x29, 0xd4, 0xdc, 0x6d, 0xfa, 0x43, 0x7d } }, "F_VN_InsertIntoContainer_TcVnVector2_REAL", nullptr }, \
	{ { 0xc62003bc, 0x97b1, 0x4739, { 0xbc, 0x8d, 0xbf, 0xb8, 0x3a, 0xf4, 0x0b, 0x84 } }, "F_VN_InsertIntoContainer_TcVnVector2_SINT", nullptr }, \
	{ { 0x62f9167c, 0x79c9, 0x4c69, { 0x96, 0xad, 0x56, 0x88, 0x50, 0xe1, 0x5f, 0xa3 } }, "F_VN_InsertIntoContainer_TcVnVector2_UINT", nullptr }, \
	{ { 0xe12b9911, 0x91a4, 0x43d9, { 0xa9, 0x39, 0x39, 0x54, 0xf3, 0x55, 0x40, 0x3d } }, "F_VN_InsertIntoContainer_TcVnVector2_USINT", nullptr }, \
	{ { 0x2fd280b2, 0xabf3, 0x4369, { 0x98, 0xc7, 0x9e, 0x22, 0x0c, 0xe2, 0x93, 0xdf } }, "F_VN_InsertIntoContainer_TcVnVector3_INT", nullptr }, \
	{ { 0x042275cb, 0x8d98, 0x4b7d, { 0x91, 0x5c, 0x26, 0x96, 0xa1, 0xfb, 0xbd, 0x9d } }, "F_VN_InsertIntoContainer_TcVnVector3_REAL", nullptr }, \
	{ { 0x168e8dde, 0xf76b, 0x4a7e, { 0xa4, 0x39, 0x6f, 0x6e, 0xaa, 0xfa, 0xb6, 0x52 } }, "F_VN_InsertIntoContainer_TcVnVector3_SINT", nullptr }, \
	{ { 0x21c6e0ea, 0x4e27, 0x4d43, { 0x92, 0xff, 0xce, 0x83, 0x52, 0x6b, 0x2e, 0xdd } }, "F_VN_InsertIntoContainer_TcVnVector3_UINT", nullptr }, \
	{ { 0x48929c58, 0x2214, 0x4725, { 0xb0, 0x10, 0xa2, 0xcf, 0x6c, 0x15, 0x73, 0x23 } }, "F_VN_InsertIntoContainer_TcVnVector3_USINT", nullptr }, \
	{ { 0x30099d68, 0xb690, 0x4f2b, { 0xa1, 0xa3, 0x4a, 0x71, 0xdf, 0x0e, 0xe3, 0x85 } }, "F_VN_InsertIntoContainer_TcVnVector4_DINT", nullptr }, \
	{ { 0xece7a5ef, 0x5b22, 0x4e9b, { 0xa8, 0xee, 0x89, 0x18, 0x60, 0x6a, 0xae, 0xd7 } }, "F_VN_InsertIntoContainer_TcVnVector4_INT", nullptr }, \
	{ { 0x77d0f0ac, 0x6a9c, 0x48e3, { 0x9f, 0x4b, 0x20, 0x76, 0x7a, 0x97, 0x98, 0x1f } }, "F_VN_InsertIntoContainer_TcVnVector4_LREAL", nullptr }, \
	{ { 0xd142ea55, 0xe4af, 0x493a, { 0xb6, 0x00, 0x40, 0x24, 0x9f, 0x4f, 0x47, 0x8f } }, "F_VN_InsertIntoContainer_TcVnVector4_REAL", nullptr }, \
	{ { 0x6c19187b, 0x8048, 0x4de5, { 0xbc, 0xd8, 0x41, 0x5d, 0x00, 0x01, 0x2f, 0xe5 } }, "F_VN_InsertIntoContainer_TcVnVector4_SINT", nullptr }, \
	{ { 0xdb2b46fa, 0x954e, 0x49fc, { 0xbf, 0xb4, 0x82, 0x8d, 0x80, 0x37, 0xff, 0x15 } }, "F_VN_InsertIntoContainer_TcVnVector4_UINT", nullptr }, \
	{ { 0x049eb197, 0x2485, 0x442d, { 0xbb, 0x26, 0x48, 0x36, 0xda, 0xaf, 0x17, 0xaf } }, "F_VN_InsertIntoContainer_TcVnVector4_USINT", nullptr }, \
	{ { 0xcce2acf5, 0x4ed2, 0x4371, { 0xa1, 0x61, 0x78, 0x1f, 0x98, 0x07, 0x80, 0xe3 } }, "F_VN_InsertIntoContainer_UDINT", nullptr }, \
	{ { 0xe2cf6a0f, 0xf4b4, 0x4829, { 0xa3, 0xcf, 0xb2, 0x34, 0xa9, 0x16, 0xbe, 0x60 } }, "F_VN_InsertIntoContainer_UINT", nullptr }, \
	{ { 0x779bc59a, 0xe256, 0x42d0, { 0xa3, 0x7e, 0x2f, 0xfc, 0x8c, 0x36, 0x27, 0x13 } }, "F_VN_InsertIntoContainer_ULINT", nullptr }, \
	{ { 0x21d9b623, 0x2d66, 0x4d1f, { 0x82, 0xb2, 0x17, 0xb3, 0xfd, 0x89, 0x01, 0x9b } }, "F_VN_InsertIntoContainer_USINT", nullptr }, \
	{ { 0xc01bc3c7, 0xcaa1, 0x4558, { 0xaa, 0x0b, 0x3c, 0x01, 0xf1, 0x58, 0x3b, 0x0c } }, "F_VN_InverseDft", nullptr }, \
	{ { 0x3a2caec5, 0x7d99, 0x469d, { 0xb4, 0x79, 0x09, 0x1a, 0x8f, 0x56, 0x1f, 0xa1 } }, "F_VN_InvertAffineTransformation", nullptr }, \
	{ { 0x1460f4e5, 0xa41e, 0x4e3a, { 0xad, 0xb3, 0x1f, 0x4b, 0xbb, 0x1e, 0x29, 0x95 } }, "F_VN_InvertImageColorExp", nullptr }, \
	{ { 0xfab64915, 0xb208, 0x4c67, { 0xb3, 0x45, 0xa4, 0x3a, 0x3d, 0x76, 0x5d, 0xe5 } }, "F_VN_InvertMatrix3x3", nullptr }, \
	{ { 0xddf43ab3, 0xfb95, 0x4489, { 0x9f, 0xaf, 0x0e, 0x1d, 0xf7, 0xe4, 0x8f, 0x28 } }, "F_VN_IteratorDistance", nullptr }, \
	{ { 0x79d8eae2, 0x58c2, 0x4d7c, { 0x81, 0xf6, 0xbf, 0x62, 0x48, 0x58, 0x66, 0xca } }, "F_VN_LaplacianFilterExp", nullptr }, \
	{ { 0x1bd9e0cf, 0x97fc, 0x4f94, { 0x84, 0xe2, 0x8e, 0xe4, 0x66, 0x1d, 0xf0, 0x90 } }, "F_VN_LineIntersectionPoint", nullptr }, \
	{ { 0x10ab1ee9, 0xed43, 0x4e41, { 0x83, 0xc3, 0x70, 0x62, 0x11, 0x49, 0x24, 0xa9 } }, "F_VN_LineIntersectionPointAndAngle", nullptr }, \
	{ { 0xfa6401fb, 0x1076, 0x451e, { 0xbb, 0x1a, 0xca, 0x8a, 0x09, 0x5e, 0x3e, 0xda } }, "F_VN_LocalMaxima", nullptr }, \
	{ { 0xca346f66, 0x8bf4, 0x4e8e, { 0xab, 0xd7, 0x47, 0x9f, 0xd8, 0x1b, 0xfe, 0x35 } }, "F_VN_LocalMinima", nullptr }, \
	{ { 0x8603ad5b, 0xd90e, 0x47cd, { 0x95, 0xb0, 0x6f, 0xe8, 0x6b, 0xf6, 0xa9, 0xa4 } }, "F_VN_MaxContainer", nullptr }, \
	{ { 0x02d8ba2d, 0x7c6b, 0x4d88, { 0xaf, 0xaa, 0xca, 0x9f, 0xf3, 0x34, 0x3d, 0x1e } }, "F_VN_MaxElement", nullptr }, \
	{ { 0xb3b9bda2, 0x80e8, 0x484c, { 0xa9, 0x31, 0x42, 0x78, 0x42, 0x57, 0x8f, 0x0e } }, "F_VN_MaxElementElementwise_DINT", nullptr }, \
	{ { 0x87b03015, 0x352b, 0x4be7, { 0x92, 0xd4, 0x02, 0x80, 0x7b, 0xf5, 0xfd, 0xde } }, "F_VN_MaxElementElementwise_INT", nullptr }, \
	{ { 0x500dc4c1, 0x270c, 0x4720, { 0x93, 0x47, 0xc3, 0xcf, 0xd5, 0xfd, 0x5f, 0xa0 } }, "F_VN_MaxElementElementwise_LREAL", nullptr }, \
	{ { 0x3bfc7034, 0xb36d, 0x4a03, { 0x9e, 0x47, 0x28, 0x7c, 0x54, 0xd0, 0x85, 0x2e } }, "F_VN_MaxElementElementwise_REAL", nullptr }, \
	{ { 0xc56d5b61, 0x6f5f, 0x450f, { 0xb9, 0x64, 0x65, 0xf0, 0xd3, 0x7d, 0xb4, 0xd4 } }, "F_VN_MaxElementElementwise_SINT", nullptr }, \
	{ { 0xb98ab73b, 0xa4af, 0x490d, { 0x8b, 0x62, 0x8a, 0x52, 0x19, 0x16, 0x82, 0x0d } }, "F_VN_MaxElementElementwise_TcVnPoint2_DINT", nullptr }, \
	{ { 0xb7eafa17, 0xe86c, 0x499c, { 0xae, 0x14, 0x2c, 0xe6, 0xfc, 0x08, 0x07, 0xbd } }, "F_VN_MaxElementElementwise_TcVnPoint2_LREAL", nullptr }, \
	{ { 0x1c13f811, 0x3f12, 0x4af8, { 0x8c, 0x9e, 0x4f, 0x34, 0x61, 0x95, 0x4b, 0x29 } }, "F_VN_MaxElementElementwise_TcVnPoint2_REAL", nullptr }, \
	{ { 0x18469dc9, 0x89dd, 0x44e5, { 0xaf, 0xde, 0xbc, 0x49, 0x00, 0x0e, 0xed, 0x8f } }, "F_VN_MaxElementElementwise_TcVnPoint3_LREAL", nullptr }, \
	{ { 0xef9b8a3b, 0x1edb, 0x4549, { 0xa8, 0xf5, 0x9c, 0x37, 0xe9, 0xca, 0x7c, 0x42 } }, "F_VN_MaxElementElementwise_TcVnPoint3_REAL", nullptr }, \
	{ { 0xd1e5010a, 0x7383, 0x4302, { 0xb8, 0x42, 0x65, 0x53, 0x77, 0xe7, 0x93, 0xc7 } }, "F_VN_MaxElementElementwise_TcVnVector2_DINT", nullptr }, \
	{ { 0xd86a4dfe, 0x25a5, 0x498f, { 0xa4, 0xce, 0xe4, 0x59, 0xec, 0x80, 0x28, 0x57 } }, "F_VN_MaxElementElementwise_TcVnVector2_INT", nullptr }, \
	{ { 0xbf792e1c, 0x9635, 0x4fc4, { 0xb8, 0xd3, 0x3c, 0x57, 0x49, 0xfa, 0x36, 0x3c } }, "F_VN_MaxElementElementwise_TcVnVector2_REAL", nullptr }, \
	{ { 0x3ba49006, 0xe0a5, 0x42ae, { 0x9e, 0x97, 0x00, 0x4a, 0xc6, 0x88, 0x7a, 0xff } }, "F_VN_MaxElementElementwise_TcVnVector2_SINT", nullptr }, \
	{ { 0xa97973c8, 0x4d97, 0x4880, { 0x9f, 0x63, 0x16, 0x13, 0x80, 0x74, 0x6a, 0xfb } }, "F_VN_MaxElementElementwise_TcVnVector2_UINT", nullptr }, \
	{ { 0xfc11bb89, 0xc7ac, 0x4ea7, { 0x9e, 0x55, 0x8a, 0x63, 0x47, 0x3f, 0x7b, 0x96 } }, "F_VN_MaxElementElementwise_TcVnVector2_USINT", nullptr }, \
	{ { 0x0b870017, 0x145c, 0x42ac, { 0x80, 0x59, 0x96, 0x6d, 0xf5, 0xbe, 0x81, 0xf0 } }, "F_VN_MaxElementElementwise_TcVnVector3_INT", nullptr }, \
	{ { 0x8831faf6, 0xb60b, 0x4ea0, { 0x8b, 0x3d, 0x44, 0x11, 0x72, 0x31, 0x7b, 0xac } }, "F_VN_MaxElementElementwise_TcVnVector3_REAL", nullptr }, \
	{ { 0xeb7a1829, 0xa5f4, 0x4fa9, { 0x9f, 0x3a, 0x51, 0x28, 0x02, 0x16, 0xc2, 0xea } }, "F_VN_MaxElementElementwise_TcVnVector3_SINT", nullptr }, \
	{ { 0x9e4c8bda, 0xbca1, 0x4293, { 0xb0, 0xd3, 0xe0, 0xb4, 0x36, 0x6f, 0x7e, 0x96 } }, "F_VN_MaxElementElementwise_TcVnVector3_UINT", nullptr }, \
	{ { 0x43cc7720, 0xd0b4, 0x4c18, { 0x83, 0xbd, 0xb1, 0x8f, 0x33, 0x44, 0x73, 0xc1 } }, "F_VN_MaxElementElementwise_TcVnVector3_USINT", nullptr }, \
	{ { 0x44b43507, 0x3847, 0x4778, { 0xa5, 0x2d, 0xe4, 0xae, 0x23, 0x5d, 0x3c, 0xe3 } }, "F_VN_MaxElementElementwise_TcVnVector4_DINT", nullptr }, \
	{ { 0x96a0f972, 0x36f6, 0x4579, { 0x9b, 0xef, 0x40, 0x6f, 0x08, 0x7f, 0x7a, 0xac } }, "F_VN_MaxElementElementwise_TcVnVector4_INT", nullptr }, \
	{ { 0x7e80c01e, 0xefaf, 0x4867, { 0x93, 0xf6, 0x57, 0x02, 0x8c, 0x7a, 0x44, 0xf8 } }, "F_VN_MaxElementElementwise_TcVnVector4_LREAL", nullptr }, \
	{ { 0x2e33e770, 0xf603, 0x44e7, { 0xa9, 0x36, 0xf6, 0x56, 0x73, 0x76, 0x0f, 0x02 } }, "F_VN_MaxElementElementwise_TcVnVector4_REAL", nullptr }, \
	{ { 0x32313d9e, 0x6380, 0x427d, { 0x84, 0xa4, 0xfd, 0x6b, 0xd4, 0x0a, 0x08, 0xdd } }, "F_VN_MaxElementElementwise_TcVnVector4_SINT", nullptr }, \
	{ { 0xec6bc2ee, 0x486b, 0x4ff3, { 0x9b, 0x13, 0x33, 0x6e, 0xe1, 0xad, 0x3e, 0x16 } }, "F_VN_MaxElementElementwise_TcVnVector4_UINT", nullptr }, \
	{ { 0x15b219d4, 0x93a9, 0x4501, { 0xba, 0x32, 0x33, 0xf9, 0x7d, 0xa8, 0x0b, 0x09 } }, "F_VN_MaxElementElementwise_TcVnVector4_USINT", nullptr }, \
	{ { 0xa6cd35d4, 0xa80c, 0x4cb2, { 0x88, 0x7f, 0x5e, 0xff, 0x77, 0x85, 0xef, 0xce } }, "F_VN_MaxElementElementwise_UDINT", nullptr }, \
	{ { 0xa503bd4b, 0x8583, 0x4f24, { 0xae, 0x36, 0xa6, 0xd7, 0x04, 0xa7, 0x53, 0x15 } }, "F_VN_MaxElementElementwise_UINT", nullptr }, \
	{ { 0xf0d1eed8, 0x07b7, 0x487c, { 0x82, 0x28, 0x07, 0xe4, 0x10, 0x27, 0xfe, 0xb8 } }, "F_VN_MaxElementElementwise_ULINT", nullptr }, \
	{ { 0xec6343a9, 0x20f4, 0x4c9e, { 0x92, 0x7e, 0x22, 0x93, 0x5c, 0x06, 0x55, 0x8c } }, "F_VN_MaxElementElementwise_USINT", nullptr }, \
	{ { 0x0bb21c7a, 0xb351, 0x4b8d, { 0xb0, 0x68, 0xd8, 0x66, 0x58, 0x34, 0x1b, 0x47 } }, "F_VN_MaxImage", nullptr }, \
	{ { 0x05ff8967, 0x7960, 0x404f, { 0x97, 0xad, 0x76, 0x37, 0xb0, 0x60, 0x2b, 0x9f } }, "F_VN_MaxImageExp", nullptr }, \
	{ { 0x5e72688d, 0x117b, 0x47f8, { 0x86, 0xef, 0xa2, 0xc8, 0xb9, 0x40, 0x87, 0x93 } }, "F_VN_MaxImageWithScalar", nullptr }, \
	{ { 0x2e41c340, 0xfef9, 0x4938, { 0x80, 0x87, 0x2b, 0xdd, 0x04, 0xc7, 0x6e, 0x01 } }, "F_VN_MaxImageWithScalarExp", nullptr }, \
	{ { 0xbc03e782, 0xc2a7, 0x40ba, { 0x9e, 0x4d, 0x15, 0x18, 0x02, 0x8f, 0xcd, 0xf0 } }, "F_VN_MaxImageWithVector", nullptr }, \
	{ { 0xacee8440, 0x5de7, 0x4ad0, { 0x9f, 0x39, 0xd9, 0xe6, 0x39, 0x19, 0xfa, 0x3f } }, "F_VN_MaxImageWithVectorExp", nullptr }, \
	{ { 0x94f83cee, 0xe102, 0x4f8c, { 0xa0, 0x0f, 0x67, 0xd2, 0x1b, 0xaf, 0xcd, 0xca } }, "F_VN_MaxPixelValueExp", nullptr }, \
	{ { 0xe2cd05ae, 0x682a, 0x43cd, { 0xb4, 0xd7, 0x6a, 0x0a, 0x49, 0x17, 0x1e, 0x17 } }, "F_VN_MedianElement", nullptr }, \
	{ { 0xa02c38d4, 0x8ea8, 0x4e1d, { 0x99, 0x4b, 0x79, 0x76, 0x91, 0xdc, 0x8a, 0xcd } }, "F_VN_MedianElementElementwise_DINT", nullptr }, \
	{ { 0x428c79dc, 0x8909, 0x4b16, { 0x95, 0x61, 0xd5, 0xb5, 0x4b, 0x6d, 0xca, 0xbc } }, "F_VN_MedianElementElementwise_INT", nullptr }, \
	{ { 0x3ce7a0f7, 0xf100, 0x45a8, { 0xba, 0x23, 0xb2, 0xa9, 0xb6, 0x42, 0x87, 0x31 } }, "F_VN_MedianElementElementwise_LREAL", nullptr }, \
	{ { 0xa858474f, 0xf501, 0x45de, { 0x9d, 0x0f, 0x24, 0x71, 0x8c, 0xd0, 0x6c, 0x79 } }, "F_VN_MedianElementElementwise_REAL", nullptr }, \
	{ { 0x2eede02e, 0x6f42, 0x415c, { 0xb0, 0xc3, 0xd0, 0x41, 0x75, 0xe8, 0x98, 0x97 } }, "F_VN_MedianElementElementwise_SINT", nullptr }, \
	{ { 0x2adf9225, 0x2f8f, 0x4e97, { 0x95, 0x23, 0xc0, 0x49, 0x43, 0x12, 0x17, 0xfa } }, "F_VN_MedianElementElementwise_TcVnPoint2_DINT", nullptr }, \
	{ { 0xd12c79b3, 0x3124, 0x4912, { 0x8c, 0x87, 0x45, 0xa6, 0xe6, 0x99, 0x9d, 0x28 } }, "F_VN_MedianElementElementwise_TcVnPoint2_LREAL", nullptr }, \
	{ { 0x71d5cdee, 0x42b9, 0x40c7, { 0xbf, 0xb3, 0x0c, 0x38, 0x22, 0x3b, 0x5c, 0x28 } }, "F_VN_MedianElementElementwise_TcVnPoint2_REAL", nullptr }, \
	{ { 0x78cc8de7, 0x498f, 0x4e7c, { 0x8a, 0x65, 0x30, 0x2c, 0x92, 0x5a, 0x5e, 0xa3 } }, "F_VN_MedianElementElementwise_TcVnPoint3_LREAL", nullptr }, \
	{ { 0xfce996a1, 0x1c05, 0x4def, { 0x85, 0xfb, 0xa4, 0xb1, 0x52, 0xdd, 0x3c, 0x50 } }, "F_VN_MedianElementElementwise_TcVnPoint3_REAL", nullptr }, \
	{ { 0x07c18b7e, 0xcc36, 0x49b5, { 0xb8, 0x7f, 0x49, 0xf2, 0xf0, 0xfc, 0x7f, 0x40 } }, "F_VN_MedianElementElementwise_TcVnVector2_DINT", nullptr }, \
	{ { 0xd25b8a37, 0xd964, 0x489d, { 0x87, 0x54, 0x62, 0xa0, 0x2a, 0x33, 0xb9, 0x6d } }, "F_VN_MedianElementElementwise_TcVnVector2_INT", nullptr }, \
	{ { 0x0f6f01c6, 0x8803, 0x4139, { 0xb0, 0x37, 0x8a, 0x59, 0x95, 0x18, 0x99, 0xe2 } }, "F_VN_MedianElementElementwise_TcVnVector2_REAL", nullptr }, \
	{ { 0x76a1a743, 0xc941, 0x49e3, { 0xa3, 0x6b, 0x7e, 0xa4, 0x14, 0xf4, 0x20, 0x7f } }, "F_VN_MedianElementElementwise_TcVnVector2_SINT", nullptr }, \
	{ { 0xf9dec9b7, 0x1475, 0x4a2d, { 0x8f, 0xbe, 0x87, 0x1a, 0x7b, 0xa1, 0x55, 0x29 } }, "F_VN_MedianElementElementwise_TcVnVector2_UINT", nullptr }, \
	{ { 0xacf6a481, 0x4ed4, 0x4a5b, { 0xbf, 0x06, 0x80, 0x08, 0x8d, 0xaa, 0x17, 0x1d } }, "F_VN_MedianElementElementwise_TcVnVector2_USINT", nullptr }, \
	{ { 0xc5506867, 0x926d, 0x4485, { 0x8d, 0x1b, 0x2b, 0x46, 0x73, 0x8a, 0x50, 0x85 } }, "F_VN_MedianElementElementwise_TcVnVector3_INT", nullptr }, \
	{ { 0xc71ff38f, 0xb24d, 0x4848, { 0xb5, 0x0b, 0xcd, 0xfe, 0xd6, 0x81, 0xa8, 0x0d } }, "F_VN_MedianElementElementwise_TcVnVector3_REAL", nullptr }, \
	{ { 0x18b16b59, 0x64d2, 0x445d, { 0xa3, 0x1d, 0x83, 0x21, 0x0a, 0x45, 0x16, 0xf1 } }, "F_VN_MedianElementElementwise_TcVnVector3_SINT", nullptr }, \
	{ { 0x21593114, 0x2dd0, 0x4eee, { 0xb3, 0x2a, 0x34, 0xc6, 0x2d, 0xd0, 0x0f, 0x25 } }, "F_VN_MedianElementElementwise_TcVnVector3_UINT", nullptr }, \
	{ { 0x850926b0, 0x60bc, 0x4600, { 0xbc, 0x6c, 0xcf, 0xc9, 0xa2, 0xfd, 0x13, 0x5f } }, "F_VN_MedianElementElementwise_TcVnVector3_USINT", nullptr }, \
	{ { 0xe62b1542, 0x6a93, 0x4346, { 0xb6, 0x29, 0xad, 0x12, 0x63, 0x64, 0x90, 0x31 } }, "F_VN_MedianElementElementwise_TcVnVector4_DINT", nullptr }, \
	{ { 0xddfd13c3, 0x0480, 0x4b7d, { 0xa1, 0xb0, 0x63, 0x98, 0x21, 0xfd, 0x9d, 0x59 } }, "F_VN_MedianElementElementwise_TcVnVector4_INT", nullptr }, \
	{ { 0xebe0bcac, 0x31f0, 0x48c9, { 0x89, 0x33, 0x22, 0x80, 0xc6, 0x66, 0x7f, 0xcc } }, "F_VN_MedianElementElementwise_TcVnVector4_LREAL", nullptr }, \
	{ { 0xc071e309, 0x5a7b, 0x4c7e, { 0xbd, 0x1b, 0x09, 0xcc, 0x0c, 0x73, 0xd8, 0xaf } }, "F_VN_MedianElementElementwise_TcVnVector4_REAL", nullptr }, \
	{ { 0xe8efed50, 0x7a6e, 0x457a, { 0xa1, 0x93, 0xac, 0x32, 0x2d, 0xb5, 0x4e, 0x6e } }, "F_VN_MedianElementElementwise_TcVnVector4_SINT", nullptr }, \
	{ { 0x8d3b0d49, 0x18fc, 0x4503, { 0xb4, 0x2d, 0x16, 0x2f, 0x9e, 0xa2, 0x07, 0xe3 } }, "F_VN_MedianElementElementwise_TcVnVector4_UINT", nullptr }, \
	{ { 0x4f94bb2b, 0x2436, 0x4bf6, { 0x8b, 0x63, 0x2b, 0xc8, 0xa3, 0x46, 0xf6, 0x8a } }, "F_VN_MedianElementElementwise_TcVnVector4_USINT", nullptr }, \
	{ { 0x124101c9, 0x5adf, 0x415f, { 0xb1, 0x48, 0xe5, 0x8b, 0x1e, 0x82, 0xa7, 0x8c } }, "F_VN_MedianElementElementwise_UDINT", nullptr }, \
	{ { 0x23f8baad, 0x4c27, 0x479f, { 0xaf, 0x9b, 0x10, 0x8b, 0xbc, 0xed, 0xc0, 0x72 } }, "F_VN_MedianElementElementwise_UINT", nullptr }, \
	{ { 0x074901fe, 0x65b9, 0x4ca7, { 0x89, 0xbf, 0x27, 0x38, 0x38, 0xff, 0xee, 0xec } }, "F_VN_MedianElementElementwise_ULINT", nullptr }, \
	{ { 0xa01236d4, 0xe3c9, 0x4e8c, { 0x9c, 0x23, 0x84, 0x2e, 0xe0, 0x1c, 0x7f, 0x6b } }, "F_VN_MedianElementElementwise_USINT", nullptr }, \
	{ { 0xe1277e1d, 0x1397, 0x456e, { 0xb0, 0x70, 0xd8, 0x4e, 0x17, 0x93, 0x97, 0x7d } }, "F_VN_MedianFilter", nullptr }, \
	{ { 0x0c6234d9, 0x3ca6, 0x41ad, { 0xae, 0x72, 0x44, 0xf9, 0xb1, 0x62, 0x27, 0x90 } }, "F_VN_MinContainer", nullptr }, \
	{ { 0x04e8e74d, 0x7846, 0x4fb8, { 0x8b, 0x98, 0x66, 0x9b, 0xb9, 0x26, 0x2b, 0x30 } }, "F_VN_MinElement", nullptr }, \
	{ { 0xf7d0cf4c, 0xf02b, 0x4573, { 0xa1, 0xf1, 0xe9, 0xda, 0xf6, 0xc5, 0xc5, 0x2c } }, "F_VN_MinElementElementwise_DINT", nullptr }, \
	{ { 0x823fefd5, 0x0d36, 0x4763, { 0x91, 0x65, 0x84, 0x1c, 0xcb, 0x13, 0x1e, 0xb1 } }, "F_VN_MinElementElementwise_INT", nullptr }, \
	{ { 0x48533654, 0xab7f, 0x4270, { 0xa9, 0xac, 0x05, 0x76, 0xd1, 0x0c, 0xc3, 0x82 } }, "F_VN_MinElementElementwise_LREAL", nullptr }, \
	{ { 0xcc80bbf5, 0xd602, 0x4de1, { 0x9c, 0x09, 0x31, 0x9c, 0x36, 0xe9, 0x6d, 0x8e } }, "F_VN_MinElementElementwise_REAL", nullptr }, \
	{ { 0xa78b1c38, 0x9e13, 0x49b8, { 0xa7, 0xdd, 0xb9, 0x0a, 0xb8, 0xec, 0xac, 0x29 } }, "F_VN_MinElementElementwise_SINT", nullptr }, \
	{ { 0x874ff066, 0x66a3, 0x4822, { 0xa0, 0x9c, 0x48, 0xe6, 0xc1, 0x82, 0x4e, 0x33 } }, "F_VN_MinElementElementwise_TcVnPoint2_DINT", nullptr }, \
	{ { 0x137ad2c1, 0x23b2, 0x4e85, { 0x9e, 0x75, 0x57, 0xfe, 0xa2, 0x19, 0x6f, 0xf3 } }, "F_VN_MinElementElementwise_TcVnPoint2_LREAL", nullptr }, \
	{ { 0xf34007d4, 0x7d60, 0x49fa, { 0xb0, 0x6b, 0x2e, 0xdf, 0xbf, 0x49, 0x00, 0x56 } }, "F_VN_MinElementElementwise_TcVnPoint2_REAL", nullptr }, \
	{ { 0x39ad7dea, 0xcb45, 0x4192, { 0xa9, 0xd2, 0x00, 0x30, 0x82, 0x1b, 0xd9, 0x9c } }, "F_VN_MinElementElementwise_TcVnPoint3_LREAL", nullptr }, \
	{ { 0x9fe83c93, 0x902c, 0x4f52, { 0x99, 0x97, 0x94, 0x79, 0x31, 0x32, 0x83, 0x73 } }, "F_VN_MinElementElementwise_TcVnPoint3_REAL", nullptr }, \
	{ { 0xc3769555, 0x09b8, 0x425b, { 0xba, 0x45, 0x87, 0x2b, 0x03, 0x85, 0x5c, 0x8a } }, "F_VN_MinElementElementwise_TcVnVector2_DINT", nullptr }, \
	{ { 0xd8188b97, 0xc435, 0x427c, { 0xbb, 0xec, 0x19, 0xe5, 0x30, 0xd8, 0xed, 0xfd } }, "F_VN_MinElementElementwise_TcVnVector2_INT", nullptr }, \
	{ { 0x0caad634, 0xe0a9, 0x48c4, { 0xa3, 0xc9, 0x6f, 0xf1, 0xf9, 0x6c, 0xe3, 0x50 } }, "F_VN_MinElementElementwise_TcVnVector2_REAL", nullptr }, \
	{ { 0xcc4b87dd, 0xad15, 0x4db0, { 0x91, 0xdf, 0x8b, 0x2a, 0x46, 0x2f, 0x4f, 0xd9 } }, "F_VN_MinElementElementwise_TcVnVector2_SINT", nullptr }, \
	{ { 0x0b5bad99, 0xd77a, 0x4d77, { 0x84, 0xaf, 0xd8, 0x59, 0xec, 0xc1, 0x33, 0x97 } }, "F_VN_MinElementElementwise_TcVnVector2_UINT", nullptr }, \
	{ { 0x5d42ee2f, 0xe9ef, 0x4e2b, { 0x8a, 0xab, 0x99, 0x96, 0x82, 0x3a, 0xff, 0x49 } }, "F_VN_MinElementElementwise_TcVnVector2_USINT", nullptr }, \
	{ { 0x89b98703, 0x195a, 0x44a6, { 0x9a, 0x7c, 0x11, 0x3b, 0x75, 0x88, 0x7e, 0xc2 } }, "F_VN_MinElementElementwise_TcVnVector3_INT", nullptr }, \
	{ { 0x457a0670, 0x77c2, 0x4c86, { 0xbf, 0x20, 0xbc, 0x15, 0xb6, 0x5f, 0x5a, 0x25 } }, "F_VN_MinElementElementwise_TcVnVector3_REAL", nullptr }, \
	{ { 0xe93d24d7, 0x25c4, 0x4016, { 0x85, 0x48, 0x0a, 0x75, 0x68, 0xf8, 0x96, 0x9e } }, "F_VN_MinElementElementwise_TcVnVector3_SINT", nullptr }, \
	{ { 0xbb2d2e97, 0xe109, 0x4a0b, { 0x9d, 0x7d, 0x4f, 0x14, 0x2a, 0x85, 0x3b, 0x31 } }, "F_VN_MinElementElementwise_TcVnVector3_UINT", nullptr }, \
	{ { 0xe56166d5, 0xf07b, 0x47ca, { 0x9f, 0x09, 0x02, 0xe7, 0x18, 0x20, 0xdd, 0xa2 } }, "F_VN_MinElementElementwise_TcVnVector3_USINT", nullptr }, \
	{ { 0xc3c9869b, 0x015c, 0x4aaf, { 0xb2, 0x69, 0x37, 0x26, 0xed, 0xf7, 0xe3, 0x17 } }, "F_VN_MinElementElementwise_TcVnVector4_DINT", nullptr }, \
	{ { 0x7dec9b56, 0x8d5b, 0x4a20, { 0xbb, 0x31, 0xd8, 0xfb, 0xa9, 0xb7, 0xfa, 0x24 } }, "F_VN_MinElementElementwise_TcVnVector4_INT", nullptr }, \
	{ { 0x45028bc8, 0x042a, 0x4d61, { 0x99, 0x9c, 0x43, 0xf6, 0x54, 0x80, 0x4f, 0x40 } }, "F_VN_MinElementElementwise_TcVnVector4_LREAL", nullptr }, \
	{ { 0x82b9403d, 0x4dd5, 0x4740, { 0xbc, 0xec, 0x1d, 0x06, 0xea, 0xc6, 0xc9, 0xc6 } }, "F_VN_MinElementElementwise_TcVnVector4_REAL", nullptr }, \
	{ { 0x9a99da6b, 0x54de, 0x41c1, { 0xba, 0x59, 0xe7, 0xe7, 0x80, 0x26, 0xdb, 0x8c } }, "F_VN_MinElementElementwise_TcVnVector4_SINT", nullptr }, \
	{ { 0x5542a752, 0x62ae, 0x428c, { 0x87, 0xd1, 0xfb, 0x0c, 0x22, 0x22, 0xc1, 0x17 } }, "F_VN_MinElementElementwise_TcVnVector4_UINT", nullptr }, \
	{ { 0xf258849a, 0x101d, 0x4a9f, { 0xab, 0xec, 0xfc, 0xc2, 0xb6, 0x38, 0x10, 0xc2 } }, "F_VN_MinElementElementwise_TcVnVector4_USINT", nullptr }, \
	{ { 0xf95082d6, 0x32a1, 0x4dd0, { 0x9a, 0x62, 0xc3, 0xb5, 0x92, 0xdb, 0x67, 0x9c } }, "F_VN_MinElementElementwise_UDINT", nullptr }, \
	{ { 0xf897df50, 0x3132, 0x479f, { 0xad, 0x7f, 0x28, 0x70, 0xfd, 0xea, 0x80, 0x8c } }, "F_VN_MinElementElementwise_UINT", nullptr }, \
	{ { 0x69b9fe8b, 0x04e0, 0x4362, { 0x92, 0xa6, 0x3b, 0xc4, 0xcb, 0x1a, 0x31, 0xcd } }, "F_VN_MinElementElementwise_ULINT", nullptr }, \
	{ { 0xb9b7778d, 0xb060, 0x4f2c, { 0xac, 0x30, 0x05, 0x83, 0x94, 0xaa, 0x37, 0x5b } }, "F_VN_MinElementElementwise_USINT", nullptr }, \
	{ { 0x6b2a371e, 0xee8a, 0x45c9, { 0x9b, 0x29, 0xf9, 0xde, 0xf6, 0xd5, 0x34, 0xa0 } }, "F_VN_MinImage", nullptr }, \
	{ { 0x8febec30, 0x905a, 0x4095, { 0xae, 0x60, 0x87, 0xba, 0x31, 0x6a, 0xe2, 0x08 } }, "F_VN_MinImageExp", nullptr }, \
	{ { 0x86f3255e, 0x5c85, 0x43d4, { 0xb3, 0xc2, 0xe2, 0x67, 0x93, 0x8d, 0x3b, 0xb5 } }, "F_VN_MinImageWithScalar", nullptr }, \
	{ { 0x43e4221d, 0xd418, 0x4ff8, { 0xb2, 0x68, 0x65, 0x43, 0xf2, 0xa9, 0x50, 0xf0 } }, "F_VN_MinImageWithScalarExp", nullptr }, \
	{ { 0xa73e664f, 0x4f23, 0x4661, { 0xa5, 0x9d, 0x19, 0x91, 0x1c, 0xbd, 0xe0, 0x6f } }, "F_VN_MinImageWithVector", nullptr }, \
	{ { 0x0851e1c6, 0xc8f3, 0x4a1b, { 0x91, 0xc6, 0x9e, 0x96, 0x56, 0x87, 0xef, 0x7a } }, "F_VN_MinImageWithVectorExp", nullptr }, \
	{ { 0x0dbd851a, 0xf7a9, 0x4e52, { 0xb8, 0xac, 0x8f, 0x62, 0xd1, 0x97, 0xda, 0xb6 } }, "F_VN_MinPixelValueExp", nullptr }, \
	{ { 0x6bcb6e44, 0xee59, 0x4a3b, { 0x87, 0x26, 0x8e, 0xc8, 0x98, 0xe7, 0x18, 0x28 } }, "F_VN_MixImageChannels", nullptr }, \
	{ { 0x4b2c626d, 0x71c6, 0x48bc, { 0x9c, 0xfd, 0x79, 0x09, 0x52, 0xf0, 0x25, 0xfa } }, "F_VN_MorphologicalOperator", nullptr }, \
	{ { 0x14d82b52, 0xb983, 0x4569, { 0x94, 0xea, 0x4d, 0x2c, 0x7a, 0x78, 0x92, 0x35 } }, "F_VN_MultiplyContainers", nullptr }, \
	{ { 0xf8991207, 0x0c53, 0x4bb6, { 0x9c, 0x14, 0xe4, 0x82, 0x7d, 0xc8, 0xe3, 0x8f } }, "F_VN_MultiplyImages", nullptr }, \
	{ { 0xcb1868b4, 0xd4f2, 0x47d0, { 0x80, 0x92, 0xc3, 0x5b, 0x4c, 0xa7, 0x2a, 0x8e } }, "F_VN_MultiplyImageWithScalar", nullptr }, \
	{ { 0x2065e6b2, 0xbaa4, 0x4082, { 0xb7, 0xe7, 0x42, 0x85, 0x93, 0xdf, 0xe0, 0xd6 } }, "F_VN_MultiplyImageWithVector", nullptr }, \
	{ { 0xfc5c1f16, 0x8273, 0x4c58, { 0x87, 0x95, 0xae, 0xa5, 0x08, 0x33, 0x9c, 0x2c } }, "F_VN_MultiplyMatrices", nullptr }, \
	{ { 0x3ba7605d, 0xadf7, 0x4539, { 0x87, 0x76, 0xda, 0x89, 0xd7, 0x83, 0xeb, 0x70 } }, "F_VN_MultiplyWithContainerElements1", nullptr }, \
	{ { 0xb6d5beda, 0x32ca, 0x4a81, { 0xa7, 0xdf, 0x41, 0x68, 0x68, 0x1e, 0x5e, 0x8d } }, "F_VN_MultiplyWithContainerElements2", nullptr }, \
	{ { 0x1db206b1, 0x94ea, 0x42b2, { 0xab, 0x87, 0x0f, 0x4a, 0x0f, 0x70, 0x87, 0x70 } }, "F_VN_MultiplyWithContainerElements3", nullptr }, \
	{ { 0xdc613985, 0x6d03, 0x4a36, { 0xac, 0x56, 0x85, 0xc1, 0xce, 0x83, 0xfa, 0x98 } }, "F_VN_MultiplyWithContainerElements4", nullptr }, \
	{ { 0x06010091, 0xd01f, 0x4e11, { 0x85, 0x40, 0xcf, 0xa0, 0xe1, 0xab, 0xe6, 0x33 } }, "F_VN_NegateContainer", nullptr }, \
	{ { 0xacc5bfb7, 0x80af, 0x4f86, { 0xa0, 0x43, 0xa1, 0xd7, 0x87, 0x28, 0xbb, 0x76 } }, "F_VN_NonMaxSuppressionExp", nullptr }, \
	{ { 0x358fd966, 0x61c2, 0x4ab0, { 0x81, 0xa6, 0xdb, 0x75, 0x6f, 0xa4, 0x3b, 0x8d } }, "F_VN_NormalizeImageExp", nullptr }, \
	{ { 0x96937d09, 0xeb4c, 0x4367, { 0xa3, 0x04, 0x15, 0x06, 0xe2, 0x21, 0x12, 0x5f } }, "F_VN_NormalizeImageForDisplay", nullptr }, \
	{ { 0xeef9ac2b, 0x161c, 0x4ba9, { 0x90, 0xc1, 0xf7, 0x34, 0x5c, 0xa7, 0x59, 0x18 } }, "F_VN_OptimalDftSize", nullptr }, \
	{ { 0x1a1a18bf, 0xf988, 0x43d7, { 0x9b, 0xd5, 0x8b, 0xed, 0x85, 0x74, 0xfb, 0x7e } }, "F_VN_OrthogonalVector_TcVnVector2_DINT", nullptr }, \
	{ { 0x98a2d3da, 0x51bc, 0x49a3, { 0xbc, 0xe5, 0xee, 0x69, 0x0f, 0xd6, 0x40, 0x61 } }, "F_VN_OrthogonalVector_TcVnVector2_LREAL", nullptr }, \
	{ { 0x2720f438, 0x7f5d, 0x42d3, { 0xbc, 0x81, 0xaa, 0xd0, 0x83, 0xed, 0x37, 0x1f } }, "F_VN_OrthogonalVector_TcVnVector2_REAL", nullptr }, \
	{ { 0x346ed245, 0xd8e2, 0x4354, { 0xae, 0xe2, 0xaa, 0xe0, 0x98, 0xcd, 0x55, 0xaa } }, "F_VN_PadImageBorderExp", nullptr }, \
	{ { 0x07f4b6d7, 0xe906, 0x4ea8, { 0xb8, 0xe7, 0xe2, 0x87, 0x29, 0xaa, 0x31, 0x9d } }, "F_VN_PerspectiveTransformation", nullptr }, \
	{ { 0x915a9907, 0xceca, 0x4256, { 0x93, 0x35, 0x5a, 0x82, 0x99, 0x28, 0x39, 0x3b } }, "F_VN_PlotIntensityProfileExp", nullptr }, \
	{ { 0xa1f70ade, 0x5b1e, 0x481c, { 0x84, 0x23, 0xc2, 0x13, 0x2c, 0xb9, 0xea, 0xee } }, "F_VN_PointToLineDistance_TcVnPoint2_DINT", nullptr }, \
	{ { 0xdd979073, 0x652c, 0x4045, { 0xb9, 0x2e, 0x7b, 0x2b, 0x98, 0xf0, 0xe1, 0xcb } }, "F_VN_PointToLineDistance_TcVnPoint2_LREAL", nullptr }, \
	{ { 0xc5cd67e5, 0xa3b3, 0x4527, { 0xae, 0xea, 0x34, 0x11, 0x45, 0xc7, 0xfe, 0xaf } }, "F_VN_PointToLineDistance_TcVnPoint2_REAL", nullptr }, \
	{ { 0x995ed97a, 0xffdc, 0x4c62, { 0xb7, 0xb6, 0x5e, 0xe5, 0x2d, 0xef, 0xa0, 0xd7 } }, "F_VN_PointToPointDirection_TcVnPoint2_DINT", nullptr }, \
	{ { 0x4d85f45f, 0xf18c, 0x47ee, { 0xa6, 0x2c, 0x2d, 0x64, 0xe9, 0xbf, 0x7a, 0x0b } }, "F_VN_PointToPointDirection_TcVnPoint2_LREAL", nullptr }, \
	{ { 0xef81860b, 0x0f8e, 0x4608, { 0x87, 0xfe, 0x09, 0x4a, 0x16, 0x0f, 0xb8, 0x2a } }, "F_VN_PointToPointDirection_TcVnPoint2_REAL", nullptr }, \
	{ { 0x759c1fe8, 0x66de, 0x46c0, { 0xb0, 0xa2, 0xf8, 0x54, 0x10, 0xca, 0xe8, 0xc5 } }, "F_VN_PointToPointDistance_TcVnPoint2_DINT", nullptr }, \
	{ { 0x8c8722ce, 0xa94d, 0x4f77, { 0xa4, 0xdd, 0x9d, 0x07, 0xf5, 0xed, 0x68, 0xa2 } }, "F_VN_PointToPointDistance_TcVnPoint2_LREAL", nullptr }, \
	{ { 0x14c9d457, 0x7bee, 0x4e21, { 0xb6, 0x06, 0xc2, 0xc4, 0xfe, 0x09, 0x41, 0x09 } }, "F_VN_PointToPointDistance_TcVnPoint2_REAL", nullptr }, \
	{ { 0xab53efe1, 0xfec6, 0x4bde, { 0xbb, 0x3a, 0xea, 0x20, 0xe6, 0xac, 0x5d, 0xd5 } }, "F_VN_PutLabelExp", nullptr }, \
	{ { 0x510bae2f, 0x9539, 0x4bd7, { 0xa0, 0x03, 0x5c, 0x42, 0x0c, 0xe2, 0xe6, 0xbc } }, "F_VN_PutTextExp", nullptr }, \
	{ { 0x02935435, 0x2558, 0x4c67, { 0xa5, 0x83, 0xc3, 0xdd, 0x7c, 0x4f, 0xb8, 0x52 } }, "F_VN_PyramidDown", nullptr }, \
	{ { 0x619d51dc, 0xbd34, 0x4a03, { 0xbd, 0x5a, 0x73, 0x59, 0xcd, 0x66, 0x1b, 0x28 } }, "F_VN_PyramidUp", nullptr }, \
	{ { 0xea31d384, 0x2dc0, 0x45f0, { 0xa6, 0xcd, 0x5b, 0xd0, 0x7e, 0xa4, 0xd0, 0x32 } }, "F_VN_Reduce", nullptr }, \
	{ { 0x0dbe9492, 0xcfe3, 0x48bb, { 0xbd, 0x6f, 0xc7, 0x07, 0x61, 0xc3, 0x06, 0xa3 } }, "F_VN_ReduceArg", nullptr }, \
	{ { 0xe2a998e9, 0xca15, 0x4b97, { 0xb1, 0x6b, 0xf5, 0x72, 0x1a, 0x8b, 0xa7, 0xa6 } }, "F_VN_ReferenceColorSimilarityExp_ITcVnColorModel", nullptr }, \
	{ { 0x9404ab5e, 0x0776, 0x4087, { 0x9c, 0xdd, 0x1f, 0x4d, 0x42, 0x1a, 0x5b, 0x83 } }, "F_VN_ReferenceColorSimilarityExp_ITcVnMlModel", nullptr }, \
	{ { 0x1fde7224, 0x510e, 0x4901, { 0x90, 0xcf, 0x8c, 0xd2, 0x87, 0x68, 0xeb, 0xe9 } }, "F_VN_ReferenceColorSimilarityExp_TcVnVector3_LREAL", nullptr }, \
	{ { 0xa40395d3, 0x1a19, 0x4094, { 0x94, 0xc4, 0xf4, 0x44, 0x97, 0x57, 0x0e, 0x99 } }, "F_VN_RegionOrientationExp", nullptr }, \
	{ { 0x0d5db5c8, 0x3ec1, 0x47e1, { 0xa9, 0xc6, 0xd4, 0x9b, 0x7f, 0x02, 0x1c, 0xc0 } }, "F_VN_ReinterpretUnsupportedImage", nullptr }, \
	{ { 0x2a5fea3c, 0x7435, 0x4c3d, { 0x9c, 0x96, 0x39, 0xcc, 0x26, 0xf4, 0xef, 0x41 } }, "F_VN_RemapImageToLogPolarSpaceExp2", nullptr }, \
	{ { 0x9a13fc26, 0xb3e9, 0x48dc, { 0x84, 0x02, 0x06, 0xbe, 0x95, 0xc5, 0x21, 0x26 } }, "F_VN_RemapImageToPolarSpaceExp2", nullptr }, \
	{ { 0x9abdfb0b, 0x2463, 0x4dbb, { 0x9c, 0x42, 0x8b, 0x42, 0x7e, 0x98, 0x72, 0x5a } }, "F_VN_RemoveLocalMaxima", nullptr }, \
	{ { 0x2c12fca8, 0x4113, 0x4633, { 0xa9, 0xbc, 0x68, 0xd6, 0x5e, 0xc2, 0x25, 0x3a } }, "F_VN_RemoveLocalMinima", nullptr }, \
	{ { 0xa72d618e, 0xd861, 0x454d, { 0xad, 0x42, 0xbc, 0xc9, 0xef, 0x43, 0x2e, 0x86 } }, "F_VN_ReserveContainerMemory", nullptr }, \
	{ { 0xbddbfab7, 0xf672, 0x4ef8, { 0xb8, 0xc9, 0x4f, 0x13, 0x30, 0x00, 0xe7, 0x19 } }, "F_VN_ResetRoi", nullptr }, \
	{ { 0xa23c9dd2, 0xb232, 0x491a, { 0x82, 0x55, 0x40, 0xb5, 0x4b, 0xd1, 0x2f, 0x1b } }, "F_VN_ReshapeImage", nullptr }, \
	{ { 0xce6f5530, 0x4ebc, 0x44ee, { 0xa0, 0xfe, 0xd3, 0x2a, 0xec, 0x88, 0x9e, 0x73 } }, "F_VN_ResizeImageExp", nullptr }, \
	{ { 0x3415117d, 0xba8d, 0x48d9, { 0x9b, 0x0b, 0x31, 0xd4, 0xff, 0x83, 0xd8, 0x08 } }, "F_VN_ReverseContainer", nullptr }, \
	{ { 0x2036211b, 0x0b18, 0x4cb3, { 0x9c, 0xa3, 0x56, 0x40, 0x27, 0x65, 0x59, 0xf8 } }, "F_VN_RotatedRectangleCorners", nullptr }, \
	{ { 0x8d78bef1, 0x2564, 0x4028, { 0x9a, 0x36, 0x07, 0x75, 0x83, 0xf9, 0xcd, 0xee } }, "F_VN_RotatedRectangleIntersection", nullptr }, \
	{ { 0x75b36967, 0xcc2d, 0x4551, { 0x99, 0x9b, 0xe7, 0xe4, 0x86, 0x36, 0xc7, 0x8a } }, "F_VN_RotateImage", nullptr }, \
	{ { 0x7cef98fb, 0xeffd, 0x4830, { 0xab, 0x48, 0xd9, 0xea, 0x95, 0xc1, 0x8d, 0x0b } }, "F_VN_RotateImageExp2", nullptr }, \
	{ { 0x7e79df67, 0x3e07, 0x4986, { 0x9d, 0xb8, 0xf5, 0x23, 0x95, 0xdc, 0x77, 0x6a } }, "F_VN_SauvolaThreshold", nullptr }, \
	{ { 0x9d10fb0c, 0x5ae0, 0x4b1d, { 0xb6, 0xb4, 0x47, 0xe7, 0xe5, 0xea, 0xcb, 0x8e } }, "F_VN_ScharrFilterExp", nullptr }, \
	{ { 0x45dca7fd, 0x46e6, 0x40c7, { 0xbb, 0x6e, 0x3c, 0x2a, 0x29, 0x54, 0xa7, 0x22 } }, "F_VN_SeparableCustomFilterExp", nullptr }, \
	{ { 0xacb28d93, 0x4fdf, 0x4b86, { 0xad, 0xc6, 0xd1, 0x29, 0xfa, 0x51, 0x01, 0xb4 } }, "F_VN_SetAt_DINT", nullptr }, \
	{ { 0x3964488d, 0x7fef, 0x4459, { 0x80, 0x7c, 0xa2, 0x11, 0x0f, 0x1d, 0xf0, 0x8c } }, "F_VN_SetAt_INT", nullptr }, \
	{ { 0x3d51d8b1, 0x6158, 0x4b5b, { 0x92, 0x58, 0x33, 0xa4, 0xbc, 0x43, 0x12, 0xa3 } }, "F_VN_SetAt_ITcVnContainer", nullptr }, \
	{ { 0x027b30fd, 0xf77f, 0x4ca8, { 0x80, 0x3a, 0x08, 0xfd, 0x96, 0x9d, 0xa8, 0x91 } }, "F_VN_SetAt_ITcVnImage", nullptr }, \
	{ { 0x38051cc7, 0xe8cf, 0x4f64, { 0xae, 0x28, 0x32, 0x27, 0x3a, 0x1d, 0x96, 0xd4 } }, "F_VN_SetAt_LREAL", nullptr }, \
	{ { 0xf713c232, 0xf416, 0x430a, { 0xbb, 0x51, 0xec, 0xa0, 0x9e, 0xb5, 0x5b, 0x48 } }, "F_VN_SetAt_REAL", nullptr }, \
	{ { 0x29cf3c20, 0x6075, 0x42a6, { 0x93, 0xb2, 0x72, 0x1e, 0x92, 0x99, 0xef, 0xf2 } }, "F_VN_SetAt_SINT", nullptr }, \
	{ { 0xa4503ed0, 0xe291, 0x45b0, { 0x8b, 0x51, 0x27, 0x06, 0x4c, 0xed, 0xa6, 0xd5 } }, "F_VN_SetAt_TcVnDMatch", nullptr }, \
	{ { 0xdcc40c78, 0x13c3, 0x49f8, { 0x90, 0xf3, 0x75, 0xbc, 0xf8, 0xcc, 0x0b, 0x49 } }, "F_VN_SetAt_TcVnKeyPoint", nullptr }, \
	{ { 0xb18a8470, 0xcec2, 0x452c, { 0xae, 0x4e, 0x2c, 0xc7, 0xaf, 0xa6, 0x62, 0xc1 } }, "F_VN_SetAt_TcVnPoint2_DINT", nullptr }, \
	{ { 0xbab37145, 0x882e, 0x464d, { 0xb6, 0x34, 0x90, 0xd1, 0xab, 0xe6, 0x8c, 0x0e } }, "F_VN_SetAt_TcVnPoint2_LREAL", nullptr }, \
	{ { 0xeabae9db, 0x3ac9, 0x4a08, { 0x8d, 0xec, 0xf2, 0xc8, 0x80, 0x3b, 0x41, 0xfe } }, "F_VN_SetAt_TcVnPoint2_REAL", nullptr }, \
	{ { 0x7380ccca, 0x7f5e, 0x4712, { 0x85, 0x79, 0xc3, 0xf4, 0x54, 0x98, 0x3a, 0x12 } }, "F_VN_SetAt_TcVnPoint3_LREAL", nullptr }, \
	{ { 0x4095a755, 0x0215, 0x4811, { 0xbf, 0x71, 0x0c, 0x4b, 0x2e, 0x41, 0x25, 0xd2 } }, "F_VN_SetAt_TcVnPoint3_REAL", nullptr }, \
	{ { 0xccb41689, 0x8186, 0x4c50, { 0x9f, 0x12, 0x21, 0x7e, 0x03, 0x8e, 0x2f, 0x33 } }, "F_VN_SetAt_TcVnRectangle_DINT", nullptr }, \
	{ { 0x537ad7a2, 0xb83e, 0x4964, { 0xa5, 0xd3, 0x7e, 0x09, 0x77, 0x3e, 0x45, 0x86 } }, "F_VN_SetAt_TcVnRotatedRectangle", nullptr }, \
	{ { 0xa71af3c5, 0xc983, 0x4674, { 0xa0, 0xc8, 0xbb, 0xdc, 0x66, 0xc4, 0x21, 0x04 } }, "F_VN_SetAt_TcVnVector2_DINT", nullptr }, \
	{ { 0x634c9e0f, 0x7d40, 0x444f, { 0xbd, 0xbe, 0x15, 0x94, 0xeb, 0xcb, 0x79, 0x84 } }, "F_VN_SetAt_TcVnVector2_INT", nullptr }, \
	{ { 0x756847a9, 0xc2a4, 0x40c2, { 0xa4, 0xe2, 0x64, 0x51, 0x39, 0x60, 0xfe, 0x63 } }, "F_VN_SetAt_TcVnVector2_REAL", nullptr }, \
	{ { 0xb8faf766, 0x7096, 0x4895, { 0x88, 0x05, 0xad, 0x59, 0xbf, 0xec, 0x35, 0x67 } }, "F_VN_SetAt_TcVnVector2_SINT", nullptr }, \
	{ { 0xd8e6c503, 0xdf99, 0x451b, { 0xad, 0x17, 0x7e, 0xef, 0x74, 0x15, 0x09, 0xc0 } }, "F_VN_SetAt_TcVnVector2_UINT", nullptr }, \
	{ { 0x887f7bf6, 0x8fae, 0x46a6, { 0xb6, 0xda, 0x4f, 0x7f, 0xb8, 0x8c, 0x03, 0x7d } }, "F_VN_SetAt_TcVnVector2_USINT", nullptr }, \
	{ { 0x4a9fabab, 0x88b8, 0x4192, { 0x82, 0x3c, 0x55, 0xf6, 0x6f, 0x67, 0x44, 0xdf } }, "F_VN_SetAt_TcVnVector3_INT", nullptr }, \
	{ { 0x6e67b3bd, 0xd026, 0x44c3, { 0xa4, 0xe3, 0xb1, 0x4e, 0xf1, 0x83, 0x3f, 0x18 } }, "F_VN_SetAt_TcVnVector3_REAL", nullptr }, \
	{ { 0x7bdc0b10, 0x34a4, 0x4aee, { 0x90, 0x9c, 0x73, 0xc0, 0xc2, 0x6b, 0x68, 0xa3 } }, "F_VN_SetAt_TcVnVector3_SINT", nullptr }, \
	{ { 0x496c576c, 0xa3ae, 0x471f, { 0xb0, 0xb7, 0x72, 0xa7, 0x9e, 0x59, 0x6c, 0x33 } }, "F_VN_SetAt_TcVnVector3_UINT", nullptr }, \
	{ { 0x33804ee6, 0xca55, 0x43cf, { 0xb6, 0x00, 0xa5, 0xfe, 0x19, 0x1b, 0xa0, 0xcb } }, "F_VN_SetAt_TcVnVector3_USINT", nullptr }, \
	{ { 0x7d1f07d5, 0x4dd9, 0x4009, { 0xbb, 0xa6, 0xd4, 0xe2, 0x79, 0x6d, 0x3f, 0x29 } }, "F_VN_SetAt_TcVnVector4_DINT", nullptr }, \
	{ { 0xb59e9ce9, 0x2330, 0x482a, { 0xb8, 0x66, 0x1a, 0x38, 0x3c, 0x93, 0x73, 0x90 } }, "F_VN_SetAt_TcVnVector4_INT", nullptr }, \
	{ { 0x4a991cd0, 0xaa18, 0x49cc, { 0xb3, 0xbd, 0x44, 0x5c, 0x40, 0x46, 0x11, 0x65 } }, "F_VN_SetAt_TcVnVector4_LREAL", nullptr }, \
	{ { 0x9db68adf, 0xc5d2, 0x4265, { 0x91, 0x5e, 0x23, 0xf5, 0x88, 0x42, 0x94, 0x77 } }, "F_VN_SetAt_TcVnVector4_REAL", nullptr }, \
	{ { 0x633cca15, 0x4344, 0x4e0d, { 0x89, 0x6b, 0x1d, 0xd0, 0x63, 0x8f, 0xb4, 0x73 } }, "F_VN_SetAt_TcVnVector4_SINT", nullptr }, \
	{ { 0x656466c1, 0x1702, 0x45a4, { 0x93, 0x66, 0xcf, 0xd0, 0x55, 0x42, 0x21, 0x79 } }, "F_VN_SetAt_TcVnVector4_UINT", nullptr }, \
	{ { 0x75d399ca, 0xf95b, 0x47f1, { 0xaa, 0x76, 0x31, 0x80, 0x26, 0x23, 0xdd, 0x02 } }, "F_VN_SetAt_TcVnVector4_USINT", nullptr }, \
	{ { 0x3a831889, 0x4118, 0x4264, { 0xbd, 0xf3, 0x92, 0xda, 0xb1, 0x74, 0xd0, 0x3b } }, "F_VN_SetAt_UDINT", nullptr }, \
	{ { 0x6e255369, 0x065d, 0x4d93, { 0x9e, 0x2b, 0xe8, 0x5d, 0x07, 0xce, 0xbb, 0x40 } }, "F_VN_SetAt_UINT", nullptr }, \
	{ { 0x05904cfa, 0x51c2, 0x4112, { 0x80, 0x50, 0x8d, 0xe7, 0x9f, 0x86, 0xbc, 0xb5 } }, "F_VN_SetAt_ULINT", nullptr }, \
	{ { 0x887f0ad4, 0x92a1, 0x4644, { 0x9c, 0x9b, 0x00, 0x00, 0x3b, 0x96, 0x2d, 0xc8 } }, "F_VN_SetAt_USINT", nullptr }, \
	{ { 0xe27779bd, 0x577c, 0x4af7, { 0xb9, 0x30, 0x05, 0x7e, 0x80, 0x5a, 0x07, 0x08 } }, "F_VN_SetContainer", nullptr }, \
	{ { 0x9b9ad34e, 0xabf9, 0x47d8, { 0x90, 0xb8, 0x76, 0x5a, 0x9c, 0x79, 0x27, 0x1c } }, "F_VN_SetImageChannel", nullptr }, \
	{ { 0x5000db11, 0x6ce7, 0x469f, { 0x8a, 0xb2, 0xe5, 0x20, 0x3b, 0x14, 0x19, 0xe0 } }, "F_VN_SetIteratorToBegin", nullptr }, \
	{ { 0x1acffb57, 0xf1b5, 0x4382, { 0xb7, 0xbe, 0xdd, 0x1b, 0xc4, 0x32, 0x3e, 0x2f } }, "F_VN_SetPixel", nullptr }, \
	{ { 0xd440c7fc, 0xb349, 0x41ea, { 0xa5, 0xcc, 0x32, 0x5d, 0x23, 0xb3, 0xb0, 0x8a } }, "F_VN_SetPixelsExp", nullptr }, \
	{ { 0x9b8a0344, 0xfca8, 0x431b, { 0x92, 0x0b, 0x85, 0xaa, 0x07, 0x88, 0x06, 0xce } }, "F_VN_SetRngSeed", nullptr }, \
	{ { 0xfad46db9, 0x239b, 0x4799, { 0xad, 0x51, 0xf4, 0x80, 0x14, 0x2b, 0x4d, 0x2a } }, "F_VN_SetRoi", nullptr }, \
	{ { 0xa49f2093, 0x7d27, 0x4153, { 0xb4, 0x0f, 0x0c, 0x69, 0x28, 0xd5, 0x35, 0x89 } }, "F_VN_SetRoi_TcVnRectangle_DINT", nullptr }, \
	{ { 0xf1a563cb, 0xd673, 0x4be2, { 0xb3, 0xac, 0xdd, 0x2b, 0x67, 0x9a, 0x36, 0x1b } }, "F_VN_SetRoi_TcVnRectangle_UDINT", nullptr }, \
	{ { 0x3fdc7047, 0xc805, 0x496f, { 0xba, 0xbe, 0x0b, 0xf7, 0xab, 0xc8, 0x0f, 0xec } }, "F_VN_SigmoidExp", nullptr }, \
	{ { 0x72591c66, 0xd387, 0x4777, { 0x99, 0x5d, 0x9c, 0x08, 0x8d, 0xbc, 0x40, 0x5e } }, "F_VN_SobelFilterExp", nullptr }, \
	{ { 0xeb27ee56, 0xf2e3, 0x47ff, { 0xad, 0x96, 0x89, 0xc9, 0x93, 0x2b, 0xe4, 0x3c } }, "F_VN_SoftMax", nullptr }, \
	{ { 0x38d558c2, 0x0603, 0x4877, { 0xa1, 0x39, 0x53, 0xee, 0x57, 0xe8, 0xcc, 0xe3 } }, "F_VN_SplitImageChannels", nullptr }, \
	{ { 0x5c1d96bb, 0xf18e, 0x481e, { 0x84, 0x9b, 0x67, 0xb0, 0x49, 0x75, 0x10, 0x85 } }, "F_VN_StartAbsWatchdogExp", nullptr }, \
	{ { 0x3494b001, 0x0651, 0x40ea, { 0xab, 0x18, 0x3d, 0x5f, 0x94, 0x03, 0x86, 0x05 } }, "F_VN_StartRelWatchdogExp", nullptr }, \
	{ { 0x5e0c13a7, 0xea6c, 0x4b6b, { 0x92, 0xf4, 0x2b, 0xba, 0xb5, 0x20, 0x45, 0x96 } }, "F_VN_StopWatchdog", nullptr }, \
	{ { 0x2c4dc90e, 0x2729, 0x477e, { 0x98, 0x25, 0x8e, 0x13, 0xf6, 0xad, 0x4a, 0x7a } }, "F_VN_SubtractContainers", nullptr }, \
	{ { 0xc299684c, 0xa29d, 0x4568, { 0xb3, 0xd4, 0xe3, 0x56, 0x66, 0x55, 0xc6, 0xf5 } }, "F_VN_SubtractImageFromScalar", nullptr }, \
	{ { 0x6d623573, 0x40db, 0x4997, { 0xa2, 0xa0, 0x34, 0x7a, 0x97, 0x40, 0x93, 0x30 } }, "F_VN_SubtractImageFromVector", nullptr }, \
	{ { 0xe998639c, 0xb966, 0x4d0a, { 0xb0, 0x7a, 0xa4, 0x4f, 0x30, 0x1c, 0xd7, 0x23 } }, "F_VN_SubtractImages", nullptr }, \
	{ { 0x30468f1b, 0x8fe1, 0x4446, { 0xaf, 0x3b, 0x30, 0x50, 0x14, 0xea, 0x99, 0xd7 } }, "F_VN_SubtractScalarFromImage", nullptr }, \
	{ { 0x40764737, 0x31c8, 0x47c1, { 0xa9, 0x79, 0x73, 0x7c, 0x82, 0x3d, 0xad, 0xac } }, "F_VN_SubtractVectorFromImage", nullptr }, \
	{ { 0xf55bba63, 0x80b1, 0x49e6, { 0xaa, 0xe6, 0xaf, 0x5c, 0x70, 0x87, 0xa0, 0xea } }, "F_VN_Threshold", nullptr }, \
	{ { 0xc8c8c29a, 0xe7ad, 0x4c99, { 0xa5, 0x28, 0x25, 0x2d, 0x64, 0x9b, 0x41, 0xe2 } }, "F_VN_TrainImageColorExp2", nullptr }, \
	{ { 0x9efbcb1f, 0x1456, 0x4e82, { 0xae, 0xa5, 0xdc, 0xb7, 0x06, 0x05, 0xc9, 0x03 } }, "F_VN_TrainImageColorExp2_ITcVnMlModel", nullptr }, \
	{ { 0x713f8352, 0x220f, 0x43e8, { 0x98, 0xaa, 0xd9, 0xe8, 0xcd, 0x91, 0x62, 0xcc } }, "F_VN_TransformCoordinatesPlanar_Container", nullptr }, \
	{ { 0x85c53e4e, 0x0dfc, 0x4002, { 0x96, 0x76, 0x08, 0x7a, 0xf9, 0xce, 0xe3, 0x36 } }, "F_VN_TransformCoordinatesPlanar_Point", nullptr }, \
	{ { 0x87f19aea, 0xea22, 0x431e, { 0xab, 0x0d, 0xe2, 0x04, 0x23, 0x96, 0xb0, 0x94 } }, "F_VN_TransformIntoDisplayableImageExp", nullptr }, \
	{ { 0x4da6075f, 0x2e46, 0x4c49, { 0xa3, 0xf2, 0xc0, 0x7c, 0x38, 0x48, 0x2e, 0x5b } }, "F_VN_UpdateTimestamp", nullptr }, \
	{ { 0xd6df089c, 0xec79, 0x4ca6, { 0xb4, 0x8d, 0x3e, 0x42, 0x49, 0x64, 0x27, 0x89 } }, "F_VN_UprightBoundingRectangle", nullptr }, \
	{ { 0x0f7449f0, 0x22d1, 0x456d, { 0x92, 0x53, 0xe0, 0x5d, 0x3f, 0x0e, 0xac, 0x3c } }, "F_VN_UprightInnerRectangleExp", nullptr }, \
	{ { 0xb1d37efb, 0xfe9c, 0x45eb, { 0x85, 0x65, 0x0e, 0xc8, 0x94, 0xab, 0xa7, 0x2d } }, "F_VN_VarianceFilterExp", nullptr }, \
	{ { 0x81f98cb8, 0x9ae2, 0x42fc, { 0x94, 0xc2, 0xe8, 0x4b, 0x5e, 0x5a, 0x9a, 0x91 } }, "F_VN_WarpAffine", nullptr }, \
	{ { 0x44ba8263, 0x27b0, 0x4c91, { 0xb5, 0x98, 0xa2, 0x9b, 0x8e, 0x8b, 0x67, 0x4b } }, "F_VN_WarpAffine_Container", nullptr }, \
	{ { 0xf57dfd43, 0x1bab, 0x49e9, { 0x89, 0xed, 0x63, 0x90, 0x09, 0xe1, 0xb7, 0x19 } }, "F_VN_WarpAffine_Point", nullptr }, \
	{ { 0xa5157f1f, 0x56e0, 0x4a9a, { 0x8e, 0xf2, 0x4e, 0x7b, 0x71, 0x44, 0x4a, 0xe0 } }, "F_VN_WarpAffine_Rectangle", nullptr }, \
	{ { 0x1cd3955d, 0x5cc7, 0x4e2c, { 0x80, 0x64, 0x2d, 0x97, 0x53, 0x22, 0xe1, 0x44 } }, "F_VN_WarpAffineExp", nullptr }, \
	{ { 0x034fc1e2, 0x2c68, 0x4fe6, { 0x99, 0x96, 0x94, 0x76, 0xaf, 0x81, 0x9d, 0xb8 } }, "F_VN_WarpPerspective", nullptr }, \
	{ { 0x089aaa66, 0x0bfe, 0x4016, { 0xbf, 0xaa, 0xc5, 0xa1, 0x4b, 0x2f, 0xb5, 0x5a } }, "F_VN_WarpPerspective_Container", nullptr }, \
	{ { 0xf3c7dc0e, 0xd413, 0x4850, { 0x93, 0xec, 0xa1, 0x14, 0xc7, 0x01, 0x2c, 0x90 } }, "F_VN_WarpPerspective_Point", nullptr }, \
	{ { 0x05aae285, 0x342b, 0x4c6a, { 0x88, 0x4f, 0xec, 0x96, 0x69, 0x8a, 0x4d, 0x39 } }, "F_VN_WarpPerspective_Rectangle", nullptr }, \
	{ { 0xf819e348, 0xfc4e, 0x4af3, { 0x8c, 0xdf, 0x5b, 0x99, 0xc5, 0xce, 0x80, 0x56 } }, "F_VN_WarpPerspectiveExp", nullptr }, \
	{ { 0x04a07f60, 0x0e08, 0x42cd, { 0xa4, 0x50, 0x42, 0x74, 0x01, 0x58, 0xa8, 0xd9 } }, "F_VN_WatershedSegmentationExp", nullptr }, \
	{ { 0x56aa2393, 0xb1c6, 0x4cf3, { 0x82, 0x21, 0xdf, 0x02, 0x81, 0xd6, 0x86, 0xbc } }, "F_VN_WhiteBalance", nullptr },
#else
	#define DEFINE_TC3_Vision_Base_FUNCS
#endif

#ifdef LIC_TC3_Vision_Code_Reading
	#define DEFINE_TC3_Vision_Code_Reading_FUNCS \
	{ { 0x04d3458a, 0x54e8, 0x4bba, { 0xa3, 0x8a, 0xf6, 0xa4, 0xf2, 0xd3, 0x85, 0x8c } }, "F_VN_ReadBarcode", nullptr }, \
	{ { 0xcf9e9946, 0x81fe, 0x477b, { 0xba, 0x41, 0x6a, 0x9c, 0x6b, 0x3c, 0xb2, 0xe8 } }, "F_VN_ReadBarcodeExp2", nullptr }, \
	{ { 0xe84e52d6, 0x0a88, 0x4317, { 0x9a, 0xf9, 0x8d, 0x3b, 0x96, 0x43, 0xa3, 0x68 } }, "F_VN_ReadBarcodeRoiExp", nullptr }, \
	{ { 0x8086e273, 0x3f6a, 0x411a, { 0xa3, 0x9f, 0x4a, 0xe8, 0xb4, 0xca, 0x05, 0xe8 } }, "F_VN_ReadDataMatrixCodeExp2", nullptr }, \
	{ { 0xcf546b98, 0x55d9, 0x44e9, { 0x9c, 0xf8, 0x0e, 0x90, 0x11, 0x45, 0xe2, 0x93 } }, "F_VN_ReadDataMatrixCodeRoiExp", nullptr }, \
	{ { 0x1f064ef6, 0x6b4b, 0x4313, { 0x98, 0xd4, 0x86, 0xb3, 0x9a, 0x6c, 0x49, 0x5e } }, "F_VN_ReadPharmaCodeExp2", nullptr }, \
	{ { 0xb333d7f8, 0xf6b9, 0x4863, { 0xba, 0x54, 0xe6, 0x10, 0x3b, 0x2a, 0x1a, 0xb1 } }, "F_VN_ReadQRCodeExp2", nullptr },
#else
	#define DEFINE_TC3_Vision_Code_Reading_FUNCS
#endif

#ifdef LIC_TC3_Vision_Code_Quality
	#define DEFINE_TC3_Vision_Code_Quality_FUNCS \
	{ { 0x8a060665, 0xef55, 0x4f2a, { 0x8d, 0x38, 0x3f, 0x90, 0x79, 0x32, 0x5d, 0xd7 } }, "F_VN_GradeBarcodeExp", nullptr }, \
	{ { 0xc132cc00, 0xc2cb, 0x45d2, { 0xb2, 0x76, 0x44, 0x3f, 0xcc, 0x3c, 0x1e, 0x43 } }, "F_VN_GradeDataMatrixCodeExp", nullptr }, \
	{ { 0xfd08d826, 0x9601, 0x4e64, { 0xaf, 0x1a, 0xbe, 0x67, 0x88, 0xbb, 0x70, 0xab } }, "F_VN_GradeQRCodeExp", nullptr },
#else
	#define DEFINE_TC3_Vision_Code_Quality_FUNCS
#endif

#ifdef LIC_TC3_Vision_Metrology_2D
	#define DEFINE_TC3_Vision_Metrology_2D_FUNCS \
	{ { 0x5d93a6a5, 0xce58, 0x42a0, { 0x94, 0x45, 0x37, 0x8a, 0xd0, 0x4b, 0xb6, 0xf1 } }, "F_VN_AdjustSearchWindowOrientationToLinearEdge", nullptr }, \
	{ { 0x12a905d9, 0xe9a8, 0x4d03, { 0x90, 0x40, 0xf5, 0x84, 0x16, 0xb2, 0x2b, 0xa2 } }, "F_VN_CalibrateCamera", nullptr }, \
	{ { 0x20eb9b8d, 0x8132, 0x4ece, { 0x82, 0xa0, 0x98, 0xd8, 0xee, 0xaa, 0x84, 0xc1 } }, "F_VN_CalibrateCameraExp3", nullptr }, \
	{ { 0x27d53d55, 0x1b1d, 0x408e, { 0x9b, 0xd3, 0xf0, 0x72, 0x8e, 0xce, 0x7b, 0xea } }, "F_VN_CalibrateCameraManuallyExp", nullptr }, \
	{ { 0x547f434f, 0xc006, 0x4ffe, { 0x9c, 0x39, 0xa7, 0x5d, 0xbe, 0xc7, 0x7c, 0x3c } }, "F_VN_CalibrateLinescanCameraExp", nullptr }, \
	{ { 0xee1fff91, 0xa9ca, 0x4eb3, { 0xa8, 0xe0, 0x6c, 0xc6, 0x19, 0x43, 0x7b, 0xf2 } }, "F_VN_ClosestPointsBF", nullptr }, \
	{ { 0xb182aac0, 0xa4c5, 0x4494, { 0x83, 0x10, 0x0d, 0x87, 0xc7, 0x96, 0xfb, 0x99 } }, "F_VN_CompensateLensDistortion", nullptr }, \
	{ { 0x2bffccc7, 0xf8e6, 0x488f, { 0x84, 0x84, 0x1a, 0x42, 0x86, 0xce, 0xc7, 0x19 } }, "F_VN_CompensateLensDistortionExp1", nullptr }, \
	{ { 0xd464934b, 0xbde3, 0x488d, { 0xa0, 0x80, 0xb5, 0x45, 0xfb, 0x67, 0x3b, 0x69 } }, "F_VN_CompensateLensDistortionExp2", nullptr }, \
	{ { 0x0c1a11ac, 0x434f, 0x48b9, { 0xb8, 0xa1, 0x9a, 0x50, 0x26, 0x1e, 0x04, 0x03 } }, "F_VN_CompensateLensDistortionForPoints", nullptr }, \
	{ { 0x6defc618, 0x4078, 0x4891, { 0x89, 0x83, 0xb5, 0xc9, 0xff, 0x0f, 0xaf, 0x8d } }, "F_VN_CompensateLensDistortionForPointsExp1", nullptr }, \
	{ { 0x223e92f7, 0xf50f, 0x42a5, { 0xab, 0x07, 0x3b, 0x6f, 0x1f, 0x20, 0x5e, 0x58 } }, "F_VN_CompensateLensDistortionForPointsExp2", nullptr }, \
	{ { 0x19be9da1, 0xf691, 0x4052, { 0xb0, 0xb9, 0x3e, 0xbf, 0x56, 0x3b, 0xd7, 0x87 } }, "F_VN_DetectPatternPointsExp", nullptr }, \
	{ { 0x4ff19ef9, 0x2a68, 0x4595, { 0xac, 0xfb, 0x4b, 0x2f, 0x40, 0xa0, 0xf0, 0x2e } }, "F_VN_GenerateCalibrationPatternReferencePoints", nullptr }, \
	{ { 0x113321d0, 0x0af1, 0x4967, { 0x98, 0xe6, 0xef, 0x4a, 0x4f, 0xdc, 0xff, 0x75 } }, "F_VN_ImagePointsWorldDistance", nullptr }, \
	{ { 0x30d3bc8b, 0x54e8, 0x4912, { 0x89, 0xab, 0x6e, 0xb1, 0xa8, 0xf8, 0x33, 0xed } }, "F_VN_LocateCircularArcExp2", nullptr }, \
	{ { 0x370c553d, 0x8cfe, 0x46b5, { 0x82, 0xf1, 0x44, 0xfb, 0x4f, 0xf4, 0x0a, 0xd3 } }, "F_VN_LocateEdgeExp2", nullptr }, \
	{ { 0x4295201a, 0x7b19, 0x46bb, { 0xb3, 0x44, 0xbf, 0x3b, 0xad, 0xe8, 0x15, 0x72 } }, "F_VN_LocateEdgesExp2", nullptr }, \
	{ { 0xba64d578, 0xdb82, 0x475b, { 0xba, 0xf5, 0xd8, 0xf7, 0xc5, 0xe0, 0x61, 0x0c } }, "F_VN_LocateEllipseExp2", nullptr }, \
	{ { 0x273f3b6d, 0x72f7, 0x420c, { 0x97, 0xa3, 0x1d, 0x1b, 0xb6, 0x87, 0x28, 0x74 } }, "F_VN_MeasureAngleBetweenEdgesExp2", nullptr }, \
	{ { 0xba78e4ed, 0xa2f6, 0x4725, { 0xa7, 0x90, 0x71, 0xa8, 0x7e, 0x9f, 0xa1, 0xdc } }, "F_VN_MeasureEdgeDistanceExp2", nullptr }, \
	{ { 0xaa68236b, 0xfdfb, 0x406e, { 0x86, 0xab, 0xfc, 0x51, 0xcb, 0x5a, 0x8a, 0xa4 } }, "F_VN_MeasureMinEdgeDistanceExp2", nullptr }, \
	{ { 0x586ca80d, 0x0a36, 0x4552, { 0xb0, 0xf9, 0x24, 0x78, 0x50, 0xb4, 0xe8, 0x40 } }, "F_VN_SolvePnPExp", nullptr }, \
	{ { 0xb3789593, 0x5f6f, 0x46eb, { 0xb5, 0x08, 0x09, 0x40, 0x55, 0x1e, 0xb7, 0x54 } }, "F_VN_SortDetectedPatternPoints", nullptr }, \
	{ { 0x42a826a7, 0x5679, 0x424d, { 0xa7, 0x80, 0x11, 0xbd, 0x34, 0x68, 0x90, 0x86 } }, "F_VN_TransformCoordinatesImageToWorld_Container", nullptr }, \
	{ { 0x958acf51, 0x628a, 0x4389, { 0x91, 0x6d, 0x00, 0x29, 0xbb, 0xb6, 0xfd, 0xd8 } }, "F_VN_TransformCoordinatesImageToWorld_Point", nullptr }, \
	{ { 0xd0be3ba3, 0x4d79, 0x4dc1, { 0x91, 0xfc, 0xae, 0x80, 0x8b, 0x19, 0x7c, 0xa6 } }, "F_VN_TransformCoordinatesWorldToImage_Container", nullptr }, \
	{ { 0x948c5283, 0x6e9d, 0x46a3, { 0x93, 0xa3, 0x5f, 0xde, 0xcb, 0x3a, 0xf8, 0xa8 } }, "F_VN_TransformCoordinatesWorldToImage_Point", nullptr },
#else
	#define DEFINE_TC3_Vision_Metrology_2D_FUNCS
#endif

#ifdef LIC_TC3_Vision_Matching
	#define DEFINE_TC3_Vision_Matching_FUNCS \
	{ { 0xc498660f, 0xa442, 0x44ae, { 0x90, 0xb2, 0x75, 0xe3, 0x73, 0x26, 0x39, 0x5a } }, "F_VN_DrawKeypointsExp", nullptr }, \
	{ { 0x4f18b464, 0x18e8, 0x44c1, { 0x9b, 0x7b, 0x33, 0x9d, 0xa5, 0xde, 0x67, 0x09 } }, "F_VN_DrawMatchesExp", nullptr }, \
	{ { 0x96268b41, 0x4223, 0x4e18, { 0xb3, 0x28, 0x04, 0xa7, 0x4d, 0x19, 0x76, 0xbe } }, "F_VN_FilterGoodMatches", nullptr }, \
	{ { 0xd31cf0d6, 0x437a, 0x48b3, { 0x96, 0x22, 0x97, 0xc7, 0xbe, 0xf8, 0x4e, 0x82 } }, "F_VN_FindReferenceKeyPointsInImageExp", nullptr }, \
	{ { 0x4c4b02cf, 0xf4ee, 0x4857, { 0x8b, 0x59, 0x06, 0x19, 0x1f, 0x89, 0x0f, 0xa0 } }, "F_VN_FindReferenceKeyPointsInImageAKAZEExp", nullptr }, \
	{ { 0x92d37882, 0xee73, 0x4826, { 0x8c, 0xf0, 0x23, 0x06, 0x9a, 0x3a, 0x7e, 0xf9 } }, "F_VN_FindReferenceKeyPointsInImageBRISKExp", nullptr }, \
	{ { 0x6c9aaf19, 0xcf54, 0x4825, { 0xa5, 0xba, 0x04, 0x31, 0xad, 0x97, 0xae, 0xf7 } }, "F_VN_FindReferenceKeyPointsInImageORBExp", nullptr }, \
	{ { 0xdee7a2e6, 0xc732, 0x4f08, { 0xaa, 0xcb, 0x02, 0x2e, 0x35, 0x9e, 0xbe, 0x0d } }, "F_VN_GetMatchCoordinates", nullptr }, \
	{ { 0x8a0c3c75, 0x6843, 0x45e1, { 0xab, 0x5c, 0x2c, 0xdc, 0x72, 0x23, 0x80, 0xbb } }, "F_VN_KeyPointsAGASTExp", nullptr }, \
	{ { 0x7d9d8918, 0xebbc, 0x4aa3, { 0x9c, 0xfc, 0x21, 0x6b, 0x6c, 0xb3, 0xaa, 0xea } }, "F_VN_KeyPointsAndDescriptorsAKAZEExp", nullptr }, \
	{ { 0xcc0679ad, 0x582c, 0x415f, { 0xbe, 0x02, 0x21, 0xcc, 0xfd, 0x71, 0x6a, 0x66 } }, "F_VN_KeyPointsAndDescriptorsBRISKExp", nullptr }, \
	{ { 0xbda6dc1b, 0x51ca, 0x4039, { 0xb0, 0xde, 0x26, 0x44, 0x0e, 0x28, 0xab, 0x56 } }, "F_VN_KeyPointsAndDescriptorsKAZEExp", nullptr }, \
	{ { 0xf4a5a4e9, 0x81d5, 0x4fd7, { 0xb1, 0x5a, 0x48, 0x87, 0x2c, 0xc6, 0x0e, 0x06 } }, "F_VN_KeyPointsAndDescriptorsORBExp", nullptr }, \
	{ { 0x9f779731, 0x0a31, 0x48f9, { 0x86, 0x16, 0xee, 0x60, 0xdb, 0xbc, 0x95, 0x3f } }, "F_VN_KeyPointsFASTExp", nullptr }, \
	{ { 0xd156c50c, 0x782c, 0x48c4, { 0xbf, 0xe5, 0xee, 0x75, 0x7e, 0x5d, 0x3d, 0x0f } }, "F_VN_KeyPointsGFTTExp", nullptr }, \
	{ { 0xd1d16501, 0xa91f, 0x4db5, { 0x96, 0xd9, 0xc5, 0x0c, 0x31, 0xd5, 0xe8, 0xf0 } }, "F_VN_KeyPointsMSERExp", nullptr }, \
	{ { 0xfbc736ee, 0x5a1b, 0x4c86, { 0x98, 0xae, 0x09, 0x35, 0x3d, 0x04, 0x8e, 0xea } }, "F_VN_KeyPointsSBExp", nullptr }, \
	{ { 0x103e144a, 0x0f54, 0x4328, { 0xa8, 0x3b, 0x69, 0x10, 0x23, 0xc4, 0x15, 0x27 } }, "F_VN_MatchContoursExp", nullptr }, \
	{ { 0x9527fdc4, 0xfe0f, 0x4a13, { 0xa9, 0x05, 0xca, 0xda, 0x8f, 0xad, 0xb7, 0x28 } }, "F_VN_MatchContours1vsNExp", nullptr }, \
	{ { 0x38b073fb, 0xa78e, 0x46ee, { 0xb8, 0xa8, 0x44, 0x49, 0x16, 0x3d, 0xf3, 0xd9 } }, "F_VN_MatchDescriptorsBFExp", nullptr }, \
	{ { 0xdc87279d, 0xc653, 0x4582, { 0xb4, 0x42, 0x63, 0x85, 0xd0, 0xe0, 0x23, 0x20 } }, "F_VN_MatchDescriptorsFlannLshExp", nullptr }, \
	{ { 0x356c0c8e, 0xd500, 0x40f9, { 0xb3, 0x73, 0xe5, 0xc1, 0x33, 0xfd, 0xab, 0x55 } }, "F_VN_MatchDescriptorsKnnBFExp", nullptr }, \
	{ { 0xbeaf5153, 0x1788, 0x4be9, { 0x98, 0x9d, 0x79, 0x15, 0xf1, 0x9f, 0xb2, 0x96 } }, "F_VN_MatchDescriptorsKnnFlannLshExp", nullptr }, \
	{ { 0x778b8991, 0x7e2e, 0x4345, { 0x8f, 0x86, 0x9e, 0x95, 0xea, 0x77, 0xb6, 0x80 } }, "F_VN_MatchImageHuMoments", nullptr }, \
	{ { 0x248f66c9, 0xf1af, 0x44c5, { 0xb5, 0xa3, 0xbd, 0x55, 0xf4, 0x41, 0xbe, 0x70 } }, "F_VN_MatchTemplateExp", nullptr }, \
	{ { 0x4070b30d, 0x784f, 0x463d, { 0xb7, 0xca, 0x23, 0xf2, 0x7c, 0x32, 0x02, 0xee } }, "F_VN_MatchTemplateAndEvaluateExp", nullptr }, \
	{ { 0x9ebb31ec, 0xbf88, 0x4514, { 0xbd, 0x74, 0xc5, 0x1b, 0x57, 0xa9, 0xe2, 0x36 } }, "F_VN_RegionsMSERExp", nullptr },
#else
	#define DEFINE_TC3_Vision_Matching_FUNCS
#endif

#ifdef LIC_TC3_Vision_OCR
	#define DEFINE_TC3_Vision_OCR_FUNCS \
	{ { 0x643a41c0, 0x6fdf, 0x4078, { 0xac, 0x36, 0xc1, 0xb8, 0x2e, 0xcd, 0xfb, 0x75 } }, "F_VN_OCRExp", nullptr },
#else
	#define DEFINE_TC3_Vision_OCR_FUNCS
#endif

#ifdef LIC_TC3_Machine_Learning_Realtime_Inference
	#define DEFINE_TC3_Machine_Learning_Realtime_Inference_FUNCS \
	{ { 0xfe24a9d9, 0x399d, 0x4912, { 0xaf, 0x0b, 0x94, 0x75, 0x00, 0x2d, 0x40, 0x04 } }, "F_VN_CreateBoostClassifierExp2", nullptr }, \
	{ { 0x00ec1919, 0xfe97, 0x4e04, { 0xb9, 0x20, 0x3c, 0x8a, 0x44, 0x51, 0x83, 0x96 } }, "F_VN_CreateKmppModelExp", nullptr }, \
	{ { 0xae4ea5d4, 0xdd6a, 0x4d1b, { 0xb8, 0x85, 0x91, 0x07, 0x5c, 0x24, 0xb4, 0xd6 } }, "F_VN_CreateKnnModel", nullptr }, \
	{ { 0xec0b352f, 0xaae0, 0x4e0f, { 0x9f, 0xda, 0x0b, 0x12, 0x52, 0x79, 0x79, 0x28 } }, "F_VN_CreateLbgModelExp", nullptr }, \
	{ { 0x2e656907, 0xd35e, 0x4631, { 0xa0, 0xa1, 0xe1, 0xb2, 0x80, 0x92, 0x42, 0x82 } }, "F_VN_CreateLdaTransform", nullptr }, \
	{ { 0x0a6144e4, 0xdd38, 0x4b7f, { 0xb4, 0x4a, 0x7e, 0x87, 0xbd, 0xdb, 0xf0, 0x3f } }, "F_VN_CreateLdaTransformViaComponentNum", nullptr }, \
	{ { 0x4b89c4bb, 0xc130, 0x4eb5, { 0xb1, 0x25, 0x58, 0x5a, 0xc3, 0xd0, 0x3a, 0x7b } }, "F_VN_CreateNbcModel", nullptr }, \
	{ { 0x4bafc7fb, 0x0ac5, 0x4198, { 0x87, 0x41, 0xd0, 0x05, 0xef, 0x17, 0x88, 0xbd } }, "F_VN_CreatePcaTransform", nullptr }, \
	{ { 0xb99b4c52, 0xa4e8, 0x4eb1, { 0x90, 0x20, 0xa9, 0x3e, 0x19, 0xba, 0x86, 0xa7 } }, "F_VN_CreatePcaTransformViaComponentNum", nullptr }, \
	{ { 0x8c8bbbc3, 0xfa8c, 0x4a16, { 0xbd, 0xfb, 0x51, 0x2a, 0xa7, 0xca, 0x11, 0x47 } }, "F_VN_CreatePcaTransformViaVariance", nullptr }, \
	{ { 0x5aa1070b, 0xef56, 0x4f3a, { 0xb4, 0x19, 0xe8, 0x11, 0xc3, 0xea, 0xa6, 0x6c } }, "F_VN_CreateRTreesModelExp2", nullptr }, \
	{ { 0x2542eb02, 0x732f, 0x4390, { 0x94, 0x0d, 0x45, 0x1d, 0x47, 0x51, 0x67, 0xe0 } }, "F_VN_CreateStaModelExp2", nullptr }, \
	{ { 0x96cda660, 0xbff4, 0x487d, { 0x95, 0x5c, 0x78, 0xfe, 0x27, 0x51, 0xe7, 0x48 } }, "F_VN_CreateSvmModelExp2", nullptr }, \
	{ { 0xcc69790b, 0x2940, 0x4d97, { 0x81, 0xf5, 0xaa, 0x18, 0x6f, 0x81, 0x47, 0xb3 } }, "F_VN_CreateSvmSgdClassifierExp", nullptr }, \
	{ { 0x70d9e34c, 0xc39d, 0x43ba, { 0x9c, 0x43, 0x1d, 0xf7, 0x27, 0x28, 0x9a, 0x75 } }, "F_VN_FeatureScalingExp", nullptr }, \
	{ { 0x3f1ffe8c, 0x29e7, 0x4011, { 0xa3, 0x89, 0xcb, 0x9a, 0xf8, 0x7d, 0xee, 0xb2 } }, "F_VN_FeatureTransform", nullptr }, \
	{ { 0x133fea86, 0xc5df, 0x4f68, { 0xac, 0xb7, 0x0a, 0xfa, 0x1b, 0x4d, 0x82, 0x00 } }, "F_VN_GetBatchClustersExp", nullptr }, \
	{ { 0x8523fae1, 0x2197, 0x453e, { 0x9b, 0xe6, 0x65, 0x08, 0xb3, 0x26, 0x0a, 0xb8 } }, "F_VN_GetBatchNovelties", nullptr }, \
	{ { 0xf694eac1, 0xb735, 0x440f, { 0x93, 0xd7, 0x51, 0x3d, 0x11, 0xe6, 0xe1, 0xf6 } }, "F_VN_GetClusterCenter", nullptr }, \
	{ { 0xad9728cb, 0xc9b8, 0x4ff0, { 0xb1, 0xc7, 0xff, 0x66, 0x8f, 0x24, 0xb0, 0x75 } }, "F_VN_GetClusterNum", nullptr }, \
	{ { 0x072ecc31, 0xa2e4, 0x4438, { 0x91, 0x57, 0x20, 0x62, 0x26, 0xd7, 0x8c, 0x7a } }, "F_VN_GetFeatureScales", nullptr }, \
	{ { 0xcd6f249d, 0x7ee9, 0x46be, { 0x91, 0x16, 0xf4, 0x4c, 0xd9, 0x59, 0x50, 0xbe } }, "F_VN_GetSampleClusterExp", nullptr }, \
	{ { 0x2baf8c13, 0xe3f0, 0x4eca, { 0x93, 0x87, 0x68, 0xf0, 0x69, 0x87, 0x32, 0x9c } }, "F_VN_GetSampleNovelty", nullptr }, \
	{ { 0x64caecec, 0x3ab9, 0x41f9, { 0x94, 0x2e, 0x65, 0x45, 0xcd, 0xa2, 0xa0, 0xa1 } }, "F_VN_Granulometry", nullptr }, \
	{ { 0x49cd891a, 0x428f, 0x466b, { 0xb1, 0x3b, 0x42, 0xef, 0x34, 0x84, 0xf4, 0x65 } }, "F_VN_HaralickFeatures", nullptr }, \
	{ { 0x7216595e, 0x86cf, 0x4671, { 0xa5, 0x2a, 0x70, 0x33, 0x08, 0x90, 0x6a, 0x5b } }, "F_VN_InverseFeatureScalingExp", nullptr }, \
	{ { 0xdbb0c2f3, 0x7f97, 0x442c, { 0xab, 0x3c, 0x58, 0xc8, 0xd0, 0xcb, 0x34, 0xe0 } }, "F_VN_InverseFeatureScalingExp_REAL", nullptr }, \
	{ { 0x24fd917a, 0x14d3, 0x428b, { 0x82, 0xc7, 0x60, 0x84, 0xaf, 0x07, 0x39, 0x44 } }, "F_VN_InverseFeatureTransform", nullptr }, \
	{ { 0xd18811dd, 0x3304, 0x4c44, { 0x9c, 0x54, 0x79, 0xc4, 0xb2, 0xf7, 0xf1, 0x3d } }, "F_VN_PredictBatchExp", nullptr }, \
	{ { 0x68ff3182, 0x17fe, 0x4072, { 0x8a, 0x8f, 0x29, 0xa8, 0x90, 0xb7, 0xcd, 0xff } }, "F_VN_PredictSampleClassExp", nullptr }, \
	{ { 0x20159c43, 0x14de, 0x46ec, { 0xa8, 0x4c, 0xc7, 0x63, 0xc0, 0xae, 0x4e, 0x57 } }, "F_VN_PredictSampleScalarExp", nullptr }, \
	{ { 0x1118f9b0, 0x190e, 0x404f, { 0xaa, 0x85, 0x56, 0xa0, 0xfb, 0x7a, 0xf1, 0x77 } }, "F_VN_PredictSampleVectorExp", nullptr }, \
	{ { 0x65938293, 0x2a61, 0x429d, { 0xa4, 0x5c, 0x3a, 0x82, 0x19, 0xdc, 0xcb, 0x8d } }, "F_VN_TrainBatch", nullptr }, \
	{ { 0x314174f8, 0x0661, 0x465d, { 0x97, 0x34, 0x82, 0x4d, 0xd9, 0x4e, 0xbc, 0x30 } }, "F_VN_TrainBatchClusters", nullptr }, \
	{ { 0x790dd853, 0x653e, 0x4257, { 0x95, 0x5a, 0x80, 0xb0, 0xf6, 0x2c, 0x57, 0x86 } }, "F_VN_TrainSample", nullptr }, \
	{ { 0x13cde622, 0x0656, 0x4326, { 0x93, 0xe4, 0xc6, 0xf9, 0x6f, 0x59, 0xe9, 0x14 } }, "F_VN_TrainSampleClass", nullptr }, \
	{ { 0x2255cc70, 0x8dfa, 0x47ac, { 0x9b, 0x5e, 0x14, 0xae, 0xd1, 0xaa, 0xd9, 0x4e } }, "F_VN_TrainSampleCluster", nullptr }, \
	{ { 0x4ad6aa37, 0xd31c, 0x4c7f, { 0x99, 0x7c, 0xf1, 0xd0, 0xa9, 0xcb, 0x77, 0x36 } }, "F_VN_TrainSampleScalar", nullptr }, \
	{ { 0xb38de66e, 0xfe98, 0x4746, { 0x94, 0xea, 0xfe, 0x3a, 0x81, 0x00, 0x4c, 0x7d } }, "F_VN_TrainSampleVector", nullptr },
#else
	#define DEFINE_TC3_Machine_Learning_Realtime_Inference_FUNCS
#endif

#ifdef LIC_TC3_Neural_Network_Realtime_Inference
	#define DEFINE_TC3_Neural_Network_Realtime_Inference_FUNCS \
	{ { 0xe8f6bbec, 0x0691, 0x4a65, { 0x8e, 0xcd, 0x66, 0x87, 0x55, 0xd7, 0x90, 0xc5 } }, "F_VN_ExecuteNeuralNetwork", nullptr }, \
	{ { 0x306495df, 0xd569, 0x4264, { 0xa0, 0x5e, 0x30, 0xe4, 0x19, 0xed, 0x74, 0x7a } }, "F_VN_ExecuteNeuralNetwork_MI", nullptr }, \
	{ { 0xf0a09fcd, 0x237f, 0x45f9, { 0x99, 0x94, 0xe4, 0x5a, 0x24, 0x34, 0xa7, 0xfb } }, "F_VN_ExecuteNeuralNetwork_MIMO_String", nullptr }, \
	{ { 0x46e8b7b2, 0x7862, 0x4136, { 0x89, 0x09, 0xef, 0x8d, 0xe5, 0xc0, 0x9c, 0x81 } }, "F_VN_ExecuteNeuralNetwork_MISO", nullptr }, \
	{ { 0xe375edcf, 0xde30, 0x4478, { 0x94, 0xdf, 0xa2, 0x30, 0x4b, 0xd6, 0xe3, 0x9f } }, "F_VN_ExecuteNeuralNetwork_MO", nullptr }, \
	{ { 0x4c4925bb, 0xee04, 0x4e54, { 0xaa, 0xee, 0x06, 0xdb, 0xea, 0x05, 0x9a, 0xfc } }, "F_VN_ExecuteNeuralNetwork_MultiLayerOutput", nullptr }, \
	{ { 0x930f4894, 0xf7c6, 0x454a, { 0xaf, 0xa8, 0x35, 0xe5, 0x52, 0xf6, 0x03, 0x8d } }, "F_VN_ExecuteNeuralNetwork_SingleLayerOutput", nullptr }, \
	{ { 0x2199fe20, 0xdfd5, 0x4fc5, { 0x80, 0x84, 0xa6, 0x39, 0xc5, 0x6b, 0xe3, 0x0c } }, "F_VN_ExecuteNeuralNetwork_SO", nullptr }, \
	{ { 0xabbda4a0, 0xdcd4, 0x4004, { 0xa1, 0x6c, 0x8d, 0xc7, 0x25, 0x7e, 0xbb, 0x16 } }, "F_VN_GetNeuralNetworkLayerNames", nullptr }, \
	{ { 0xea42dd1e, 0xafe8, 0x426d, { 0x82, 0x5f, 0xb2, 0x89, 0x44, 0x64, 0xd1, 0xc5 } }, "F_VN_GetNeuralNetworkLayerNamesExp", nullptr }, \
	{ { 0x046c3d59, 0x9537, 0x405a, { 0xaf, 0x5c, 0x62, 0xa4, 0x6e, 0x6c, 0x70, 0xa7 } }, "F_VN_GetNeuralNetworkLayerNamesExp_String", nullptr },
#else
	#define DEFINE_TC3_Neural_Network_Realtime_Inference_FUNCS
#endif

#ifdef LIC_TC3_Vision_Base
	#define DEFINE_TC3_Vision_Base_FBS \
	{ { 0xa97550b4, 0xfe90, 0x4484, { 0x8a, 0xd8, 0x52, 0x61, 0x2d, 0x2d, 0xc1, 0x45 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0GETCURRENTIMAGE\0GETCURRENTIMAGEANDFILENAME\0STARTACQUISITION\0STOPACQUISITION\0RESET\0GETSTATE\0TRIGGERIMAGE\0TRIGGERIMAGEEXP\0TRIGGERIMAGEBYNAME\0", FB_VN_FileSourceControl_Methods }, \
	{ { 0xf6a82428, 0xc67b, 0x4961, { 0xbc, 0xde, 0x1a, 0xa2, 0x95, 0xdc, 0xee, 0x83 } }, "FB_MAIN\0CLEARIMAGEQUEUE\0CLOSECAMERA\0FB_EXIT\0FB_INIT\0GETCALIBPATTERNREF\0GETCAMERAMATRIX\0GETCURRENTIMAGE\0GETCURRENTIMAGEUNDISTORTED\0GETCURRENTIMAGEWITHGVSPINFO\0GETCURRENTIMAGEWITHGVSPINFOUNDISTORTED\0GETCURRENTIMAGEWITHTIMESTAMPS\0GETDISTORTIONCOEFFICIENTS\0GETLASTIMAGEFROMQUEUE\0GETOMITTEDIMAGESNUM\0GETROTATIONMATRIX\0GETSTATE\0GETTRANSLATIONVECTOR\0INITIALIZECAMERA\0OPENCAMERA\0RESET\0RESETCAMERAFEATURES\0SETCAMERAMATRIX\0SETDISTORTIONCOEFFICIENTS\0SETROTATIONMATRIX\0SETTRANSLATIONVECTOR\0STARTACQUISITION\0STOPACQUISITION\0TRIGGERIMAGE\0", FB_VN_GevCameraControl_Methods }, \
	{ { 0xd7513f19, 0xdc83, 0x44cc, { 0x91, 0x49, 0xd2, 0x40, 0x35, 0x77, 0xa1, 0x39 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_InitializeFunction_Methods }, \
	{ { 0x155f488c, 0x7812, 0x4694, { 0x8c, 0xfd, 0xe1, 0x77, 0x8b, 0x65, 0x80, 0xd4 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadCalibrationPattern_Methods }, \
	{ { 0xf8133003, 0x0b27, 0x42ad, { 0xb8, 0xdb, 0xd9, 0xb0, 0x4c, 0x28, 0xfe, 0x7c } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadCalibrationResult_Methods }, \
	{ { 0xef8f5a43, 0xa597, 0x4632, { 0xb5, 0xe8, 0xdf, 0x38, 0xff, 0xd1, 0x39, 0x77 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadContainer_Methods }, \
	{ { 0x7add30e2, 0xd87f, 0x46df, { 0xa8, 0x38, 0x66, 0x7c, 0x8a, 0x3a, 0xaa, 0x4c } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadImage_Methods }, \
	{ { 0x0d2253d2, 0x07a0, 0x497f, { 0x93, 0xa3, 0xb1, 0x2d, 0xe4, 0x9f, 0x15, 0x68 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadMemory_Methods }, \
	{ { 0xa603e909, 0x35a9, 0x4559, { 0xb4, 0x6b, 0xec, 0xeb, 0xb0, 0x6d, 0xc4, 0x42 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadMlModel_Methods }, \
	{ { 0x330b4672, 0xefee, 0x4213, { 0xa4, 0x19, 0x2d, 0x59, 0xa5, 0xcc, 0x95, 0x94 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadNeuralNetwork_Methods }, \
	{ { 0x7a1872dc, 0x8037, 0x4613, { 0x9c, 0xfd, 0xb9, 0x14, 0x8d, 0x09, 0x6d, 0x98 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadRegister_REAL_Methods }, \
	{ { 0x205bcad0, 0xeb00, 0x45dc, { 0xaa, 0xb0, 0xe7, 0x55, 0x2f, 0x8e, 0x42, 0x3b } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadRegister_UDINT_Methods }, \
	{ { 0xfc0970da, 0xd1e4, 0x4b34, { 0xa1, 0x35, 0x0d, 0x98, 0x61, 0x5c, 0x3b, 0xde } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_ReadRegister_ULINT_Methods }, \
	{ { 0x235bceaf, 0xaf1d, 0x4e14, { 0x99, 0xd6, 0x10, 0x9d, 0x74, 0x6d, 0xe1, 0xc9 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0GETCURRENTIMAGE\0GETSTATE\0RESET\0STARTACQUISITION\0STOPACQUISITION\0TRIGGERIMAGE\0", FB_VN_SimpleCameraControl_Methods }, \
	{ { 0x8e6a02c2, 0x4348, 0x499b, { 0xa3, 0xd7, 0x89, 0x51, 0xff, 0xf7, 0xa1, 0xe3 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteCalibrationResult_Methods }, \
	{ { 0xdfaeb46a, 0xa5dc, 0x4630, { 0xb6, 0xe3, 0xd8, 0x22, 0xe7, 0xe4, 0xab, 0xcb } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteContainer_Methods }, \
	{ { 0x31aeff44, 0x3ed7, 0x4af7, { 0xb7, 0x30, 0x6c, 0xf2, 0xc5, 0xf1, 0x10, 0x9e } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteImage_Methods }, \
	{ { 0x180241c8, 0x4eb9, 0x425b, { 0x80, 0x28, 0x78, 0x16, 0xaa, 0xdb, 0x97, 0x3d } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteMemory_Methods }, \
	{ { 0xbfe1c576, 0x90db, 0x430f, { 0x92, 0x21, 0x8f, 0x44, 0x08, 0x41, 0xaf, 0x89 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteMlModel_Methods }, \
	{ { 0x6d1ea6a5, 0x074b, 0x4f60, { 0x99, 0x16, 0xa5, 0x29, 0xc5, 0xfe, 0x9d, 0x8d } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteRegister_REAL_Methods }, \
	{ { 0x3e07f848, 0x3043, 0x4f7e, { 0xb4, 0x72, 0x89, 0x9f, 0x8d, 0x4a, 0xac, 0x99 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteRegister_UDINT_Methods }, \
	{ { 0x645f7bcc, 0x101e, 0x4727, { 0x88, 0x19, 0x7d, 0xa9, 0x3a, 0xcf, 0x14, 0xe8 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0", FB_VN_WriteRegister_ULINT_Methods },
#else
	#define DEFINE_TC3_Vision_Base_FBS
#endif

#ifdef LIC_TC3_Vision_Code_Reading
	#define DEFINE_TC3_Vision_Code_Reading_FBS
#else
	#define DEFINE_TC3_Vision_Code_Reading_FBS
#endif

#ifdef LIC_TC3_Vision_Code_Quality
	#define DEFINE_TC3_Vision_Code_Quality_FBS
#else
	#define DEFINE_TC3_Vision_Code_Quality_FBS
#endif

#ifdef LIC_TC3_Vision_Metrology_2D
	#define DEFINE_TC3_Vision_Metrology_2D_FBS
#else
	#define DEFINE_TC3_Vision_Metrology_2D_FBS
#endif

#ifdef LIC_TC3_Vision_Matching
	#define DEFINE_TC3_Vision_Matching_FBS \
	{ { 0x595f31a6, 0x684d, 0x4726, { 0xb5, 0xe0, 0xfb, 0xef, 0xc4, 0xbc, 0x7a, 0xe0 } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0DETECT\0SETCANNYTHRESHOLD\0SETINVACCURATIO\0SETLEVELS\0SETMINDIST\0SETTEMPLATE\0SETVOTESTHRESHOLD\0", FB_VN_GeneralizedHoughBallard_Methods }, \
	{ { 0xb96dee08, 0xdb11, 0x4de2, { 0xb0, 0xcc, 0x2f, 0x6e, 0x94, 0xef, 0x4a, 0x2f } }, "FB_MAIN\0FB_EXIT\0FB_INIT\0COMPUTE\0SETREFERENCE\0", FB_VN_SSIM_Methods },
#else
	#define DEFINE_TC3_Vision_Matching_FBS
#endif

#ifdef LIC_TC3_Vision_OCR
	#define DEFINE_TC3_Vision_OCR_FBS
#else
	#define DEFINE_TC3_Vision_OCR_FBS
#endif

#ifdef LIC_TC3_Machine_Learning_Realtime_Inference
	#define DEFINE_TC3_Machine_Learning_Realtime_Inference_FBS
#else
	#define DEFINE_TC3_Machine_Learning_Realtime_Inference_FBS
#endif

#ifdef LIC_TC3_Neural_Network_Realtime_Inference
	#define DEFINE_TC3_Neural_Network_Realtime_Inference_FBS
#else
	#define DEFINE_TC3_Neural_Network_Realtime_Inference_FBS
#endif

#define DEFINE_LIBRARY_INFO_Tc3_Vision \
namespace Tc3_Vision \
{ \
	TcTmlVersionedLibraryFunction libraryFunctions[TotalFuncs + 1] = \
	{ \
		DEFINE_TC3_Vision_Base_FUNCS \
		DEFINE_TC3_Vision_Code_Reading_FUNCS \
		DEFINE_TC3_Vision_Code_Quality_FUNCS \
		DEFINE_TC3_Vision_Metrology_2D_FUNCS \
		DEFINE_TC3_Vision_Matching_FUNCS \
		DEFINE_TC3_Vision_OCR_FUNCS \
		DEFINE_TC3_Machine_Learning_Realtime_Inference_FUNCS \
		DEFINE_TC3_Neural_Network_Realtime_Inference_FUNCS \
		{ GUID_NULL, nullptr, nullptr } \
	}; \
 \
	TcTmlFunctionPointer FB_VN_FileSourceControl_Methods[12] = { }; \
	TcTmlFunctionPointer FB_VN_GeneralizedHoughBallard_Methods[10] = { }; \
	TcTmlFunctionPointer FB_VN_GevCameraControl_Methods[29] = { }; \
	TcTmlFunctionPointer FB_VN_InitializeFunction_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadCalibrationPattern_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadCalibrationResult_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadContainer_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadImage_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadMemory_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadMlModel_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadNeuralNetwork_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadRegister_REAL_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadRegister_UDINT_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_ReadRegister_ULINT_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_SimpleCameraControl_Methods[9] = { }; \
	TcTmlFunctionPointer FB_VN_SSIM_Methods[5] = { }; \
	TcTmlFunctionPointer FB_VN_WriteCalibrationResult_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_WriteContainer_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_WriteImage_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_WriteMemory_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_WriteMlModel_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_WriteRegister_REAL_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_WriteRegister_UDINT_Methods[3] = { }; \
	TcTmlFunctionPointer FB_VN_WriteRegister_ULINT_Methods[3] = { }; \
 \
	TcTmlVersionedLibraryFB libraryFBs[TotalFBs + 1] = \
	{ \
		DEFINE_TC3_Vision_Base_FBS \
		DEFINE_TC3_Vision_Code_Reading_FBS \
		DEFINE_TC3_Vision_Code_Quality_FBS \
		DEFINE_TC3_Vision_Metrology_2D_FBS \
		DEFINE_TC3_Vision_Matching_FBS \
		DEFINE_TC3_Vision_OCR_FBS \
		DEFINE_TC3_Machine_Learning_Realtime_Inference_FBS \
		DEFINE_TC3_Neural_Network_Realtime_Inference_FBS \
		{ GUID_NULL, nullptr, nullptr } \
	}; \
 \
	TcTmlVersionedLibraryInfo libraryInfo = \
	{ \
		VID_Tc3_Vision, \
		libraryFunctions, \
		libraryFBs, \
		Tc3_Vision_LibraryIdNameStr, \
		Tc3_Vision_FileVersionStr, \
		Tc3_Vision_InternalNameStr, \
		Tc3_Vision_CompanyNameStr \
	}; \
}

#pragma warning(pop)
