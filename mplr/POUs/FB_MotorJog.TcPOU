<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotorJog" Id="{572e2650-5346-4e2a-bd24-17aaf2aabb29}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotorJog EXTENDS FB_SolidSamplingModule
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	
	/// axis reference data structure 
	Axis1: AXIS_REF;
	/// state machine state 
	state: MoveState_t;
	PowerAxis1: MC_Power;
	/// debug function block output data 
	PowerAxis1Out: ST_McOutputs;
	MoveAxis1: MC_MoveAbsolute;
	/// debug function block output data 
	MoveAbsoluteOut1: ST_McOutputs;
// 	MoveAxis2: MC_MoveAbsolute;
	/// debug function block output data 
// 	MoveAbsoluteOut2: ST_McOutputs;
	Reset: MC_Reset;
	/// debug function block output data 
	ResetOut: ST_McOutputs;
	
	HaltAxis1: MC_Halt;
	
	bEnable	:	BOOL := FALSE;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="EnablePower" Id="{bbd8026d-cdfa-44b8-9db6-db11045b5e31}">
      <Declaration><![CDATA[METHOD EnablePower : BOOL
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Axis1.ReadStatus();

PowerAxis1(
	Axis:=Axis1, 
	Enable:= bEnable, 
	Status=> , 
	Busy=> , 
	Active=> , 
	Error=> , 
	ErrorID=> );]]></ST>
      </Implementation>
    </Method>
    <Method Name="METH" Id="{4f1f4daf-18c2-495e-94c9-7298abe5d79b}">
      <Declaration><![CDATA[METHOD METH : BOOL
VAR_INPUT
	bMove : BOOL;
	nIdlePosition : INT; // 1: 63, 2: 70
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nIdlePosition < 1 OR nIdlePosition > 2 THEN		// Rejects other Position values
	nIdlePosition := 2;
END_IF

Axis1();

CASE state OF
	MOVESTATE_INIT :	(* initialisation *)
		MoveAxis1.Execute := FALSE;
		Reset.Execute := FALSE;
		state := MOVESTATE_ENABLE;

	MOVESTATE_ENABLE :
		PowerAxis1.Enable := TRUE;
		PowerAxis1.Enable_Positive := TRUE;
		PowerAxis1.Enable_Negative := TRUE;
		IF PowerAxis1.Status THEN
			state := MOVESTATE_FORWARD;
		ELSIF PowerAxis1.Error THEN
			state := MOVESTATE_ERROR;
		END_IF
		
	MOVESTATE_IDLE:
		IF bMove THEN
// 			state := MOVESTATE_NEWTARGETPOSITION;
			HaltAxis1(axis := Axis1);
		END_IF

	MOVESTATE_FORWARD :		(* start to first position *)
		MoveAxis1(
			axis := Axis1,
			Position := 63,	
			Velocity := 2,	
			Execute := TRUE
		);
		
		IF NOT MoveAxis1.Busy THEN
			MoveAxis1(axis := Axis1, Execute := FALSE);		// If axis is not busy, then execute move
			IF MoveAxis1.Error THEN
				state := MOVESTATE_ERROR;
			ELSE
				state := SEL(NOT bMove AND nIdlePosition = 1, MOVESTATE_NEWTARGETPOSITION, MOVESTATE_IDLE);
			END_IF
		END_IF

	MOVESTATE_NEWTARGETPOSITION : // IDLE POS 2
		MoveAxis1(
			axis := Axis1,
			Position := 70,	
			Velocity := 2,	
			Execute := TRUE
		);
		
		IF NOT MoveAxis1.Busy THEN
			MoveAxis1(axis := Axis1, Execute := FALSE);
			IF MoveAxis1.Error THEN
				state := MOVESTATE_ERROR;
			ELSE
				state := SEL(NOT bMove AND nIdlePosition = 2, MOVESTATE_FORWARD, MOVESTATE_IDLE);
				(*If bMove=FALSE && nIdlePosition=2 then MOVESTATE_IDLE; else MOVESTATE_FORWARD*)
			END_IF
		END_IF

	MOVESTATE_ERROR :
		state := SEL(Axis1.Status.Error, MOVESTATE_INIT, MOVESTATE_RESET);

	MOVESTATE_RESET :
		Reset.Execute := TRUE;
		state := MOVESTATE_INIT;
END_CASE
	
PowerAxis1(axis := Axis1);
Reset(axis := Axis1);]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotorDosingPosition" Id="{000e46a7-d768-4af3-a8d9-7f99c3aface3}">
      <Declaration><![CDATA[METHOD MotorDosingPosition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotorLoadingPosition" Id="{e29b9f65-c08f-4666-b282-98670f3f7956}">
      <Declaration><![CDATA[METHOD MotorLoadingPosition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotorMain" Id="{f8963046-76f8-4fe8-abb9-a7a94c873c2a}">
      <Declaration><![CDATA[METHOD MotorMain : BOOL
VAR_INPUT
	bMove : BOOL;
	nIdlePosition : INT; // 1: 63, 2: 70
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[METH(bMove, nIdlePosition);
RETURN;

	(* update the axis status at the beginning of each cycle *)
	Axis1();

	(* move axis using a state machine *)
	CASE state OF

		MOVESTATE_INIT :	(* initialisation *)
			(* initialize all function blocks *)
			MoveAxis1.Execute := FALSE;
// 			MoveAxis2.Execute := FALSE;
			Reset.Execute := FALSE;
			state := MOVESTATE_ENABLE;

		MOVESTATE_ENABLE :
// 			PowerAxis1.Status := TRUE;
			PowerAxis1.Enable := TRUE;
			PowerAxis1.Enable_Positive := TRUE;
			PowerAxis1.Enable_Negative := TRUE;
			IF PowerAxis1.Status THEN
				state := MOVESTATE_FORWARD;
			ELSIF PowerAxis1.Error THEN
				state := MOVESTATE_ERROR;
			END_IF

		MOVESTATE_FORWARD :		(* start to first position *)
			MoveAxis1.Position := 63;		(* 1500 start to intermediate tartet position *)
			MoveAxis1.Velocity := 2;		(* 500 medium velocity level *)
			MoveAxis1.BufferMode := MC_Buffered;
			MoveAxis1.Execute := TRUE;
			
			IF MoveAxis1.Active  THEN
				(* axis is executing job but is not yet finished *)
				MoveAxis1.Execute := FALSE;
				(* leave this state and buffer a second command *)
				state := MOVESTATE_NEWTARGETPOSITION;
			ELSIF MoveAxis1.CommandAborted OR MoveAxis1.Error THEN
				state := MOVESTATE_ERROR;
			END_IF

		MOVESTATE_NEWTARGETPOSITION :		(* change target position while moving *)
			(* start a buffered motion command while axis is moving *)
			MoveAxis1.Position := 70;		(* 5000 start to final target *)
			MoveAxis1.Velocity := 2;		(* 1500 increase velocity *)
			MoveAxis1.BufferMode := MC_BlendingPrevious; 	(* use velocity of previous command till intermediate target position position *)
			MoveAxis1.Execute := TRUE;
			IF MoveAxis1.Done THEN
				MoveAxis1.Execute := FALSE;
				state := MOVESTATE_FORWARD;
			ELSIF MoveAxis1.CommandAborted OR MoveAxis1.Error THEN
				state := MOVESTATE_ERROR;
			END_IF

// 		MOVESTATE_BACKWARDS :	(* move back to initial position *)
// 			MoveAxis1.Position := 63;		(* position close to initial position *)
// 			MoveAxis1.Velocity := 2;		(* high velocity *)
// 			MoveAxis1.BufferMode := MC_Buffered;
// 			MoveAxis1.Execute := TRUE;
// 			IF MoveAxis1.Active THEN
// 				(* axis is executing job but is not yet finished *)
// 				MoveAxis1.Execute := FALSE;
// 				(* leave this state and buffer a second command *)
// 				state := MOVESTATE_BACKWARDSSLOW;
// 			ELSIF MoveAxis1.CommandAborted OR MoveAxis1.Error THEN
// 				state := MOVESTATE_ERROR;
// 			END_IF
// 
// 		MOVESTATE_BACKWARDSSLOW :	(* move back to initial position *)
// 			(* start a buffered motion command while axis is moving *)
// 			MoveAxis2.Position := 70;	(* back to initial position *)
// 			MoveAxis2.Velocity := 2; 	(* slow velocity *)
// 			MoveAxis2.BufferMode := MC_BlendingNext; 	(* use velocity from first target position *)
// 			MoveAxis2.Execute := TRUE;
// 			IF MoveAxis2.Done THEN
// 				MoveAxis2.Execute := FALSE;
// 				state := MOVESTATE_FORWARD;
// 			ELSIF MoveAxis2.CommandAborted OR MoveAxis2.Error THEN
// 				state := MOVESTATE_ERROR;
// 			END_IF

		MOVESTATE_ERROR :
			IF Axis1.Status.Error THEN
				state := MOVESTATE_RESET;	(* axis error requires reset *)
			ELSE
				state := MOVESTATE_INIT;		(* function block errors don't need a reset *)
			END_IF

		MOVESTATE_RESET :
			Reset.Execute := TRUE;
			IF Reset.Done THEN
				state := MOVESTATE_INIT;
			ELSIF Reset.Error THEN
				state := MOVESTATE_INIT; (* can't do anything here *)
			END_IF

	END_CASE
	
PowerAxis1(axis := Axis1);
MoveAxis1(axis := Axis1);
Reset(axis := Axis1);
// 
// 	fbMotor.EnablePower();	(* call the power function block *)
// 	fbMotor.MotorDosingPosition();	(* call the move function block *)
// 	fbMotor.MotorLoadingPosition();	(* call the reset function block *)
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>