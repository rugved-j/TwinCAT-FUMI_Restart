<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotorJog" Id="{572e2650-5346-4e2a-bd24-17aaf2aabb29}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MotorJog EXTENDS FB_SolidSamplingModule
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	
	/// axis reference data structure 
	Axis1: AXIS_REF;
	/// state machine state 
	state: MoveState_t;
	PowerAxis1: MC_Power;
	/// debug function block output data 
	PowerAxis1Out: ST_McOutputs;
	MoveAxis1: MC_MoveAbsolute;
	/// debug function block output data 
	MoveAbsoluteOut1: ST_McOutputs;
// 	MoveAxis2: MC_MoveAbsolute;
	/// debug function block output data 
// 	MoveAbsoluteOut2: ST_McOutputs;
	Reset: MC_Reset;
	/// debug function block output data 
	ResetOut: ST_McOutputs;
	
	HaltAxis1: MC_Halt;
	fbRobot		: FB_Robot;
	fbRise		: R_TRIG;
	bPulse		: BOOL;
	bEnable	:	BOOL := FALSE;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="EnablePower" Id="{bbd8026d-cdfa-44b8-9db6-db11045b5e31}">
      <Declaration><![CDATA[METHOD EnablePower : BOOL
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Axis1.ReadStatus();

PowerAxis1(
	Axis:=Axis1, 
	Enable:= bEnable, 
	Status=> , 
	Busy=> , 
	Active=> , 
	Error=> , 
	ErrorID=> );]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotorDosingPosition" Id="{000e46a7-d768-4af3-a8d9-7f99c3aface3}">
      <Declaration><![CDATA[METHOD MotorDosingPosition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotorLoadingPosition" Id="{e29b9f65-c08f-4666-b282-98670f3f7956}">
      <Declaration><![CDATA[METHOD MotorLoadingPosition : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotorMain" Id="{f8963046-76f8-4fe8-abb9-a7a94c873c2a}">
      <Declaration><![CDATA[METHOD MotorMain : BOOL
VAR_INPUT
	bMove : BOOL;
	nIdlePosition : INT; // 1: 63, 2: 70
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MotorMove(bMove);
RETURN;

IF nIdlePosition < 1 OR nIdlePosition > 2 THEN		// Rejects other Position values
	nIdlePosition := 1;
END_IF

	(* update the axis status at the beginning of each cycle *)
	Axis1();

	(* move axis using a state machine *)
	CASE state OF

		MOVESTATE_INIT :	(* initialisation *)
			MoveAxis1.Execute := FALSE;
			Reset.Execute := FALSE;
			state := MOVESTATE_ENABLE;

		MOVESTATE_ENABLE :
			PowerAxis1.Enable := TRUE;
			PowerAxis1.Enable_Positive := TRUE;
			PowerAxis1.Enable_Negative := TRUE;
			IF PowerAxis1.Status THEN
				state := MOVESTATE_FORWARD;
			ELSIF PowerAxis1.Error THEN
				state := MOVESTATE_ERROR;
			END_IF

		MOVESTATE_FORWARD :		(* start to first position *)
		MoveAxis1(
			axis := Axis1,
			Position := 63,	
			Velocity := 2,	
			Execute := TRUE
		);
		
		IF NOT MoveAxis1.Busy THEN
			MoveAxis1(axis := Axis1, Execute := FALSE);		// If axis is not busy, then execute move
			IF MoveAxis1.Error THEN
				state := MOVESTATE_ERROR;
			ELSE
				state := SEL(NOT bMove AND nIdlePosition = 1, MOVESTATE_NEWTARGETPOSITION, MOVESTATE_IDLE);
			(*If bMove=false and nIdlePosition=1, Movestate Idle, else NEWTARGETPOSITION*)
			END_IF
		END_IF

		MOVESTATE_NEWTARGETPOSITION :		(* change target position while moving *)
			MoveAxis1(
			axis := Axis1,
			Position := 55,	
			Velocity := 2,	
			Execute := TRUE
		);
		
		IF NOT MoveAxis1.Busy THEN
			MoveAxis1(axis := Axis1, Execute := FALSE);
			IF MoveAxis1.Error THEN
				state := MOVESTATE_ERROR;
			ELSE
				state := SEL(NOT bMove AND nIdlePosition = 2, MOVESTATE_FORWARD, MOVESTATE_IDLE);
				(*If bMove=FALSE && nIdlePosition=2 then MOVESTATE_IDLE; else MOVESTATE_FORWARD*)
			END_IF
		END_IF

		MOVESTATE_IDLE:
			HaltAxis1(axis := Axis1);
			
// 				IF bMove THEN
// 					state := MOVESTATE_NEWTARGETPOSITION;
// 		// 			HaltAxis1(axis := Axis1);	
// 				END_IF
				
		MOVESTATE_ERROR :
			state := SEL(Axis1.Status.Error, MOVESTATE_INIT, MOVESTATE_RESET);

		MOVESTATE_RESET :
// 			Reset.Execute := TRUE;
// 			IF Reset.Done THEN
// 				state := MOVESTATE_INIT;
// 			ELSIF Reset.Error THEN
// 				state := MOVESTATE_INIT; (* can't do anything here *)
// 			END_IF
			Reset.Execute := TRUE;
			state := MOVESTATE_INIT;

	END_CASE
	
PowerAxis1(axis := Axis1);
Reset(axis := Axis1);
// 
// 	fbMotor.EnablePower();	(* call the power function block *)
// 	fbMotor.MotorDosingPosition();	(* call the move function block *)
// 	fbMotor.MotorLoadingPosition();	(* call the reset function block *)
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MotorMove" Id="{4f1f4daf-18c2-495e-94c9-7298abe5d79b}">
      <Declaration><![CDATA[METHOD MotorMove : BOOL
VAR_INPUT
	bMove : BOOL;
// 	nIdlePosition : INT; // 1: 63, 2: 70
END_VAR

VAR
	bLoadingPosition	: BOOL := process_gvl.fRobotInput.General_Bits.GPBitIN_15;
	bDosingPosition	: BOOL := process_gvl.fRobotInput.General_Bits.GPBitIN_16;
	trLoad      : R_TRIG;   // edge on bit 15
	trDose   	: R_TRIG;	// edge on bit 16
    bExecIssued : BOOL;     // latched once Busy=TRUE
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// IF nIdlePosition < 1 OR nIdlePosition > 2 THEN		// Rejects other Position values
// 	nIdlePosition := 1;
// END_IF

Axis1();

CASE state OF
	MOVESTATE_INIT :	(* initialisation *)
		MoveAxis1.Execute := FALSE;
		Reset.Execute := FALSE;
		state := MOVESTATE_ENABLE;

	MOVESTATE_ENABLE :
		PowerAxis1.Enable := TRUE;
		PowerAxis1.Enable_Positive := TRUE;
		PowerAxis1.Enable_Negative := TRUE;
		IF PowerAxis1.Status THEN
// 			state := MOVESTATE_FORWARD;
			state := MOVESTATE_IDLE;
		ELSIF PowerAxis1.Error THEN
			state := MOVESTATE_ERROR;
		END_IF
		
	MOVESTATE_IDLE:	
		process_gvl.bMotorHalted := FALSE;	
		trLoad(CLK := process_gvl.fRobotInput.General_Bits.GPBitIN_15<>0);
		trDose(CLK := process_gvl.fRobotInput.General_Bits.GPBitIN_16<>0);
		
		IF trLoad.Q THEN
			state := MOVESTATE_FORWARD;
			bExecIssued := FALSE;   // prepare new command
		ELSIF trDose.Q THEN
			state := MOVESTATE_NEWTARGETPOSITION;
			bExecIssued := FALSE;
		ELSE
			state := MOVESTATE_IDLE;
		END_IF
		
	MOVESTATE_FORWARD :		(* start to first position *)        
		MoveAxis1(
			axis := Axis1,
			Position := 58,	
			Velocity := 2,	
			Execute := TRUE
		);
		IF NOT bExecIssued THEN
		// Present Execute until the FB acknowledges (Busy=TRUE once)
		MoveAxis1(axis := Axis1, Execute := FALSE); // If axis is not busy, then execute move  
		IF NOT MoveAxis1.Busy THEN 
				bExecIssued := TRUE;     // command has started
		END_IF 
		ELSE
			 // After start, keep calling with Execute FALSE
			 MoveAxis1(Axis := Axis1, Execute := FALSE);
		END_IF
		IF MoveAxis1.Error THEN 
			state := MOVESTATE_ERROR; 
		ELSIF bExecIssued AND NOT MoveAxis1.Busy THEN
			// Finished successfully → choose next
			bExecIssued := FALSE;
			process_gvl.bMotorHalted := TRUE;
			state := SEL(bMove, MOVESTATE_NEWTARGETPOSITION, MOVESTATE_IDLE);
		END_IF
		
	MOVESTATE_NEWTARGETPOSITION : // IDLE POS 2
	MoveAxis1(
			axis := Axis1,
			Position := 63,	
			Velocity := 2,	
			Execute := TRUE
		);
		IF NOT bExecIssued THEN 
			MoveAxis1(
				axis := Axis1, Execute := FALSE);
			IF NOT MoveAxis1.Busy THEN 
				bExecIssued := TRUE;
			END_IF
		ELSE
			MoveAxis1(Axis := Axis1, Execute := FALSE);	
		END_IF
		IF MoveAxis1.Error THEN 
			state := MOVESTATE_ERROR; 
		ELSIF  bExecIssued AND NOT MoveAxis1.Busy THEN
			bExecIssued := FALSE;
			process_gvl.bMotorHalted := TRUE;
			state := SEL(bMove, MOVESTATE_FORWARD, MOVESTATE_IDLE);
		END_IF 		

	MOVESTATE_ERROR :
		state := SEL(Axis1.Status.Error, MOVESTATE_INIT, MOVESTATE_RESET);

	MOVESTATE_RESET :
		Reset.Execute := TRUE;
		state := MOVESTATE_INIT;
END_CASE
	
PowerAxis1(axis := Axis1);
Reset(axis := Axis1);]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>