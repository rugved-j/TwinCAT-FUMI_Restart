<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_Camera" Id="{5dd9008b-c7f4-4e76-8185-09c16c8b52f8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Camera
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	    // Camera control
//     fbCam        :  FB_VN_SimpleCameraControl;
    eState       : ETcVnCameraState;
    hr           : HRESULT;

    // Software trigger (toggle TRUE → FALSE to grab one frame)
    bSoftTrig    : BOOL := FALSE;
    rSoftTrig    : R_TRIG;
    bPending     : BOOL := FALSE;

    // Images
    ipImageRaw   : ITcVnImage;               // raw from camera (Bayer GR8)
    ipImageGray  : ITcVnImage;               // grayscale after conversion
    ipImageRGB   : ITcVnImage;               // RGB canvas to draw on
    ipImageDisp  : ITcVnDisplayableImage;    // display handle for ADS
	ipImageDisp1 : ITcVnDisplayableImage;
// 	ipImageDispUndis : ITcVnDisplayableImage;
    // QR results
    ipDecoded    : ITcVnContainer;           // decoded data list
    ipContours   : ITcVnContainer;           // contours (for drawing)
    sQRCode      : STRING(255);

    // Drawing
    aRed         : TcVnVector4_LREAL := [0, 0, 255, 255];  // BGRA red
    font         : ETcVnFontType := TCVN_FT_HERSHEY_PLAIN;
	  clrRed			: TcVnVector4_LREAL := [255,0,0,255];
    clrBlue			: TcVnVector4_LREAL := [0,0,255,255];
	ipContour: ITcVnContainer;
	GetElementNum: INT;
	nPts: ULINT;
	nBufferSize: ULINT;

	i: INT;
	ptTmp: TcVnPoint2_LREAL;

	ptTL: TcVnPoint2_LREAL;
	ptTR: TcVnPoint2_LREAL;
	ptBR: TcVnPoint2_LREAL;
	ptBL: TcVnPoint2_LREAL;
	xTL, yTL, xTR, yTR, xBR, yBR, xBL, yBL : DINT;
	ptTL_L, ptTR_L, ptBR_L, ptBL_L : TcVnPoint2_LREAL;
	sMark : STRING(4) := '+';
// 	ipExtremePoints : ITcVnContainer;
	nContours : DINT := 0;
	ptTop: TcVnPoint2_LREAL;
	ptRight: TcVnPoint2_LREAL;
	ptLeft: TcVnPoint2_LREAL;
	ptBottom: TcVnPoint2_LREAL;
// 	
// 	// Camera calibration results
	aPointImage              :   ARRAY[0..3] OF TcVnPoint2_LREAL:= [ [0,0], [50,0], [0, 50], [50, 50] ]; //TcVnPoint2_LREAL
	aPointWorld              :   ARRAY[0..3] OF TcVnPoint3_LREAL; //TcVnPoint3_LREAL
	fbCam				  :   FB_VN_GevCameraControl;
	ipIterator				:	ITcVnForwardIterator;
	aCameraMatrix             :   TcVnMatrix3x3_LREAL;
	aDistortionCoefficients   :   TcVnArray8_LREAL;
	aRotationMatrix           :   TcVnMatrix3x3_LREAL;
	aTranslationVector        :   TcVnVector3_LREAL;
	bInit: BOOL := TRUE;
	aCoordinatesWorld		:	ARRAY[0..4] OF TcVnPoint3_LREAL;
	aCoordinatesImage		:	ARRAY[0..4] OF TcVnPoint2_LREAL;
	aLine: TcVnVector4_DINT;
	aColorGreen: TcVnVector4_LREAL;
	ipImageRes: ITcVnImage;
// 	i					: INT;
	counter				: INT;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="DetectQRCode" Id="{82243952-66c7-4357-a30a-e28449390f85}">
      <Declaration><![CDATA[METHOD DetectQRCode : BOOL
VAR
// 	fbQrCode	:	FB_Camera;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// process_gvl.fCameraControl.eCameraState :=process_gvl.fCameraControl.fbCameraControl.GetState();
// 
// process_gvl.fCameraControl.hr := F_VN_ReadQRCode(
// 				process_gvl.fCameraControl.ipImageIn,
// 				process_gvl.fCameraControl.ipDecodedData,
// // 				process_gvl.fCameraControl.ipContours,
// // 				process_gvl.fCameraControl.nCodeNumber,
// // 				process_gvl.fCameraControl.eSearchStrategy,
// // 				process_gvl.fCameraControl.ipAngles,
// 				process_gvl.fCameraControl.hr);
				
				
				]]></ST>
      </Implementation>
    </Method>
    <Method Name="EstimatePose" Id="{5ce97ce8-47dc-4044-9d0a-d7addc7f0154}">
      <Declaration><![CDATA[METHOD EstimatePose : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="TriggerCamera" Id="{9802e0e5-f872-4b06-8a83-9f3b0e36212d}">
      <Declaration><![CDATA[METHOD TriggerCamera : BOOL
VAR
	

END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Read the Calibration Params from the Image Provider
IF bInit THEN
	bInit := FALSE;
	hr := fbCam.GetCameraMatrix(aCameraMatrix);
	hr := fbCam.GetDistortionCoefficients(aDistortionCoefficients);
	hr := fbCam.GetRotationMatrix(aRotationMatrix);
	hr := fbCam.GetTranslationVector(aTranslationVector);
END_IF


eState := fbCam.GetState();

CASE eState OF
    TCVN_CS_ERROR:
        hr := fbCam.Reset();

    TCVN_CS_INITIAL, TCVN_CS_INITIALIZING, TCVN_CS_INITIALIZED,
    TCVN_CS_OPENING, TCVN_CS_OPENED, TCVN_CS_STARTACQUISITION:
        hr := fbCam.StartAcquisition();
END_CASE
// When acquiring, do software trigger → grab → process
IF eState = TCVN_CS_ACQUIRING THEN
    // rising edge on software trigger
    rSoftTrig(CLK := bSoftTrig);
    IF rSoftTrig.Q THEN
        hr := fbCam.TriggerImage();
        bPending := TRUE;
    END_IF

    IF bPending THEN
        // get the newly triggered frame (Bayer GR8 from camera)
        hr := fbCam.GetCurrentImage(ipImageRaw);
		
        IF SUCCEEDED(hr) AND (ipImageRaw <> 0) THEN
				
            // 1) Bayer GR8 -> GRAY
            hr := F_VN_ConvertColorSpace(
                    ipSrcImage := ipImageRaw,
                    ipDestImage := ipImageGray,
                    eTransform := TCVN_CST_BAYER_GR_TO_GRAY,
                    hrPrev := hr);
			
            // 2) Detect QR on the GRAY image (also ask for contours)
            hr := F_VN_ReadQRCodeExp(
                    ipSrcImage      := ipImageGray,
                    ipDecodedData   := ipDecoded,
                    ipContours      := ipContours,
                    nCodeNumber     := 1,    // read just one (simplest)
                    eSearchStrategy := TCVN_CSS_ONLY_NOT_INVERTED + TCVN_CSS_ONLY_NOT_FLIPPED,
//  					eSearchStrategy := TCVN_CSS_DEFAULT,
// 					ipAngles		:= 0,
                    hrPrev          := hr);
			IF ipDecoded<>0 AND ipContours<>0 THEN
            // 3) Make an RGB canvas from GRAY for colored drawing/text
            hr := F_VN_ConvertColorSpace(
                    ipSrcImage := ipImageGray,
                    ipDestImage := ipImageRGB,
                    eTransform := TCVN_CST_GRAY_TO_RGB,
                    hrPrev := hr);
			ELSE
				counter:=counter+1;
			END_IF
            // 4) If we got a QR, export text, draw border, overlay text
            IF (hr = S_OK) AND (ipDecoded <> 0) THEN
                // decoded string
                hr := F_VN_ExportSubContainer_String(
                        ipContainer := ipDecoded,
                        nIndex := 0,
                        sText := sQRCode,
                        nMaxLength := SIZEOF(sQRCode)-1,
                        hrPrev := hr);

                // draw contour(s) in red (line thickness = 3)
                IF (hr = S_OK) AND (ipContours <> 0)THEN
                    hr := F_VN_DrawContours(ipContours, -1, ipImageRGB, clrRed, 3, hr);
                END_IF
            END_IF
			
		
			// 5) Get first contour of ipContours, find its' extreme points, and draw them
			IF (ipContours <> 0) THEN
                ipContour := 0;
                hr := F_VN_GetAt_ITcVnContainer(ipContours, ipContour,0,hr);
                IF ipContour <> 0 THEN
                    // Count points & find TL/TR/BR/BL by extrema => INFO: Changed to top-most, left-most, bottom-most, and right-most points 
                    // The reason can be found in the description of each eDirection enum value (e.g. TCVN_EPD_TOP_LEFT => Search top-most point and if multiple exist search for the left-most of those)
					ipContour.GetElementNum(nPts);
					IF nPts > 0 THEN
						hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_TOP_LEFT,		aExtremePoint:=ptTop, hrPrev:=S_OK);
						hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_RIGHT_TOP,	aExtremePoint:=ptRight, hrPrev:=hr);
						hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_BOTTOM_RIGHT,	aExtremePoint:=ptBottom, hrPrev:=hr);						
						hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_LEFT_BOTTOM,	aExtremePoint:=ptLeft, hrPrev:=hr);
													

						IF hr = S_OK THEN
							hr := F_VN_DrawPointExp(TO_UDINT(ptTop[0]), TO_UDINT(ptTop[1]), ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);
							hr := F_VN_DrawPointExp(TO_UDINT(ptRight[0]), TO_UDINT(ptRight[1]), ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);
							hr := F_VN_DrawPointExp(TO_UDINT(ptBottom[0]), TO_UDINT(ptBottom[1]), ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);
							hr := F_VN_DrawPointExp(TO_UDINT(ptLeft[0]), TO_UDINT(ptLeft[1]), ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);
						END_IF
					END_IF
				END_IF
			END_IF
// 			hr := F_VN_GetForwardIterator(ipContour, ipIterator, hr);
			
// 			WHILE SUCCEEDED(hr) AND_THEN ipIterator.CheckIfEnd() <> S_OK DO
// 				hr := F_VN_GetContainer(ipIterator, ipContour, hr);
// 				hr := F_VN_IncrementIterator(ipIterator, hr);

// 				// Calculate the image position
// 				hr := F_VN_ContourCenterOfMass(ipContour, aPointImage, hr);	
				FOR i:=0 TO 3 DO
				// Coordinate Transformation to retrieve the real world position
				hr := F_VN_TransformCoordinatesImageToWorld_Point(
					aSrcPoint				:= aPointImage[i], 
					aDestPoint				:= aPointWorld[i], 
					aCameraMatrix			:= aCameraMatrix, 
					aDistortionCoefficients	:= aDistortionCoefficients, 
					aRotationMatrix			:= aRotationMatrix, 
					aTranslationVector		:= aTranslationVector, 
					fZ						:= 0, 
					hrPrev					:= hr);																							
				END_FOR
// 			END_WHILE
		
			// 6) Show in ADS Image Watch (display the annotated RGB)
// 			hr := F_VN_CopyIntoDisplayableImage(ipSrcImage:= ipImageRaw, ipDestImage:=ipImageDispUndis, hr );
			hr := F_VN_CopyIntoDisplayableImage(ipSrcImage:= ipImageRGB, ipDestImage:=ipImageDisp1, hr );
            hr := F_VN_TransformIntoDisplayableImage(ipImageRGB, ipImageDisp, hr);

            // cleanup for next trigger
            ipDecoded := 0;
            ipContours := 0;
            ipImageRaw := 0;
            ipImageGray := 0;
            ipImageRGB := 0;
            bPending := FALSE;
        END_IF
    END_IF
END_IF

]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>