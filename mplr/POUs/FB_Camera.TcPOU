<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_Camera" Id="{5dd9008b-c7f4-4e76-8185-09c16c8b52f8}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Camera
VAR_INPUT
	pRobot : POINTER TO FB_Robot;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	    // Camera control
//     fbCam        :  FB_VN_SimpleCameraControl;
    eState       : ETcVnCameraState;
    hr           : HRESULT;

    // Software trigger (toggle TRUE → FALSE to grab one frame)
    bSoftTrig    : BOOL := FALSE;
    rSoftTrig    : R_TRIG;
    bPending     : BOOL := FALSE;

    // Images
    ipImageRaw   : ITcVnImage;               // raw from camera (Bayer GR8)
    ipImageGray  : ITcVnImage;               // grayscale after conversion
    ipImageRGB   : ITcVnImage;               // RGB canvas to draw on
    ipImageDisp  : ITcVnDisplayableImage;    // display handle for ADS
	ipImageDisp1 : ITcVnDisplayableImage;
// 	ipImageDispUndis : ITcVnDisplayableImage;
    // QR results
    ipDecoded    : ITcVnContainer;           // decoded data list
    ipContours   : ITcVnContainer;           // contours (for drawing)
    sQRCode      : STRING(255);

    // Drawing
    aRed         : TcVnVector4_LREAL := [0, 0, 255, 255];  // BGRA red
    font         : ETcVnFontType := TCVN_FT_HERSHEY_PLAIN;
	  clrRed			: TcVnVector4_LREAL := [255,0,0,255];
    clrBlue			: TcVnVector4_LREAL := [0,0,255,255];
	ipContour: ITcVnContainer;
	GetElementNum: INT;
	nPts: ULINT;
	nBufferSize: ULINT;

	ptTop: TcVnPoint2_LREAL;
	ptRight: TcVnPoint2_LREAL;
	ptLeft: TcVnPoint2_LREAL;
	ptBottom: TcVnPoint2_LREAL;

	// Camera calibration results
	
	fbCam				  :   FB_VN_GevCameraControl;
	aCameraMatrix             :   TcVnMatrix3x3_LREAL;
	aDistortionCoefficients   :   TcVnArray8_LREAL;
	aRotationMatrix           :   TcVnMatrix3x3_LREAL;
	aTranslationVector        :   TcVnVector3_LREAL;
	bInit: BOOL := TRUE;
	aCoordinatesWorld		:	ARRAY[0..4] OF TcVnPoint3_LREAL;
	aCoordinatesImage		:	ARRAY[0..4] OF TcVnPoint2_LREAL;
	ipImageRes: ITcVnImage;
	
	// QR code Dictionary lookup variables
	// ring buffer for last 8 QR numbers
    aQrIds      : ARRAY[0..7] OF DINT;   // filled FIFO-style
    iQrWrite    : INT := 0;              // next write index (0..7)
    nQrCount    : INT := 0;              // Nr of valid items (0..8)
    idQr        : DINT;                  // parsed numeric QR id (from sQRCode)
    bNewQrPulse : BOOL;                  // one-scan pulse when we store a new id
	
	  // Pose result of the QR (object pose in camera coordinates)
    aTagR       : TcVnMatrix3x3_LREAL;   // rotation matrix (QR->camera)
    aTagT       : TcVnVector3_LREAL;     // translation vector (mm; QR->camera)
	rv   		: TcVnVector3_LREAL;
    // convenience: latches
    bHavePose   : BOOL;
	
	 // --- one-shot control
    bRunOnce    : BOOL := FALSE;    // toggle TRUE for one cycle to run the test
    bBusy       : BOOL := FALSE;
	
    // (optional) GP mapping guard
    bParsedOk   : BOOL;
	
	fQrSizeMM   : LREAL := 23.0;         // <<< set your QR edge length (mm)
    aPts3D      : ARRAY[0..3] OF TcVnPoint3_LREAL;   // model points (QR frame)
    aPts2D      : ARRAY[0..3] OF TcVnPoint2_LREAL;   // image points (pixels)
    ipObjPts    : ITcVnContainer;        // vector<TcVnPoint3_LREAL>
    ipImgPts    : ITcVnContainer;        // vector<TcVnPoint2_LREAL>
	
	ipObjectPoints : ITcVnContainer;   // vector<TcVnPoint3_LREAL>  (3D model points)
    ipImagePoints  : ITcVnContainer;   // vector<TcVnPoint2_LREAL>  (2D image points)
	bReprojError  : LREAL;

    // --- Intrinsics (we try to read them; else we synthesize)
    aK              : TcVnMatrix3x3_LREAL;         // camera matrix
//     aDist80          : TcVnArray8_LREAL := [0,0,0,0,0,0,0,0]; // distortion zeroed for the synthetic test
	aDist80      : ARRAY[0..7] OF LREAL;   // zeros by default
    // --- SolvePnP outputs
    aR              : TcVnMatrix3x3_LREAL;
    aTt             : TcVnVector3_LREAL;
    bSolved         : BOOL;
	
	    // 2D/3D points (REAL versions!)
    aPts2D_R : ARRAY[0..3] OF TcVnPoint2_REAL;
    aPts3D_R : ARRAY[0..3] OF TcVnPoint3_REAL;
	    // --- containers (must be REAL types per Exp signature)
    ipRefPts    : ITcVnContainer;   // vector<TcVnPoint3_REAL>
	bCalibReady     : BOOL := FALSE;
	
	fbMakeT : FB_CreateTransformationMat;
	fbMakeT_1 : FB_CreateTransformationMat;
//     R_matrix       : TcVnMatrix3x3_LREAL;
//     t_matrix       : TcVnVector3_LREAL;
    T4x4_matrix       : TcVnMatrix;
	T4x4_matrix_1	  : TcVnMatrix;
	T4x4_matrix_result	  : TcVnMatrix;
	fbConvert : FB_MatConversion;
	fbRob : FB_Robot;
	fbMultiplyMat		: FB_MultiplyMatrices4x4;
	
END_VAR
	
VAR_OUTPUT
	_pose : ST_PoseLREAL;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Property Name="Pose" Id="{178c9652-e0d5-4296-8ffd-15455e02fc44}">
      <Declaration><![CDATA[PROPERTY Pose : REFERENCE TO ST_PoseLREAL // Property to obtain pose of Tag w.r.t. camera



]]></Declaration>
      <Get Name="Get" Id="{1976b7ea-a666-4d14-96cf-c42e837a7fa9}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Pose REF= _pose;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{63df2a98-8a10-4e94-bd6c-4a01890bd9c0}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="QRCodefinal" Id="{ff59f934-43e6-4d05-ac42-873ca753f38f}">
      <Declaration><![CDATA[METHOD QRCodefinal : BOOL
VAR_INPUT
END_VAR

VAR
END_VAR

VAR_OUTPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// --- Provider state machine ---
eState := fbCam.GetState();

CASE eState OF
    TCVN_CS_ERROR:
        hr := fbCam.Reset();

    TCVN_CS_INITIAL, TCVN_CS_INITIALIZING, TCVN_CS_INITIALIZED,
    TCVN_CS_OPENING, TCVN_CS_OPENED, TCVN_CS_STARTACQUISITION:
        hr := fbCam.StartAcquisition();
END_CASE

// --- Read calibration once, when ACQUIRING ---
IF (eState = TCVN_CS_ACQUIRING) AND NOT bCalibReady THEN
    hr := fbCam.GetCameraMatrix(aCameraMatrix);
    IF SUCCEEDED(hr) THEN
        hr := fbCam.GetDistortionCoefficients(aDistortionCoefficients);  // length must match your calibration
    END_IF
    bCalibReady := SUCCEEDED(hr);
END_IF

// --- Work only when ACQUIRING ---
IF eState = TCVN_CS_ACQUIRING THEN

    // Software trigger (edge)
    rSoftTrig(CLK := bSoftTrig);
    IF rSoftTrig.Q THEN
        hr := fbCam.TriggerImage();
        bPending := TRUE;
    END_IF

    // One-shot trigger support (optional)
    IF bRunOnce AND NOT bBusy THEN
        bBusy := TRUE;
        hr := fbCam.TriggerImage();
        bPending := TRUE;
    END_IF

    IF bPending THEN
        hr := fbCam.GetCurrentImage(ipImageRaw);

        IF SUCCEEDED(hr) AND (ipImageRaw <> 0) THEN
            // 1) RAW (Bayer GR8) -> GRAY
            hr := F_VN_ConvertColorSpace(
                    ipSrcImage := ipImageRaw,
                    ipDestImage := ipImageGray,
                    eTransform := TCVN_CST_BAYER_GR_TO_GRAY,
                    hrPrev := hr);

            // 2) QR decode (+ contours)
            hr := F_VN_ReadQRCodeExp(
                    ipSrcImage      := ipImageGray,
                    ipDecodedData   := ipDecoded,
                    ipContours      := ipContours,
                    nCodeNumber     := 1,
                    eSearchStrategy := TCVN_CSS_ONLY_NOT_INVERTED + TCVN_CSS_ONLY_NOT_FLIPPED,
                    hrPrev          := hr);

            // 3) Prepare RGB canvas if something was found
            IF (ipDecoded <> 0) AND (ipContours <> 0) THEN
                hr := F_VN_ConvertColorSpace(
                        ipSrcImage := ipImageGray,
                        ipDestImage := ipImageRGB,
                        eTransform := TCVN_CST_GRAY_TO_RGB,
                        hrPrev := hr);
            END_IF

            // 4) If decoded, export text, draw contour, store ID
            IF SUCCEEDED(hr) AND (ipDecoded <> 0) THEN
                hr := F_VN_ExportSubContainer_String(
                        ipContainer := ipDecoded,
                        nIndex := 0,
                        sText := sQRCode,
                        nMaxLength := SIZEOF(sQRCode)-1,
                        hrPrev := hr);

                IF SUCCEEDED(hr) AND (ipContours <> 0) THEN
                    hr := F_VN_DrawContours(ipContours, -1, ipImageRGB, clrRed, 3, hr);
                END_IF

                // push into ring buffer (no validation here; add if needed)
                idQr := STRING_TO_DINT(sQRCode);
                aQrIds[iQrWrite] := idQr;
                iQrWrite := (iQrWrite + 1) MOD 8;
                IF nQrCount < 8 THEN nQrCount := nQrCount + 1; END_IF
            END_IF

            // 5) Extract QR corner points (TL, TR, BR, BL)
            IF (ipContours <> 0) THEN
                ipContour := 0;
                hr := F_VN_GetAt_ITcVnContainer(ipContours, ipContour, 0, hr);

                IF (ipContour <> 0) THEN
                    ipContour.GetElementNum(nPts);

                    IF nPts > 0 THEN
                        // Extremes → TL, TR, BR, BL
                        hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_TOP_LEFT,     aExtremePoint:=ptTop,    hrPrev:=S_OK);
                        hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_RIGHT_TOP,    aExtremePoint:=ptRight,  hrPrev:=hr);
                        hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_BOTTOM_RIGHT, aExtremePoint:=ptBottom, hrPrev:=hr);
                        hr := F_VN_ContourExtremePoint(ipContour:=ipContour, eDirection:=TCVN_EPD_LEFT_BOTTOM,  aExtremePoint:=ptLeft,   hrPrev:=hr);

                        IF SUCCEEDED(hr) THEN
                            // draw corner marks
                            hr := F_VN_DrawPointExp(TO_UDINT(ptTop[0]),    TO_UDINT(ptTop[1]),    ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);
                            hr := F_VN_DrawPointExp(TO_UDINT(ptRight[0]),  TO_UDINT(ptRight[1]),  ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);
                            hr := F_VN_DrawPointExp(TO_UDINT(ptBottom[0]), TO_UDINT(ptBottom[1]), ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);
                            hr := F_VN_DrawPointExp(TO_UDINT(ptLeft[0]),   TO_UDINT(ptLeft[1]),   ipImageRGB, TCVN_DS_PLUS, clrBlue, 5, -1, TCVN_LT_4_CONNECTED, hr);

                            // --- Build 3D model (REAL) TL,TR,BR,BL (Z=0 plane) ---
                            aPts3D_R[0][0] := LREAL_TO_REAL(-fQrSizeMM*0.5);  aPts3D_R[0][1] := LREAL_TO_REAL(-fQrSizeMM*0.5);  aPts3D_R[0][2] := 0.0;
                            aPts3D_R[1][0] := LREAL_TO_REAL( fQrSizeMM*0.5);  aPts3D_R[1][1] := LREAL_TO_REAL(-fQrSizeMM*0.5);  aPts3D_R[1][2] := 0.0;
                            aPts3D_R[2][0] := LREAL_TO_REAL( fQrSizeMM*0.5);  aPts3D_R[2][1] := LREAL_TO_REAL( fQrSizeMM*0.5);  aPts3D_R[2][2] := 0.0;
                            aPts3D_R[3][0] := LREAL_TO_REAL(-fQrSizeMM*0.5);  aPts3D_R[3][1] := LREAL_TO_REAL( fQrSizeMM*0.5);  aPts3D_R[3][2] := 0.0;

                            // --- 2D image points (REAL) in the same order ---
                            aPts2D_R[0][0] := LREAL_TO_REAL(ptTop[0]);    aPts2D_R[0][1] := LREAL_TO_REAL(ptTop[1]);
                            aPts2D_R[1][0] := LREAL_TO_REAL(ptRight[0]);  aPts2D_R[1][1] := LREAL_TO_REAL(ptRight[1]);
                            aPts2D_R[2][0] := LREAL_TO_REAL(ptBottom[0]); aPts2D_R[2][1] := LREAL_TO_REAL(ptBottom[1]);
                            aPts2D_R[3][0] := LREAL_TO_REAL(ptLeft[0]);   aPts2D_R[3][1] := LREAL_TO_REAL(ptLeft[1]);

                            // --- Create REAL containers and fill ---
                            ipRefPts := 0; ipImgPts := 0;
                            hr := F_VN_CreateContainer(ipRefPts, ContainerType_Vector_TcVnPoint3_REAL, 4, hr);
                            IF SUCCEEDED(hr) THEN
                                hr := F_VN_CreateContainer(ipImgPts, ContainerType_Vector_TcVnPoint2_REAL, 4, hr);
                            END_IF

                            IF SUCCEEDED(hr) THEN
                                hr := F_VN_SetAt_TcVnPoint3_REAL(aPts3D_R[0], ipRefPts, 0, hr);
                                hr := F_VN_SetAt_TcVnPoint3_REAL(aPts3D_R[1], ipRefPts, 1, hr);
                                hr := F_VN_SetAt_TcVnPoint3_REAL(aPts3D_R[2], ipRefPts, 2, hr);
                                hr := F_VN_SetAt_TcVnPoint3_REAL(aPts3D_R[3], ipRefPts, 3, hr);

                                hr := F_VN_SetAt_TcVnPoint2_REAL(aPts2D_R[0], ipImgPts, 0, hr);
                                hr := F_VN_SetAt_TcVnPoint2_REAL(aPts2D_R[1], ipImgPts, 1, hr);
                                hr := F_VN_SetAt_TcVnPoint2_REAL(aPts2D_R[2], ipImgPts, 2, hr);
                                hr := F_VN_SetAt_TcVnPoint2_REAL(aPts2D_R[3], ipImgPts, 3, hr);
                            END_IF

                            // --- SolvePnP (Exp) → full 6D pose ---
                            bHavePose := FALSE;
                            IF SUCCEEDED(hr) AND bCalibReady THEN
                                hr := F_VN_SolvePnPExp(
                                        ipImagePoints           := ipImgPts,
                                        ipReferencePoints       := ipRefPts,
                                        aCameraMatrix           := aCameraMatrix,
                                        aDistortionCoefficients := aDistortionCoefficients, // exact length!
                                        aRotationMatrix         := aTagR,
                                        aTranslationVector      := aTagT,
                                        fReprojError            := bReprojError,
                                        eMethod                 := TCVN_SPM_ITERATIVE,      // your build
                                        bUseExtrinsicGuess      := FALSE,
                                        hrPrev                  := hr);

                                bHavePose := SUCCEEDED(hr);
								
								IF bHavePose THEN
									rv := fbConvert.RmatToRotVec(aTagR);
									// Create Transformation matrix using aTagR and aTagT.
								 	_pose.R_Mat := aTagR; //Rotation matrix
									_pose.T_Mat := aTagT; //Translation matrix
									
									fbMakeT.R_mat := _pose.R_Mat;
									fbMakeT.t_mat := _pose.T_Mat;
									fbMakeT();
									// outputs a valid TcVnMatrix pointing to internal 4x4 LREALs
									T4x4_matrix := fbMakeT.Tx_mat;				
// 									T4x4_matrix_1:=fbRob.RobotPose();  // error
									
									fbRob.RobotPose();				
									_pose.R_Mat := fbRob.r1_matrix;
									_pose.T_Mat := fbRob.v1_matrix;

									fbMakeT_1.R_mat := _pose.R_Mat;
									fbMakeT_1.t_mat := _pose.T_Mat;
									fbMakeT_1();
									
									T4x4_matrix_1:= fbMakeT_1.Tx_mat;
									
(*Multiply cam_T_qr to base_T_tcp*)
									fbMultiplyMat(M1:=T4x4_matrix, M2:=T4x4_matrix_1);	 
									T4x4_matrix_result := fbMultiplyMat.M_result;
(*Multiply xx_T_xx to xx_T_xx*)
									process_gvl.fRobotOutput.General_Register1.Floats.Floats[3] := LREAL_TO_REAL(aTagT[0]);
									process_gvl.fRobotOutput.General_Register1.Floats.Floats[4] := LREAL_TO_REAL(aTagT[1]);
									process_gvl.fRobotOutput.General_Register1.Floats.Floats[5] := LREAL_TO_REAL(aTagT[2]);
									process_gvl.fRobotOutput.General_Register1.Floats.Floats[0] := LREAL_TO_REAL(rv[0]);
									process_gvl.fRobotOutput.General_Register1.Floats.Floats[1] := LREAL_TO_REAL(rv[1]);
									process_gvl.fRobotOutput.General_Register1.Floats.Floats[2] := LREAL_TO_REAL(rv[2]);
									
								END_IF
                            END_IF

                            // tidy temp containers
                            ipRefPts := 0; ipImgPts := 0;
                        END_IF
                    END_IF
                END_IF
            END_IF

            // 6) Show in ADS Image Watch
            hr := F_VN_CopyIntoDisplayableImage(ipSrcImage:= ipImageRGB, ipDestImage:=ipImageDisp1, hr );
            hr := F_VN_TransformIntoDisplayableImage(ipImageRGB, ipImageDisp, hr);

            // cleanup for next trigger
            ipDecoded    := 0;
            ipContours   := 0;
            ipImageRaw   := 0;
            ipImageGray  := 0;
            ipImageRGB   := 0;
            bPending     := FALSE;
        END_IF
    END_IF
END_IF

// allow one-shot retrigger
IF NOT bRunOnce THEN
    bBusy := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>